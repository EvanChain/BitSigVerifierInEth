(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.MyLib = {}));
})(this, function(exports) {
  "use strict";var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

  var _r, _s, _v, _networkV, _a, _privateKey;
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getAugmentedNamespace(n2) {
    if (n2.__esModule)
      return n2;
    var f2 = n2.default;
    if (typeof f2 == "function") {
      var a = function a2() {
        if (this instanceof a2) {
          return Reflect.construct(f2, arguments, this.constructor);
        }
        return f2.apply(this, arguments);
      };
      a.prototype = f2.prototype;
    } else
      a = {};
    Object.defineProperty(a, "__esModule", { value: true });
    Object.keys(n2).forEach(function(k2) {
      var d = Object.getOwnPropertyDescriptor(n2, k2);
      Object.defineProperty(a, k2, d.get ? d : {
        enumerable: true,
        get: function() {
          return n2[k2];
        }
      });
    });
    return a;
  }
  var buffer$2 = {};
  var base64Js = {};
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0; i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output2 = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output2.push(tripletToBase64(tmp));
    }
    return output2.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  var ieee754 = {};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  ieee754.read = function(buffer2, offset, isLE2, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE2 ? nBytes - 1 : 0;
    var d = isLE2 ? -1 : 1;
    var s2 = buffer2[offset + i2];
    i2 += d;
    e = s2 & (1 << -nBits) - 1;
    s2 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s2 ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  ieee754.write = function(buffer2, value, offset, isLE2, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE2 ? 0 : nBytes - 1;
    var d = isLE2 ? 1 : -1;
    var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
    }
    buffer2[offset + i2 - d] |= s2 * 128;
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(exports2) {
    const base64 = base64Js;
    const ieee754$1 = ieee754;
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto2 = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto2, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto2);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength2(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i2 = 0; i2 < length; i2 += 1) {
        buf[i2] = array[i2] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len2 = checked(obj.length) | 0;
        const buf = createBuffer(len2);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len2);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN2(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i2 = 0, len2 = Math.min(x, y); i2 < len2; ++i2) {
        if (a[i2] !== b[i2]) {
          x = a[i2];
          y = b[i2];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding2(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat2(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i2;
      if (length === void 0) {
        length = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length += list[i2].length;
        }
      }
      const buffer2 = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        let buf = list[i2];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer2.isBuffer(buf))
              buf = Buffer2.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength2(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len2 = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len2 === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len2;
          case "utf8":
          case "utf-8":
            return utf8ToBytes2(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len2 * 2;
          case "hex":
            return len2 >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes2(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength2;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n2, m) {
      const i2 = b[n2];
      b[n2] = b[m];
      b[m] = i2;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len2 = this.length;
      if (len2 % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i2 = 0; i2 < len2; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len2 = this.length;
      if (len2 % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i2 = 0; i2 < len2; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len2 = this.length;
      if (len2 % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i2 = 0; i2 < len2; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max2 = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max2)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len2 = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i2 = 0; i2 < len2; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x = thisCopy[i2];
          y = targetCopy[i2];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN2(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i3) {
        if (indexSize === 1) {
          return buf[i3];
        } else {
          return buf.readUInt16BE(i3 * indexSize);
        }
      }
      let i2;
      if (dir) {
        let foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i2 + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i2;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes2(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i2;
      for (i2 = 0; i2 < length; ++i2) {
        const parsed = parseInt(string.substr(i2 * 2, 2), 16);
        if (numberIsNaN2(parsed))
          return i2;
        buf[offset + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes2(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i2 = start;
      while (i2 < end) {
        const firstByte = buf[i2];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len2 = codePoints.length;
      if (len2 <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i2 = 0;
      while (i2 < len2) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len2 = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len2)
        end = len2;
      let out = "";
      for (let i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf[i2]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes2 = buf.slice(start, end);
      let res = "";
      for (let i2 = 0; i2 < bytes2.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes2[i2] + bytes2[i2 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice2(start, end) {
      const len2 = this.length;
      start = ~~start;
      end = end === void 0 ? len2 : ~~end;
      if (start < 0) {
        start += len2;
        if (start < 0)
          start = 0;
      } else if (start > len2) {
        start = len2;
      }
      if (end < 0) {
        end += len2;
        if (end < 0)
          end = 0;
      } else if (end > len2) {
        end = len2;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength3 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      let val = this[offset + --byteLength3];
      let mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 24);
      const hi = this[++offset] + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + last * __pow(2, 24);
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + this[++offset];
      const lo = this[++offset] * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength3 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      let i2 = byteLength3;
      let mul = 1;
      let val = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * __pow(2, 8) + this[offset + 6] * __pow(2, 16) + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 24));
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max2, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max2 || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      let mul = 1;
      let i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength3 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      let i2 = byteLength3 - 1;
      let mul = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max2) {
      checkIntBI(value, min, max2, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max2) {
      checkIntBI(value, min, max2, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      let i2 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      let i2 = byteLength3 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max2, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len2 = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len2;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len2 = bytes2.length;
        if (len2 === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes2[i2 % len2];
        }
      }
      return this;
    };
    const errors2 = {};
    function E(sym, getMessage, Base2) {
      errors2[sym] = class NodeError extends Base2 {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name2) {
        if (name2) {
          return `${name2} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name2, actual) {
        return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range2, input2) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input2;
        if (Number.isInteger(input2) && Math.abs(input2) > __pow(2, 32)) {
          received = addNumericalSeparator(String(input2));
        } else if (typeof input2 === "bigint") {
          received = String(input2);
          if (input2 > __pow(BigInt(2), BigInt(32)) || input2 < -__pow(BigInt(2), BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range2}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i2 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i2 >= start + 4; i2 -= 3) {
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      }
      return `${val.slice(0, i2)}${res}`;
    }
    function checkBounds(buf, offset, byteLength3) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
        boundsError(offset, buf.length - (byteLength3 + 1));
      }
    }
    function checkIntBI(value, min, max2, buf, offset, byteLength3) {
      if (value > max2 || value < min) {
        const n2 = typeof min === "bigint" ? "n" : "";
        let range2;
        if (byteLength3 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range2 = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
          } else {
            range2 = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
          }
        } else {
          range2 = `>= ${min}${n2} and <= ${max2}${n2}`;
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range2, value);
      }
      checkBounds(buf, offset, byteLength3);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length, type2) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type2);
        throw new errors2.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE(
        type2 || "offset",
        `>= ${type2 ? 1 : 0} and <= ${length}`,
        value
      );
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes2(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes2 = [];
      for (let i2 = 0; i2 < length; ++i2) {
        codePoint = string.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes2.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes2.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes2.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes2.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes2;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        byteArray.push(str.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i2);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset, length) {
      let i2;
      for (i2 = 0; i2 < length; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src2.length)
          break;
        dst[i2 + offset] = src2[i2];
      }
      return i2;
    }
    function isInstance(obj, type2) {
      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
    }
    function numberIsNaN2(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i2 = 0; i2 < 16; ++i2) {
        const i16 = i2 * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i2] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  })(buffer$2);
  const version$3 = "6.11.1";
  function checkType(value, type2, name2) {
    const types2 = type2.split("|").map((t) => t.trim());
    for (let i2 = 0; i2 < types2.length; i2++) {
      switch (type2) {
        case "any":
          return;
        case "bigint":
        case "boolean":
        case "number":
        case "string":
          if (typeof value === type2) {
            return;
          }
      }
    }
    const error = new Error(`invalid value for type ${type2}`);
    error.code = "INVALID_ARGUMENT";
    error.argument = `value.${name2}`;
    error.value = value;
    throw error;
  }
  function defineProperties$1(target, values, types2) {
    for (let key2 in values) {
      let value = values[key2];
      const type2 = types2 ? types2[key2] : null;
      if (type2) {
        checkType(value, type2, key2);
      }
      Object.defineProperty(target, key2, { enumerable: true, value, writable: false });
    }
  }
  function stringify(value) {
    if (value == null) {
      return "null";
    }
    if (Array.isArray(value)) {
      return "[ " + value.map(stringify).join(", ") + " ]";
    }
    if (value instanceof Uint8Array) {
      const HEX = "0123456789abcdef";
      let result = "0x";
      for (let i2 = 0; i2 < value.length; i2++) {
        result += HEX[value[i2] >> 4];
        result += HEX[value[i2] & 15];
      }
      return result;
    }
    if (typeof value === "object" && typeof value.toJSON === "function") {
      return stringify(value.toJSON());
    }
    switch (typeof value) {
      case "boolean":
      case "symbol":
        return value.toString();
      case "bigint":
        return BigInt(value).toString();
      case "number":
        return value.toString();
      case "string":
        return JSON.stringify(value);
      case "object": {
        const keys = Object.keys(value);
        keys.sort();
        return "{ " + keys.map((k2) => `${stringify(k2)}: ${stringify(value[k2])}`).join(", ") + " }";
      }
    }
    return `[ COULD NOT SERIALIZE ]`;
  }
  function makeError(message2, code2, info) {
    let shortMessage = message2;
    {
      const details = [];
      if (info) {
        if ("message" in info || "code" in info || "name" in info) {
          throw new Error(`value will overwrite populated values: ${stringify(info)}`);
        }
        for (const key2 in info) {
          if (key2 === "shortMessage") {
            continue;
          }
          const value = info[key2];
          details.push(key2 + "=" + stringify(value));
        }
      }
      details.push(`code=${code2}`);
      details.push(`version=${version$3}`);
      if (details.length) {
        message2 += " (" + details.join(", ") + ")";
      }
    }
    let error;
    switch (code2) {
      case "INVALID_ARGUMENT":
        error = new TypeError(message2);
        break;
      case "NUMERIC_FAULT":
      case "BUFFER_OVERRUN":
        error = new RangeError(message2);
        break;
      default:
        error = new Error(message2);
    }
    defineProperties$1(error, { code: code2 });
    if (info) {
      Object.assign(error, info);
    }
    if (error.shortMessage == null) {
      defineProperties$1(error, { shortMessage });
    }
    return error;
  }
  function assert$m(check2, message2, code2, info) {
    if (!check2) {
      throw makeError(message2, code2, info);
    }
  }
  function assertArgument(check2, message2, name2, value) {
    assert$m(check2, message2, "INVALID_ARGUMENT", { argument: name2, value });
  }
  ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
    try {
      if ("test".normalize(form) !== "test") {
        throw new Error("bad");
      }
      ;
      if (form === "NFD") {
        const check2 = String.fromCharCode(233).normalize("NFD");
        const expected = String.fromCharCode(101, 769);
        if (check2 !== expected) {
          throw new Error("broken");
        }
      }
      accum.push(form);
    } catch (error) {
    }
    return accum;
  }, []);
  function assertPrivate(givenGuard, guard, className) {
    if (className == null) {
      className = "";
    }
    if (givenGuard !== guard) {
      let method2 = className, operation = "new";
      if (className) {
        method2 += ".";
        operation += " " + className;
      }
      assert$m(false, `private constructor; use ${method2}from* methods`, "UNSUPPORTED_OPERATION", {
        operation
      });
    }
  }
  function _getBytes(value, name2, copy) {
    if (value instanceof Uint8Array) {
      if (copy) {
        return new Uint8Array(value);
      }
      return value;
    }
    if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
      const result = new Uint8Array((value.length - 2) / 2);
      let offset = 2;
      for (let i2 = 0; i2 < result.length; i2++) {
        result[i2] = parseInt(value.substring(offset, offset + 2), 16);
        offset += 2;
      }
      return result;
    }
    assertArgument(false, "invalid BytesLike value", name2 || "value", value);
  }
  function getBytes(value, name2) {
    return _getBytes(value, name2, false);
  }
  function getBytesCopy(value, name2) {
    return _getBytes(value, name2, true);
  }
  function isHexString$1(value, length) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
      return false;
    }
    if (typeof length === "number" && value.length !== 2 + 2 * length) {
      return false;
    }
    if (length === true && value.length % 2 !== 0) {
      return false;
    }
    return true;
  }
  const HexCharacters = "0123456789abcdef";
  function hexlify(data2) {
    const bytes2 = getBytes(data2);
    let result = "0x";
    for (let i2 = 0; i2 < bytes2.length; i2++) {
      const v = bytes2[i2];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }
  function concat$4(datas) {
    return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
  }
  function dataLength(data2) {
    if (isHexString$1(data2, true)) {
      return (data2.length - 2) / 2;
    }
    return getBytes(data2).length;
  }
  function zeroPad(data2, length, left) {
    const bytes2 = getBytes(data2);
    assert$m(length >= bytes2.length, "padding exceeds data length", "BUFFER_OVERRUN", {
      buffer: new Uint8Array(bytes2),
      length,
      offset: length + 1
    });
    const result = new Uint8Array(length);
    result.fill(0);
    if (left) {
      result.set(bytes2, length - bytes2.length);
    } else {
      result.set(bytes2, 0);
    }
    return hexlify(result);
  }
  function zeroPadValue(data2, length) {
    return zeroPad(data2, length, true);
  }
  const BN_0$2 = BigInt(0);
  BigInt(1);
  const maxValue = 9007199254740991;
  function getBigInt(value, name2) {
    switch (typeof value) {
      case "bigint":
        return value;
      case "number":
        assertArgument(Number.isInteger(value), "underflow", name2 || "value", value);
        assertArgument(value >= -maxValue && value <= maxValue, "overflow", name2 || "value", value);
        return BigInt(value);
      case "string":
        try {
          if (value === "") {
            throw new Error("empty string");
          }
          if (value[0] === "-" && value[1] !== "-") {
            return -BigInt(value.substring(1));
          }
          return BigInt(value);
        } catch (e) {
          assertArgument(false, `invalid BigNumberish string: ${e.message}`, name2 || "value", value);
        }
    }
    assertArgument(false, "invalid BigNumberish value", name2 || "value", value);
  }
  function getUint(value, name2) {
    const result = getBigInt(value, name2);
    assert$m(result >= BN_0$2, "unsigned value cannot be negative", "NUMERIC_FAULT", {
      fault: "overflow",
      operation: "getUint",
      value
    });
    return result;
  }
  function getNumber(value, name2) {
    switch (typeof value) {
      case "bigint":
        assertArgument(value >= -maxValue && value <= maxValue, "overflow", name2 || "value", value);
        return Number(value);
      case "number":
        assertArgument(Number.isInteger(value), "underflow", name2 || "value", value);
        assertArgument(value >= -maxValue && value <= maxValue, "overflow", name2 || "value", value);
        return value;
      case "string":
        try {
          if (value === "") {
            throw new Error("empty string");
          }
          return getNumber(BigInt(value), name2);
        } catch (e) {
          assertArgument(false, `invalid numeric string: ${e.message}`, name2 || "value", value);
        }
    }
    assertArgument(false, "invalid numeric value", name2 || "value", value);
  }
  function toBeHex$1(_value, _width) {
    const value = getUint(_value, "value");
    let result = value.toString(16);
    if (_width == null) {
      if (result.length % 2) {
        result = "0" + result;
      }
    } else {
      const width = getNumber(_width, "width");
      assert$m(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
        operation: "toBeHex",
        fault: "overflow",
        value: _value
      });
      while (result.length < width * 2) {
        result = "0" + result;
      }
    }
    return "0x" + result;
  }
  function toBeArray(_value) {
    const value = getUint(_value, "value");
    if (value === BN_0$2) {
      return new Uint8Array([]);
    }
    let hex = value.toString(16);
    if (hex.length % 2) {
      hex = "0" + hex;
    }
    const result = new Uint8Array(hex.length / 2);
    for (let i2 = 0; i2 < result.length; i2++) {
      const offset = i2 * 2;
      result[i2] = parseInt(hex.substring(offset, offset + 2), 16);
    }
    return result;
  }
  function number(n2) {
    if (!Number.isSafeInteger(n2) || n2 < 0)
      throw new Error(`Wrong positive integer: ${n2}`);
  }
  function bytes$1(b, ...lengths) {
    if (!(b instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  }
  function hash$7(hash2) {
    if (typeof hash2 !== "function" || typeof hash2.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash2.outputLen);
    number(hash2.blockLen);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output$1(out, instance) {
    bytes$1(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }
  const crypto$2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const u8a$1 = (a) => a instanceof Uint8Array;
  const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  const rotr = (word, shift) => word << 32 - shift | word >>> shift;
  const isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE)
    throw new Error("Non little-endian hardware is not supported");
  function utf8ToBytes$1(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data2) {
    if (typeof data2 === "string")
      data2 = utf8ToBytes$1(data2);
    if (!u8a$1(data2))
      throw new Error(`expected Uint8Array, got ${typeof data2}`);
    return data2;
  }
  function concatBytes$1(...arrays) {
    const r2 = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0;
    arrays.forEach((a) => {
      if (!u8a$1(a))
        throw new Error("Uint8Array expected");
      r2.set(a, pad);
      pad += a.length;
    });
    return r2;
  }
  let Hash$b = class Hash {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function randomBytes$2(bytesLength = 32) {
    if (crypto$2 && typeof crypto$2.getRandomValues === "function") {
      return crypto$2.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }
  class HMAC extends Hash$b {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      hash$7(hash2);
      const key2 = toBytes(_key);
      this.iHash = hash2.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key2.length > blockLen ? hash2.create().update(key2).digest() : key2);
      for (let i2 = 0; i2 < pad.length; i2++)
        pad[i2] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash2.create();
      for (let i2 = 0; i2 < pad.length; i2++)
        pad[i2] ^= 54 ^ 92;
      this.oHash.update(pad);
      pad.fill(0);
    }
    update(buf) {
      exists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      exists(this);
      bytes$1(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  }
  const hmac$1 = (hash2, key2, message2) => new HMAC(hash2, key2).update(message2).digest();
  hmac$1.create = (hash2, key2) => new HMAC(hash2, key2);
  function setBigUint64(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  }
  class SHA2 extends Hash$b {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data2) {
      exists(this);
      const { view, buffer: buffer2, blockLen } = this;
      data2 = toBytes(data2);
      const len2 = data2.length;
      for (let pos = 0; pos < len2; ) {
        const take = Math.min(blockLen - this.pos, len2 - pos);
        if (take === blockLen) {
          const dataView = createView(data2);
          for (; blockLen <= len2 - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer2.set(data2.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data2.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      exists(this);
      output$1(out, this);
      this.finished = true;
      const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer2[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i2 = pos; i2 < blockLen; i2++)
        buffer2[i2] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const len2 = this.outputLen;
      if (len2 % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len2 / 4;
      const state2 = this.get();
      if (outLen > state2.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i2 = 0; i2 < outLen; i2++)
        oview.setUint32(4 * i2, state2[i2], isLE2);
    }
    digest() {
      const { buffer: buffer2, outputLen } = this;
      this.digestInto(buffer2);
      const res = buffer2.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer2);
      return to;
    }
  }
  const Chi = (a, b, c) => a & b ^ ~a & c;
  const Maj = (a, b, c) => a & b ^ a & c ^ b & c;
  const SHA256_K = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  const IV = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  let SHA256$2 = class SHA256 extends SHA2 {
    constructor() {
      super(64, 32, 8, false);
      this.A = IV[0] | 0;
      this.B = IV[1] | 0;
      this.C = IV[2] | 0;
      this.D = IV[3] | 0;
      this.E = IV[4] | 0;
      this.F = IV[5] | 0;
      this.G = IV[6] | 0;
      this.H = IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G: G2, H } = this;
      return [A, B, C, D, E, F, G2, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G2, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G2 | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i2 = 0; i2 < 16; i2++, offset += 4)
        SHA256_W[i2] = view.getUint32(offset, false);
      for (let i2 = 16; i2 < 64; i2++) {
        const W15 = SHA256_W[i2 - 15];
        const W2 = SHA256_W[i2 - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
      }
      let { A, B, C, D, E, F, G: G2, H } = this;
      for (let i2 = 0; i2 < 64; i2++) {
        const sigma12 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma12 + Chi(E, F, G2) + SHA256_K[i2] + SHA256_W[i2] | 0;
        const sigma02 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma02 + Maj(A, B, C) | 0;
        H = G2;
        G2 = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G2 = G2 + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G2, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  const sha256$3 = /* @__PURE__ */ wrapConstructor(() => new SHA256$2());
  const U32_MASK64 = /* @__PURE__ */ BigInt(__pow(2, 32) - 1);
  const _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n2, le = false) {
    if (le)
      return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
    return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i2 = 0; i2 < lst.length; i2++) {
      const { h, l } = fromBig(lst[i2], le);
      [Ah[i2], Al[i2]] = [h, l];
    }
    return [Ah, Al];
  }
  const rotlSH = (h, l, s2) => h << s2 | l >>> 32 - s2;
  const rotlSL = (h, l, s2) => l << s2 | h >>> 32 - s2;
  const rotlBH = (h, l, s2) => l << s2 - 32 | h >>> 64 - s2;
  const rotlBL = (h, l, s2) => h << s2 - 32 | l >>> 64 - s2;
  const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
  const _0n$4 = /* @__PURE__ */ BigInt(0);
  const _1n$5 = /* @__PURE__ */ BigInt(1);
  const _2n$3 = /* @__PURE__ */ BigInt(2);
  const _7n = /* @__PURE__ */ BigInt(7);
  const _256n = /* @__PURE__ */ BigInt(256);
  const _0x71n = /* @__PURE__ */ BigInt(113);
  for (let round = 0, R = _1n$5, x = 1, y = 0; round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n$4;
    for (let j = 0; j < 7; j++) {
      R = (R << _1n$5 ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n$3)
        t ^= _1n$5 << (_1n$5 << /* @__PURE__ */ BigInt(j)) - _1n$5;
    }
    _SHA3_IOTA.push(t);
  }
  const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
  const rotlH = (h, l, s2) => s2 > 32 ? rotlBH(h, l, s2) : rotlSH(h, l, s2);
  const rotlL = (h, l, s2) => s2 > 32 ? rotlBL(h, l, s2) : rotlSL(h, l, s2);
  function keccakP(s2, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s2[x] ^ s2[x + 10] ^ s2[x + 20] ^ s2[x + 30] ^ s2[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s2[x + y] ^= Th;
          s2[x + y + 1] ^= Tl;
        }
      }
      let curH = s2[2];
      let curL = s2[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s2[PI];
        curL = s2[PI + 1];
        s2[PI] = Th;
        s2[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s2[y + x];
        for (let x = 0; x < 10; x++)
          s2[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s2[0] ^= SHA3_IOTA_H[round];
      s2[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
  }
  let Keccak$1 = class Keccak2 extends Hash$b {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      number(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = u32(this.state);
    }
    keccak() {
      keccakP(this.state32, this.rounds);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data2) {
      exists(this);
      const { blockLen, state: state2 } = this;
      data2 = toBytes(data2);
      const len2 = data2.length;
      for (let pos = 0; pos < len2; ) {
        const take = Math.min(blockLen - this.pos, len2 - pos);
        for (let i2 = 0; i2 < take; i2++)
          state2[this.pos++] ^= data2[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state: state2, suffix, pos, blockLen } = this;
      state2[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state2[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      exists(this, false);
      bytes$1(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len2 = out.length; pos < len2; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len2 - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes2) {
      number(bytes2);
      return this.xofInto(new Uint8Array(bytes2));
    }
    digestInto(out) {
      output$1(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak2(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  };
  const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak$1(blockLen, suffix, outputLen));
  const keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
  let locked = false;
  const _keccak256 = function(data2) {
    return keccak_256(data2);
  };
  let __keccak256 = _keccak256;
  function keccak256(_data) {
    const data2 = getBytes(_data, "data");
    return hexlify(__keccak256(data2));
  }
  keccak256._ = _keccak256;
  keccak256.lock = function() {
    locked = true;
  };
  keccak256.register = function(func) {
    if (locked) {
      throw new TypeError("keccak256 is locked");
    }
    __keccak256 = func;
  };
  Object.freeze(keccak256);
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const _0n$3 = BigInt(0);
  const _1n$4 = BigInt(1);
  const _2n$2 = BigInt(2);
  const u8a = (a) => a instanceof Uint8Array;
  const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
  function bytesToHex(bytes2) {
    if (!u8a(bytes2))
      throw new Error("Uint8Array expected");
    let hex = "";
    for (let i2 = 0; i2 < bytes2.length; i2++) {
      hex += hexes[bytes2[i2]];
    }
    return hex;
  }
  function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
  }
  function hexToNumber(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return BigInt(hex === "" ? "0" : `0x${hex}`);
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const len2 = hex.length;
    if (len2 % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + len2);
    const array = new Uint8Array(len2 / 2);
    for (let i2 = 0; i2 < array.length; i2++) {
      const j = i2 * 2;
      const hexByte = hex.slice(j, j + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i2] = byte;
    }
    return array;
  }
  function bytesToNumberBE(bytes2) {
    return hexToNumber(bytesToHex(bytes2));
  }
  function bytesToNumberLE(bytes2) {
    if (!u8a(bytes2))
      throw new Error("Uint8Array expected");
    return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE(n2, len2) {
    return hexToBytes(n2.toString(16).padStart(len2 * 2, "0"));
  }
  function numberToBytesLE(n2, len2) {
    return numberToBytesBE(n2, len2).reverse();
  }
  function numberToVarBytesBE(n2) {
    return hexToBytes(numberToHexUnpadded(n2));
  }
  function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes(hex);
      } catch (e) {
        throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
      }
    } else if (u8a(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len2 = res.length;
    if (typeof expectedLength === "number" && len2 !== expectedLength)
      throw new Error(`${title} expected ${expectedLength} bytes, got ${len2}`);
    return res;
  }
  function concatBytes(...arrays) {
    const r2 = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0;
    arrays.forEach((a) => {
      if (!u8a(a))
        throw new Error("Uint8Array expected");
      r2.set(a, pad);
      pad += a.length;
    });
    return r2;
  }
  function equalBytes(b1, b2) {
    if (b1.length !== b2.length)
      return false;
    for (let i2 = 0; i2 < b1.length; i2++)
      if (b1[i2] !== b2[i2])
        return false;
    return true;
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function bitLen(n2) {
    let len2;
    for (len2 = 0; n2 > _0n$3; n2 >>= _1n$4, len2 += 1)
      ;
    return len2;
  }
  function bitGet(n2, pos) {
    return n2 >> BigInt(pos) & _1n$4;
  }
  const bitSet = (n2, pos, value) => {
    return n2 | (value ? _1n$4 : _0n$3) << BigInt(pos);
  };
  const bitMask = (n2) => (_2n$2 << BigInt(n2 - 1)) - _1n$4;
  const u8n = (data2) => new Uint8Array(data2);
  const u8fr = (arr) => Uint8Array.from(arr);
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    let v = u8n(hashLen);
    let k2 = u8n(hashLen);
    let i2 = 0;
    const reset = () => {
      v.fill(1);
      k2.fill(0);
      i2 = 0;
    };
    const h = (...b) => hmacFn(k2, v, ...b);
    const reseed = (seed = u8n()) => {
      k2 = h(u8fr([0]), seed);
      v = h();
      if (seed.length === 0)
        return;
      k2 = h(u8fr([1]), seed);
      v = h();
    };
    const gen2 = () => {
      if (i2++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len2 = 0;
      const out = [];
      while (len2 < qByteLen) {
        v = h();
        const sl2 = v.slice();
        out.push(sl2);
        len2 += v.length;
      }
      return concatBytes(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen2())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  const validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object2) => object2.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  function validateObject(object2, validators, optValidators = {}) {
    const checkField = (fieldName, type2, isOptional) => {
      const checkVal = validatorFns[type2];
      if (typeof checkVal !== "function")
        throw new Error(`Invalid validator "${type2}", expected function`);
      const val = object2[fieldName];
      if (isOptional && val === void 0)
        return;
      if (!checkVal(val, object2)) {
        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type2}`);
      }
    };
    for (const [fieldName, type2] of Object.entries(validators))
      checkField(fieldName, type2, false);
    for (const [fieldName, type2] of Object.entries(optValidators))
      checkField(fieldName, type2, true);
    return object2;
  }
  const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    bitGet,
    bitLen,
    bitMask,
    bitSet,
    bytesToHex,
    bytesToNumberBE,
    bytesToNumberLE,
    concatBytes,
    createHmacDrbg,
    ensureBytes,
    equalBytes,
    hexToBytes,
    hexToNumber,
    numberToBytesBE,
    numberToBytesLE,
    numberToHexUnpadded,
    numberToVarBytesBE,
    utf8ToBytes,
    validateObject
  }, Symbol.toStringTag, { value: "Module" }));
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3);
  const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
  BigInt(9);
  BigInt(16);
  function mod(a, b) {
    const result = a % b;
    return result >= _0n$2 ? result : b + result;
  }
  function pow(num, power, modulo) {
    if (modulo <= _0n$2 || power < _0n$2)
      throw new Error("Expected power/modulo > 0");
    if (modulo === _1n$3)
      return _0n$2;
    let res = _1n$3;
    while (power > _0n$2) {
      if (power & _1n$3)
        res = res * num % modulo;
      num = num * num % modulo;
      power >>= _1n$3;
    }
    return res;
  }
  function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n$2) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number2, modulo) {
    if (number2 === _0n$2 || modulo <= _0n$2) {
      throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
    }
    let a = mod(number2, modulo);
    let b = modulo;
    let x = _0n$2, u = _1n$3;
    while (a !== _0n$2) {
      const q = b / a;
      const r2 = b % a;
      const m = x - u * q;
      b = a, a = r2, x = u, u = m;
    }
    const gcd = b;
    if (gcd !== _1n$3)
      throw new Error("invert: does not exist");
    return mod(x, modulo);
  }
  function tonelliShanks(P) {
    const legendreC = (P - _1n$3) / _2n$1;
    let Q, S, Z;
    for (Q = P - _1n$3, S = 0; Q % _2n$1 === _0n$2; Q /= _2n$1, S++)
      ;
    for (Z = _2n$1; Z < P && pow(Z, legendreC, P) !== P - _1n$3; Z++)
      ;
    if (S === 1) {
      const p1div4 = (P + _1n$3) / _4n;
      return function tonelliFast(Fp2, n2) {
        const root2 = Fp2.pow(n2, p1div4);
        if (!Fp2.eql(Fp2.sqr(root2), n2))
          throw new Error("Cannot find square root");
        return root2;
      };
    }
    const Q1div2 = (Q + _1n$3) / _2n$1;
    return function tonelliSlow(Fp2, n2) {
      if (Fp2.pow(n2, legendreC) === Fp2.neg(Fp2.ONE))
        throw new Error("Cannot find square root");
      let r2 = S;
      let g2 = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
      let x = Fp2.pow(n2, Q1div2);
      let b = Fp2.pow(n2, Q);
      while (!Fp2.eql(b, Fp2.ONE)) {
        if (Fp2.eql(b, Fp2.ZERO))
          return Fp2.ZERO;
        let m = 1;
        for (let t2 = Fp2.sqr(b); m < r2; m++) {
          if (Fp2.eql(t2, Fp2.ONE))
            break;
          t2 = Fp2.sqr(t2);
        }
        const ge = Fp2.pow(g2, _1n$3 << BigInt(r2 - m - 1));
        g2 = Fp2.sqr(ge);
        x = Fp2.mul(x, ge);
        b = Fp2.mul(b, g2);
        r2 = m;
      }
      return x;
    };
  }
  function FpSqrt(P) {
    if (P % _4n === _3n$1) {
      const p1div4 = (P + _1n$3) / _4n;
      return function sqrt3mod4(Fp2, n2) {
        const root2 = Fp2.pow(n2, p1div4);
        if (!Fp2.eql(Fp2.sqr(root2), n2))
          throw new Error("Cannot find square root");
        return root2;
      };
    }
    if (P % _8n === _5n) {
      const c1 = (P - _5n) / _8n;
      return function sqrt5mod8(Fp2, n2) {
        const n22 = Fp2.mul(n2, _2n$1);
        const v = Fp2.pow(n22, c1);
        const nv = Fp2.mul(n2, v);
        const i2 = Fp2.mul(Fp2.mul(nv, _2n$1), v);
        const root2 = Fp2.mul(nv, Fp2.sub(i2, Fp2.ONE));
        if (!Fp2.eql(Fp2.sqr(root2), n2))
          throw new Error("Cannot find square root");
        return root2;
      };
    }
    return tonelliShanks(P);
  }
  const FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    return validateObject(field, opts);
  }
  function FpPow(f2, num, power) {
    if (power < _0n$2)
      throw new Error("Expected power > 0");
    if (power === _0n$2)
      return f2.ONE;
    if (power === _1n$3)
      return num;
    let p2 = f2.ONE;
    let d = num;
    while (power > _0n$2) {
      if (power & _1n$3)
        p2 = f2.mul(p2, d);
      d = f2.sqr(d);
      power >>= _1n$3;
    }
    return p2;
  }
  function FpInvertBatch(f2, nums) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i2) => {
      if (f2.is0(num))
        return acc;
      tmp[i2] = acc;
      return f2.mul(acc, num);
    }, f2.ONE);
    const inverted = f2.inv(lastMultiplied);
    nums.reduceRight((acc, num, i2) => {
      if (f2.is0(num))
        return acc;
      tmp[i2] = f2.mul(acc, tmp[i2]);
      return f2.mul(acc, num);
    }, inverted);
    return tmp;
  }
  function nLength(n2, nBitLength) {
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
    if (ORDER <= _0n$2)
      throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
    if (BYTES > 2048)
      throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt(ORDER);
    const f2 = Object.freeze({
      ORDER,
      BITS,
      BYTES,
      MASK: bitMask(BITS),
      ZERO: _0n$2,
      ONE: _1n$3,
      create: (num) => mod(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
        return _0n$2 <= num && num < ORDER;
      },
      is0: (num) => num === _0n$2,
      isOdd: (num) => (num & _1n$3) === _1n$3,
      neg: (num) => mod(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod(num * num, ORDER),
      add: (lhs, rhs) => mod(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
      pow: (num, power) => FpPow(f2, num, power),
      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert(num, ORDER),
      sqrt: redef.sqrt || ((n2) => sqrtP(f2, n2)),
      invertBatch: (lst) => FpInvertBatch(f2, lst),
      // TODO: do we really need constant cmov?
      // We don't have const-time bigints anyway, so probably will be not very useful
      cmov: (a, b, c) => c ? b : a,
      toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES)
          throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
        return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
      }
    });
    return Object.freeze(f2);
  }
  function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
  }
  function mapHashToField(key2, fieldOrder, isLE2 = false) {
    const len2 = key2.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    if (len2 < 16 || len2 < minLen || len2 > 1024)
      throw new Error(`expected ${minLen}-1024 bytes of input, got ${len2}`);
    const num = isLE2 ? bytesToNumberBE(key2) : bytesToNumberLE(key2);
    const reduced = mod(num, fieldOrder - _1n$3) + _1n$3;
    return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
  }
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const _0n$1 = BigInt(0);
  const _1n$2 = BigInt(1);
  function wNAF(c, bits) {
    const constTimeNegate = (condition, item) => {
      const neg = item.negate();
      return condition ? neg : item;
    };
    const opts = (W2) => {
      const windows = Math.ceil(bits / W2) + 1;
      const windowSize = __pow(2, W2 - 1);
      return { windows, windowSize };
    };
    return {
      constTimeNegate,
      // non-const time multiplication ladder
      unsafeLadder(elm, n2) {
        let p2 = c.ZERO;
        let d = elm;
        while (n2 > _0n$1) {
          if (n2 & _1n$2)
            p2 = p2.add(d);
          d = d.double();
          n2 >>= _1n$2;
        }
        return p2;
      },
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
       * - 𝑊 is the window size
       * - 𝑛 is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(elm, W2) {
        const { windows, windowSize } = opts(W2);
        const points = [];
        let p2 = elm;
        let base2 = p2;
        for (let window2 = 0; window2 < windows; window2++) {
          base2 = p2;
          points.push(base2);
          for (let i2 = 1; i2 < windowSize; i2++) {
            base2 = base2.add(p2);
            points.push(base2);
          }
          p2 = base2.double();
        }
        return points;
      },
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @returns real and fake (for const-time) points
       */
      wNAF(W2, precomputes, n2) {
        const { windows, windowSize } = opts(W2);
        let p2 = c.ZERO;
        let f2 = c.BASE;
        const mask = BigInt(__pow(2, W2) - 1);
        const maxNumber = __pow(2, W2);
        const shiftBy = BigInt(W2);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n2 & mask);
          n2 >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n2 += _1n$2;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p2 = p2.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }
        return { p: p2, f: f2 };
      },
      wNAFCached(P, precomputesMap, n2, transform) {
        const W2 = P._WINDOW_SIZE || 1;
        let comp = precomputesMap.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W2);
          if (W2 !== 1) {
            precomputesMap.set(P, transform(comp));
          }
        }
        return this.wNAF(W2, comp, n2);
      }
    };
  }
  function validateBasic(curve2) {
    validateField(curve2.Fp);
    validateObject(curve2, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze(__spreadValues(__spreadValues(__spreadValues({}, nLength(curve2.n, curve2.nBitLength)), curve2), { p: curve2.Fp.ORDER }));
  }
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  function validatePointOpts(curve2) {
    const opts = validateBasic(curve2);
    validateObject(opts, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo, Fp: Fp2, a } = opts;
    if (endo) {
      if (!Fp2.eql(a, Fp2.ZERO)) {
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      }
      if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
    }
    return Object.freeze(__spreadValues({}, opts));
  }
  const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
  const DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
      constructor(m = "") {
        super(m);
      }
    },
    _parseInt(data2) {
      const { Err: E } = DER;
      if (data2.length < 2 || data2[0] !== 2)
        throw new E("Invalid signature integer tag");
      const len2 = data2[1];
      const res = data2.subarray(2, len2 + 2);
      if (!len2 || res.length !== len2)
        throw new E("Invalid signature integer: wrong length");
      if (res[0] & 128)
        throw new E("Invalid signature integer: negative");
      if (res[0] === 0 && !(res[1] & 128))
        throw new E("Invalid signature integer: unnecessary leading zero");
      return { d: b2n(res), l: data2.subarray(len2 + 2) };
    },
    toSig(hex) {
      const { Err: E } = DER;
      const data2 = typeof hex === "string" ? h2b(hex) : hex;
      if (!(data2 instanceof Uint8Array))
        throw new Error("ui8a expected");
      let l = data2.length;
      if (l < 2 || data2[0] != 48)
        throw new E("Invalid signature tag");
      if (data2[1] !== l - 2)
        throw new E("Invalid signature: incorrect length");
      const { d: r2, l: sBytes } = DER._parseInt(data2.subarray(2));
      const { d: s2, l: rBytesLeft } = DER._parseInt(sBytes);
      if (rBytesLeft.length)
        throw new E("Invalid signature: left bytes after parsing");
      return { r: r2, s: s2 };
    },
    hexFromSig(sig) {
      const slice2 = (s3) => Number.parseInt(s3[0], 16) & 8 ? "00" + s3 : s3;
      const h = (num) => {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      };
      const s2 = slice2(h(sig.s));
      const r2 = slice2(h(sig.r));
      const shl = s2.length / 2;
      const rhl = r2.length / 2;
      const sl2 = h(shl);
      const rl = h(rhl);
      return `30${h(rhl + shl + 4)}02${rl}${r2}02${sl2}${s2}`;
    }
  };
  const _0n = BigInt(0), _1n$1 = BigInt(1);
  BigInt(2);
  const _3n = BigInt(3);
  BigInt(4);
  function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp: Fp2 } = CURVE;
    const toBytes2 = CURVE.toBytes || ((_c, point2, _isCompressed) => {
      const a = point2.toAffine();
      return concatBytes(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
    });
    const fromBytes = CURVE.fromBytes || ((bytes2) => {
      const tail = bytes2.subarray(1);
      const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
      const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
      return { x, y };
    });
    function weierstrassEquation(x) {
      const { a, b } = CURVE;
      const x2 = Fp2.sqr(x);
      const x3 = Fp2.mul(x2, x);
      return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
    }
    if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
      throw new Error("bad generator point: equation left != right");
    function isWithinCurveOrder(num) {
      return typeof num === "bigint" && _0n < num && num < CURVE.n;
    }
    function assertGE(num) {
      if (!isWithinCurveOrder(num))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function normPrivateKeyToScalar(key2) {
      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
      if (lengths && typeof key2 !== "bigint") {
        if (key2 instanceof Uint8Array)
          key2 = bytesToHex(key2);
        if (typeof key2 !== "string" || !lengths.includes(key2.length))
          throw new Error("Invalid key");
        key2 = key2.padStart(nByteLength * 2, "0");
      }
      let num;
      try {
        num = typeof key2 === "bigint" ? key2 : bytesToNumberBE(ensureBytes("private key", key2, nByteLength));
      } catch (error) {
        throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key2}`);
      }
      if (wrapPrivateKey)
        num = mod(num, n2);
      assertGE(num);
      return num;
    }
    const pointPrecomputes = /* @__PURE__ */ new Map();
    function assertPrjPoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ProjectivePoint expected");
    }
    class Point2 {
      constructor(px, py, pz) {
        this.px = px;
        this.py = py;
        this.pz = pz;
        if (px == null || !Fp2.isValid(px))
          throw new Error("x required");
        if (py == null || !Fp2.isValid(py))
          throw new Error("y required");
        if (pz == null || !Fp2.isValid(pz))
          throw new Error("z required");
      }
      // Does not validate if the point is on-curve.
      // Use fromHex instead, or call assertValidity() later.
      static fromAffine(p2) {
        const { x, y } = p2 || {};
        if (!p2 || !Fp2.isValid(x) || !Fp2.isValid(y))
          throw new Error("invalid affine point");
        if (p2 instanceof Point2)
          throw new Error("projective point not allowed");
        const is0 = (i2) => Fp2.eql(i2, Fp2.ZERO);
        if (is0(x) && is0(y))
          return Point2.ZERO;
        return new Point2(x, y, Fp2.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
      static normalizeZ(points) {
        const toInv = Fp2.invertBatch(points.map((p2) => p2.pz));
        return points.map((p2, i2) => p2.toAffine(toInv[i2])).map(Point2.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
      static fromHex(hex) {
        const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
        P.assertValidity();
        return P;
      }
      // Multiplies generator point by privateKey.
      static fromPrivateKey(privateKey) {
        return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      // "Private method", don't use it directly
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      // A point on curve is valid if it conforms to equation.
      assertValidity() {
        if (this.is0()) {
          if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = this.toAffine();
        if (!Fp2.isValid(x) || !Fp2.isValid(y))
          throw new Error("bad point: x or y not FE");
        const left = Fp2.sqr(y);
        const right = weierstrassEquation(x);
        if (!Fp2.eql(left, right))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (Fp2.isOdd)
          return !Fp2.isOdd(y);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
      equals(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
        const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
        return U1 && U2;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
      negate() {
        return new Point2(this.px, Fp2.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a, b } = CURVE;
        const b3 = Fp2.mul(b, _3n);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        let t0 = Fp2.mul(X1, X1);
        let t1 = Fp2.mul(Y1, Y1);
        let t2 = Fp2.mul(Z1, Z1);
        let t3 = Fp2.mul(X1, Y1);
        t3 = Fp2.add(t3, t3);
        Z3 = Fp2.mul(X1, Z1);
        Z3 = Fp2.add(Z3, Z3);
        X3 = Fp2.mul(a, Z3);
        Y3 = Fp2.mul(b3, t2);
        Y3 = Fp2.add(X3, Y3);
        X3 = Fp2.sub(t1, Y3);
        Y3 = Fp2.add(t1, Y3);
        Y3 = Fp2.mul(X3, Y3);
        X3 = Fp2.mul(t3, X3);
        Z3 = Fp2.mul(b3, Z3);
        t2 = Fp2.mul(a, t2);
        t3 = Fp2.sub(t0, t2);
        t3 = Fp2.mul(a, t3);
        t3 = Fp2.add(t3, Z3);
        Z3 = Fp2.add(t0, t0);
        t0 = Fp2.add(Z3, t0);
        t0 = Fp2.add(t0, t2);
        t0 = Fp2.mul(t0, t3);
        Y3 = Fp2.add(Y3, t0);
        t2 = Fp2.mul(Y1, Z1);
        t2 = Fp2.add(t2, t2);
        t0 = Fp2.mul(t2, t3);
        X3 = Fp2.sub(X3, t0);
        Z3 = Fp2.mul(t2, t1);
        Z3 = Fp2.add(Z3, Z3);
        Z3 = Fp2.add(Z3, Z3);
        return new Point2(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        const a = CURVE.a;
        const b3 = Fp2.mul(CURVE.b, _3n);
        let t0 = Fp2.mul(X1, X2);
        let t1 = Fp2.mul(Y1, Y2);
        let t2 = Fp2.mul(Z1, Z2);
        let t3 = Fp2.add(X1, Y1);
        let t4 = Fp2.add(X2, Y2);
        t3 = Fp2.mul(t3, t4);
        t4 = Fp2.add(t0, t1);
        t3 = Fp2.sub(t3, t4);
        t4 = Fp2.add(X1, Z1);
        let t5 = Fp2.add(X2, Z2);
        t4 = Fp2.mul(t4, t5);
        t5 = Fp2.add(t0, t2);
        t4 = Fp2.sub(t4, t5);
        t5 = Fp2.add(Y1, Z1);
        X3 = Fp2.add(Y2, Z2);
        t5 = Fp2.mul(t5, X3);
        X3 = Fp2.add(t1, t2);
        t5 = Fp2.sub(t5, X3);
        Z3 = Fp2.mul(a, t4);
        X3 = Fp2.mul(b3, t2);
        Z3 = Fp2.add(X3, Z3);
        X3 = Fp2.sub(t1, Z3);
        Z3 = Fp2.add(t1, Z3);
        Y3 = Fp2.mul(X3, Z3);
        t1 = Fp2.add(t0, t0);
        t1 = Fp2.add(t1, t0);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.mul(b3, t4);
        t1 = Fp2.add(t1, t2);
        t2 = Fp2.sub(t0, t2);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.add(t4, t2);
        t0 = Fp2.mul(t1, t4);
        Y3 = Fp2.add(Y3, t0);
        t0 = Fp2.mul(t5, t4);
        X3 = Fp2.mul(t3, X3);
        X3 = Fp2.sub(X3, t0);
        t0 = Fp2.mul(t3, t1);
        Z3 = Fp2.mul(t5, Z3);
        Z3 = Fp2.add(Z3, t0);
        return new Point2(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      wNAF(n2) {
        return wnaf.wNAFCached(this, pointPrecomputes, n2, (comp) => {
          const toInv = Fp2.invertBatch(comp.map((p2) => p2.pz));
          return comp.map((p2, i2) => p2.toAffine(toInv[i2])).map(Point2.fromAffine);
        });
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(n2) {
        const I = Point2.ZERO;
        if (n2 === _0n)
          return I;
        assertGE(n2);
        if (n2 === _1n$1)
          return this;
        const { endo } = CURVE;
        if (!endo)
          return wnaf.unsafeLadder(this, n2);
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let k1p = I;
        let k2p = I;
        let d = this;
        while (k1 > _0n || k2 > _0n) {
          if (k1 & _1n$1)
            k1p = k1p.add(d);
          if (k2 & _1n$1)
            k2p = k2p.add(d);
          d = d.double();
          k1 >>= _1n$1;
          k2 >>= _1n$1;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        assertGE(scalar);
        let n2 = scalar;
        let point2, fake;
        const { endo } = CURVE;
        if (endo) {
          const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
          let { p: k1p, f: f1p } = this.wNAF(k1);
          let { p: k2p, f: f2p } = this.wNAF(k2);
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          point2 = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p: p2, f: f2 } = this.wNAF(n2);
          point2 = p2;
          fake = f2;
        }
        return Point2.normalizeZ([point2, fake])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
      multiplyAndAddUnsafe(Q, a, b) {
        const G2 = Point2.BASE;
        const mul = (P, a2) => a2 === _0n || a2 === _1n$1 || !P.equals(G2) ? P.multiplyUnsafe(a2) : P.multiply(a2);
        const sum = mul(this, a).add(mul(Q, b));
        return sum.is0() ? void 0 : sum;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z) ∋ (x=x/z, y=y/z)
      toAffine(iz) {
        const { px: x, py: y, pz: z } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? Fp2.ONE : Fp2.inv(z);
        const ax = Fp2.mul(x, iz);
        const ay = Fp2.mul(y, iz);
        const zz = Fp2.mul(z, iz);
        if (is0)
          return { x: Fp2.ZERO, y: Fp2.ZERO };
        if (!Fp2.eql(zz, Fp2.ONE))
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      isTorsionFree() {
        const { h: cofactor, isTorsionFree } = CURVE;
        if (cofactor === _1n$1)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point2, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: cofactor, clearCofactor } = CURVE;
        if (cofactor === _1n$1)
          return this;
        if (clearCofactor)
          return clearCofactor(Point2, this);
        return this.multiplyUnsafe(CURVE.h);
      }
      toRawBytes(isCompressed2 = true) {
        this.assertValidity();
        return toBytes2(Point2, this, isCompressed2);
      }
      toHex(isCompressed2 = true) {
        return bytesToHex(this.toRawBytes(isCompressed2));
      }
    }
    Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
    Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    return {
      CURVE,
      ProjectivePoint: Point2,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    };
  }
  function validateOpts(curve2) {
    const opts = validateBasic(curve2);
    validateObject(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze(__spreadValues({ lowS: true }, opts));
  }
  function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp2.BYTES + 1;
    const uncompressedLen = 2 * Fp2.BYTES + 1;
    function isValidFieldElement(num) {
      return _0n < num && num < Fp2.ORDER;
    }
    function modN(a) {
      return mod(a, CURVE_ORDER);
    }
    function invN(a) {
      return invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints(__spreadProps(__spreadValues({}, CURVE), {
      toBytes(_c, point2, isCompressed2) {
        const a = point2.toAffine();
        const x = Fp2.toBytes(a.x);
        const cat = concatBytes;
        if (isCompressed2) {
          return cat(Uint8Array.from([point2.hasEvenY() ? 2 : 3]), x);
        } else {
          return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
        }
      },
      fromBytes(bytes2) {
        const len2 = bytes2.length;
        const head = bytes2[0];
        const tail = bytes2.subarray(1);
        if (len2 === compressedLen && (head === 2 || head === 3)) {
          const x = bytesToNumberBE(tail);
          if (!isValidFieldElement(x))
            throw new Error("Point is not on curve");
          const y2 = weierstrassEquation(x);
          let y = Fp2.sqrt(y2);
          const isYOdd = (y & _1n$1) === _1n$1;
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y = Fp2.neg(y);
          return { x, y };
        } else if (len2 === uncompressedLen && head === 4) {
          const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
          const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
          return { x, y };
        } else {
          throw new Error(`Point of length ${len2} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
        }
      }
    }));
    const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number2) {
      const HALF = CURVE_ORDER >> _1n$1;
      return number2 > HALF;
    }
    function normalizeS(s2) {
      return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
    }
    const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
    class Signature2 {
      constructor(r2, s2, recovery) {
        this.r = r2;
        this.s = s2;
        this.recovery = recovery;
        this.assertValidity();
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(hex) {
        const l = CURVE.nByteLength;
        hex = ensureBytes("compactSignature", hex, l * 2);
        return new Signature2(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(hex) {
        const { r: r2, s: s2 } = DER.toSig(ensureBytes("DER", hex));
        return new Signature2(r2, s2);
      }
      assertValidity() {
        if (!isWithinCurveOrder(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!isWithinCurveOrder(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(recovery) {
        return new Signature2(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const { r: r2, s: s2, recovery: rec } = this;
        const h = bits2int_modN(ensureBytes("msgHash", msgHash));
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
        if (radj >= Fp2.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const prefix = (rec & 1) === 0 ? "02" : "03";
        const R = Point2.fromHex(prefix + numToNByteStr(radj));
        const ir = invN(radj);
        const u1 = modN(-h * ir);
        const u2 = modN(s2 * ir);
        const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
      }
      // DER-encoded
      toDERRawBytes() {
        return hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return DER.hexFromSig({ r: this.r, s: this.s });
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return numToNByteStr(this.r) + numToNByteStr(this.s);
      }
    }
    const utils2 = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */
      randomPrivateKey: () => {
        const length = getMinHashLength(CURVE.n);
        return mapHashToField(CURVE.randomBytes(length), CURVE.n);
      },
      /**
       * Creates precompute table for an arbitrary EC point. Makes point "cached".
       * Allows to massively speed-up `point.multiply(scalar)`.
       * @returns cached point
       * @example
       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
       * fast.multiply(privKey); // much faster ECDH now
       */
      precompute(windowSize = 8, point2 = Point2.BASE) {
        point2._setWindowSize(windowSize);
        point2.multiply(BigInt(3));
        return point2;
      }
    };
    function getPublicKey(privateKey, isCompressed2 = true) {
      return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed2);
    }
    function isProbPub(item) {
      const arr = item instanceof Uint8Array;
      const str = typeof item === "string";
      const len2 = (arr || str) && item.length;
      if (arr)
        return len2 === compressedLen || len2 === uncompressedLen;
      if (str)
        return len2 === 2 * compressedLen || len2 === 2 * uncompressedLen;
      if (item instanceof Point2)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed2 = true) {
      if (isProbPub(privateA))
        throw new Error("first arg must be private key");
      if (!isProbPub(publicB))
        throw new Error("second arg must be public key");
      const b = Point2.fromHex(publicB);
      return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed2);
    }
    const bits2int = CURVE.bits2int || function(bytes2) {
      const num = bytesToNumberBE(bytes2);
      const delta = bytes2.length * 8 - CURVE.nBitLength;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
      return modN(bits2int(bytes2));
    };
    const ORDER_MASK = bitMask(CURVE.nBitLength);
    function int2octets(num) {
      if (typeof num !== "bigint")
        throw new Error("bigint expected");
      if (!(_0n <= num && num < ORDER_MASK))
        throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
      return numberToBytesBE(num, CURVE.nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k2) => k2 in opts))
        throw new Error("sign() legacy options not supported");
      const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = ensureBytes("msgHash", msgHash);
      if (prehash)
        msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (ent != null) {
        const e = ent === true ? randomBytes2(Fp2.BYTES) : ent;
        seedArgs.push(ensureBytes("extraEntropy", e));
      }
      const seed = concatBytes(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k2 = bits2int(kBytes);
        if (!isWithinCurveOrder(k2))
          return;
        const ik = invN(k2);
        const q = Point2.BASE.multiply(k2).toAffine();
        const r2 = modN(q.x);
        if (r2 === _0n)
          return;
        const s2 = modN(ik * modN(m + r2 * d));
        if (s2 === _0n)
          return;
        let recovery = (q.x === r2 ? 0 : 2) | Number(q.y & _1n$1);
        let normS = s2;
        if (lowS && isBiggerThanHalfOrder(s2)) {
          normS = normalizeS(s2);
          recovery ^= 1;
        }
        return new Signature2(r2, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    function sign2(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const C = CURVE;
      const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
      return drbg(seed, k2sig);
    }
    Point2.BASE._setWindowSize(8);
    function verify2(signature2, msgHash, publicKey, opts = defaultVerOpts) {
      var _a2;
      const sg = signature2;
      msgHash = ensureBytes("msgHash", msgHash);
      publicKey = ensureBytes("publicKey", publicKey);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      const { lowS, prehash } = opts;
      let _sig = void 0;
      let P;
      try {
        if (typeof sg === "string" || sg instanceof Uint8Array) {
          try {
            _sig = Signature2.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof DER.Err))
              throw derError;
            _sig = Signature2.fromCompact(sg);
          }
        } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
          const { r: r3, s: s3 } = sg;
          _sig = new Signature2(r3, s3);
        } else {
          throw new Error("PARSE");
        }
        P = Point2.fromHex(publicKey);
      } catch (error) {
        if (error.message === "PARSE")
          throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
        return false;
      }
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = CURVE.hash(msgHash);
      const { r: r2, s: s2 } = _sig;
      const h = bits2int_modN(msgHash);
      const is = invN(s2);
      const u1 = modN(h * is);
      const u2 = modN(r2 * is);
      const R = (_a2 = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a2.toAffine();
      if (!R)
        return false;
      const v = modN(R.x);
      return v === r2;
    }
    return {
      CURVE,
      getPublicKey,
      getSharedSecret,
      sign: sign2,
      verify: verify2,
      ProjectivePoint: Point2,
      Signature: Signature2,
      utils: utils2
    };
  }
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  function getHash(hash2) {
    return {
      hash: hash2,
      hmac: (key2, ...msgs) => hmac$1(hash2, key2, concatBytes$1(...msgs)),
      randomBytes: randomBytes$2
    };
  }
  function createCurve(curveDef, defHash) {
    const create = (hash2) => weierstrass(__spreadValues(__spreadValues({}, curveDef), getHash(hash2)));
    return Object.freeze(__spreadProps(__spreadValues({}, create(defHash)), { create }));
  }
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
  const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  const _1n = BigInt(1);
  const _2n = BigInt(2);
  const divNearest = (a, b) => (a + b / _2n) / b;
  function sqrtMod(y) {
    const P = secp256k1P;
    const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = pow2(b3, _3n2, P) * b3 % P;
    const b9 = pow2(b6, _3n2, P) * b3 % P;
    const b11 = pow2(b9, _2n, P) * b2 % P;
    const b22 = pow2(b11, _11n, P) * b11 % P;
    const b44 = pow2(b22, _22n, P) * b22 % P;
    const b88 = pow2(b44, _44n, P) * b44 % P;
    const b176 = pow2(b88, _88n, P) * b88 % P;
    const b220 = pow2(b176, _44n, P) * b44 % P;
    const b223 = pow2(b220, _3n2, P) * b3 % P;
    const t1 = pow2(b223, _23n, P) * b22 % P;
    const t2 = pow2(t1, _6n, P) * b2 % P;
    const root2 = pow2(t2, _2n, P);
    if (!Fp.eql(Fp.sqr(root2), y))
      throw new Error("Cannot find square root");
    return root2;
  }
  const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
  const secp256k1$3 = createCurve({
    a: BigInt(0),
    b: BigInt(7),
    Fp,
    n: secp256k1N,
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: true,
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k2) => {
        const n2 = secp256k1N;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k2, n2);
        const c2 = divNearest(-b1 * k2, n2);
        let k1 = mod(k2 - c1 * a1 - c2 * a2, n2);
        let k22 = mod(-c1 * b1 - c2 * b2, n2);
        const k1neg = k1 > POW_2_128;
        const k2neg = k22 > POW_2_128;
        if (k1neg)
          k1 = n2 - k1;
        if (k2neg)
          k22 = n2 - k22;
        if (k1 > POW_2_128 || k22 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k2);
        }
        return { k1neg, k1, k2neg, k2: k22 };
      }
    }
  }, sha256$3);
  BigInt(0);
  secp256k1$3.ProjectivePoint;
  const ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
  const BN_0$1 = BigInt(0);
  const BN_1 = BigInt(1);
  const BN_2 = BigInt(2);
  const BN_27 = BigInt(27);
  const BN_28 = BigInt(28);
  const BN_35 = BigInt(35);
  const _guard = {};
  function toUint256(value) {
    return zeroPadValue(toBeArray(value), 32);
  }
  let Signature$6 = (_a = class {
    /**
     *  @private
     */
    constructor(guard, r2, s2, v) {
      __privateAdd(this, _r, void 0);
      __privateAdd(this, _s, void 0);
      __privateAdd(this, _v, void 0);
      __privateAdd(this, _networkV, void 0);
      assertPrivate(guard, _guard, "Signature");
      __privateSet(this, _r, r2);
      __privateSet(this, _s, s2);
      __privateSet(this, _v, v);
      __privateSet(this, _networkV, null);
    }
    /**
     *  The ``r`` value for a signautre.
     *
     *  This represents the ``x`` coordinate of a "reference" or
     *  challenge point, from which the ``y`` can be computed.
     */
    get r() {
      return __privateGet(this, _r);
    }
    set r(value) {
      assertArgument(dataLength(value) === 32, "invalid r", "value", value);
      __privateSet(this, _r, hexlify(value));
    }
    /**
     *  The ``s`` value for a signature.
     */
    get s() {
      return __privateGet(this, _s);
    }
    set s(_value) {
      assertArgument(dataLength(_value) === 32, "invalid s", "value", _value);
      const value = hexlify(_value);
      assertArgument(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
      __privateSet(this, _s, value);
    }
    /**
     *  The ``v`` value for a signature.
     *
     *  Since a given ``x`` value for ``r`` has two possible values for
     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
     *  values to use.
     *
     *  It is normalized to the values ``27`` or ``28`` for legacy
     *  purposes.
     */
    get v() {
      return __privateGet(this, _v);
    }
    set v(value) {
      const v = getNumber(value, "value");
      assertArgument(v === 27 || v === 28, "invalid v", "v", value);
      __privateSet(this, _v, v);
    }
    /**
     *  The EIP-155 ``v`` for legacy transactions. For non-legacy
     *  transactions, this value is ``null``.
     */
    get networkV() {
      return __privateGet(this, _networkV);
    }
    /**
     *  The chain ID for EIP-155 legacy transactions. For non-legacy
     *  transactions, this value is ``null``.
     */
    get legacyChainId() {
      const v = this.networkV;
      if (v == null) {
        return null;
      }
      return _a.getChainId(v);
    }
    /**
     *  The ``yParity`` for the signature.
     *
     *  See ``v`` for more details on how this value is used.
     */
    get yParity() {
      return this.v === 27 ? 0 : 1;
    }
    /**
     *  The [[link-eip-2098]] compact representation of the ``yParity``
     *  and ``s`` compacted into a single ``bytes32``.
     */
    get yParityAndS() {
      const yParityAndS = getBytes(this.s);
      if (this.yParity) {
        yParityAndS[0] |= 128;
      }
      return hexlify(yParityAndS);
    }
    /**
     *  The [[link-eip-2098]] compact representation.
     */
    get compactSerialized() {
      return concat$4([this.r, this.yParityAndS]);
    }
    /**
     *  The serialized representation.
     */
    get serialized() {
      return concat$4([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
    }
    /**
     *  Returns a new identical [[Signature]].
     */
    clone() {
      const clone = new _a(_guard, this.r, this.s, this.v);
      if (this.networkV) {
        __privateSet(clone, _networkV, this.networkV);
      }
      return clone;
    }
    /**
     *  Returns a representation that is compatible with ``JSON.stringify``.
     */
    toJSON() {
      const networkV = this.networkV;
      return {
        _type: "signature",
        networkV: networkV != null ? networkV.toString() : null,
        r: this.r,
        s: this.s,
        v: this.v
      };
    }
    /**
     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
     *
     *  @example:
     *    Signature.getChainId(45)
     *    //_result:
     *
     *    Signature.getChainId(46)
     *    //_result:
     */
    static getChainId(v) {
      const bv = getBigInt(v, "v");
      if (bv == BN_27 || bv == BN_28) {
        return BN_0$1;
      }
      assertArgument(bv >= BN_35, "invalid EIP-155 v", "v", v);
      return (bv - BN_35) / BN_2;
    }
    /**
     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
     *
     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
     *  property to include the chain ID.
     *
     *  @example:
     *    Signature.getChainIdV(5, 27)
     *    //_result:
     *
     *    Signature.getChainIdV(5, 28)
     *    //_result:
     *
     */
    static getChainIdV(chainId, v) {
      return getBigInt(chainId) * BN_2 + BigInt(35 + v - 27);
    }
    /**
     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
     *
     *  @example:
     *    // The values 0 and 1 imply v is actually yParity
     *    Signature.getNormalizedV(0)
     *    //_result:
     *
     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
     *    Signature.getNormalizedV(27)
     *    //_result:
     *
     *    // Legacy EIP-155 transaction (i.e. >= 35)
     *    Signature.getNormalizedV(46)
     *    //_result:
     *
     *    // Invalid values throw
     *    Signature.getNormalizedV(5)
     *    //_error:
     */
    static getNormalizedV(v) {
      const bv = getBigInt(v);
      if (bv === BN_0$1 || bv === BN_27) {
        return 27;
      }
      if (bv === BN_1 || bv === BN_28) {
        return 28;
      }
      assertArgument(bv >= BN_35, "invalid v", "v", v);
      return bv & BN_1 ? 27 : 28;
    }
    /**
     *  Creates a new [[Signature]].
     *
     *  If no %%sig%% is provided, a new [[Signature]] is created
     *  with default values.
     *
     *  If %%sig%% is a string, it is parsed.
     */
    static from(sig) {
      function assertError(check2, message2) {
        assertArgument(check2, message2, "signature", sig);
      }
      if (sig == null) {
        return new _a(_guard, ZeroHash, ZeroHash, 27);
      }
      if (typeof sig === "string") {
        const bytes2 = getBytes(sig, "signature");
        if (bytes2.length === 64) {
          const r3 = hexlify(bytes2.slice(0, 32));
          const s3 = bytes2.slice(32, 64);
          const v2 = s3[0] & 128 ? 28 : 27;
          s3[0] &= 127;
          return new _a(_guard, r3, hexlify(s3), v2);
        }
        if (bytes2.length === 65) {
          const r3 = hexlify(bytes2.slice(0, 32));
          const s3 = bytes2.slice(32, 64);
          assertError((s3[0] & 128) === 0, "non-canonical s");
          const v2 = _a.getNormalizedV(bytes2[64]);
          return new _a(_guard, r3, hexlify(s3), v2);
        }
        assertError(false, "invalid raw signature length");
      }
      if (sig instanceof _a) {
        return sig.clone();
      }
      const _r2 = sig.r;
      assertError(_r2 != null, "missing r");
      const r2 = toUint256(_r2);
      const s2 = function(s3, yParityAndS) {
        if (s3 != null) {
          return toUint256(s3);
        }
        if (yParityAndS != null) {
          assertError(isHexString$1(yParityAndS, 32), "invalid yParityAndS");
          const bytes2 = getBytes(yParityAndS);
          bytes2[0] &= 127;
          return hexlify(bytes2);
        }
        assertError(false, "missing s");
      }(sig.s, sig.yParityAndS);
      assertError((getBytes(s2)[0] & 128) == 0, "non-canonical s");
      const { networkV, v } = function(_v2, yParityAndS, yParity) {
        if (_v2 != null) {
          const v2 = getBigInt(_v2);
          return {
            networkV: v2 >= BN_35 ? v2 : void 0,
            v: _a.getNormalizedV(v2)
          };
        }
        if (yParityAndS != null) {
          assertError(isHexString$1(yParityAndS, 32), "invalid yParityAndS");
          return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
        }
        if (yParity != null) {
          switch (getNumber(yParity, "sig.yParity")) {
            case 0:
              return { v: 27 };
            case 1:
              return { v: 28 };
          }
          assertError(false, "invalid yParity");
        }
        assertError(false, "missing v");
      }(sig.v, sig.yParityAndS, sig.yParity);
      const result = new _a(_guard, r2, s2, v);
      if (networkV) {
        __privateSet(result, _networkV, networkV);
      }
      assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
      assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
      return result;
    }
  }, _r = new WeakMap(), _s = new WeakMap(), _v = new WeakMap(), _networkV = new WeakMap(), _a);
  const _SigningKey = class _SigningKey {
    /**
     *  Creates a new **SigningKey** for %%privateKey%%.
     */
    constructor(privateKey) {
      __privateAdd(this, _privateKey, void 0);
      assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
      __privateSet(this, _privateKey, hexlify(privateKey));
    }
    /**
     *  The private key.
     */
    get privateKey() {
      return __privateGet(this, _privateKey);
    }
    /**
     *  The uncompressed public key.
     *
     * This will always begin with the prefix ``0x04`` and be 132
     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
     */
    get publicKey() {
      return _SigningKey.computePublicKey(__privateGet(this, _privateKey));
    }
    /**
     *  The compressed public key.
     *
     *  This will always begin with either the prefix ``0x02`` or ``0x03``
     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
     *  nibbles)
     */
    get compressedPublicKey() {
      return _SigningKey.computePublicKey(__privateGet(this, _privateKey), true);
    }
    /**
     *  Return the signature of the signed %%digest%%.
     */
    sign(digest) {
      assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
      const sig = secp256k1$3.sign(getBytesCopy(digest), getBytesCopy(__privateGet(this, _privateKey)), {
        lowS: true
      });
      return Signature$6.from({
        r: toBeHex$1(sig.r, 32),
        s: toBeHex$1(sig.s, 32),
        v: sig.recovery ? 28 : 27
      });
    }
    /**
     *  Returns the [[link-wiki-ecdh]] shared secret between this
     *  private key and the %%other%% key.
     *
     *  The %%other%% key may be any type of key, a raw public key,
     *  a compressed/uncompressed pubic key or aprivate key.
     *
     *  Best practice is usually to use a cryptographic hash on the
     *  returned value before using it as a symetric secret.
     *
     *  @example:
     *    sign1 = new SigningKey(id("some-secret-1"))
     *    sign2 = new SigningKey(id("some-secret-2"))
     *
     *    // Notice that privA.computeSharedSecret(pubB)...
     *    sign1.computeSharedSecret(sign2.publicKey)
     *    //_result:
     *
     *    // ...is equal to privB.computeSharedSecret(pubA).
     *    sign2.computeSharedSecret(sign1.publicKey)
     *    //_result:
     */
    computeSharedSecret(other) {
      const pubKey = _SigningKey.computePublicKey(other);
      return hexlify(secp256k1$3.getSharedSecret(getBytesCopy(__privateGet(this, _privateKey)), getBytes(pubKey), false));
    }
    /**
     *  Compute the public key for %%key%%, optionally %%compressed%%.
     *
     *  The %%key%% may be any type of key, a raw public key, a
     *  compressed/uncompressed public key or private key.
     *
     *  @example:
     *    sign = new SigningKey(id("some-secret"));
     *
     *    // Compute the uncompressed public key for a private key
     *    SigningKey.computePublicKey(sign.privateKey)
     *    //_result:
     *
     *    // Compute the compressed public key for a private key
     *    SigningKey.computePublicKey(sign.privateKey, true)
     *    //_result:
     *
     *    // Compute the uncompressed public key
     *    SigningKey.computePublicKey(sign.publicKey, false);
     *    //_result:
     *
     *    // Compute the Compressed a public key
     *    SigningKey.computePublicKey(sign.publicKey, true);
     *    //_result:
     */
    static computePublicKey(key2, compressed) {
      let bytes2 = getBytes(key2, "key");
      if (bytes2.length === 32) {
        const pubKey = secp256k1$3.getPublicKey(bytes2, !!compressed);
        return hexlify(pubKey);
      }
      if (bytes2.length === 64) {
        const pub = new Uint8Array(65);
        pub[0] = 4;
        pub.set(bytes2, 1);
        bytes2 = pub;
      }
      const point2 = secp256k1$3.ProjectivePoint.fromHex(bytes2);
      return hexlify(point2.toRawBytes(compressed));
    }
    /**
     *  Returns the public key for the private key which produced the
     *  %%signature%% for the given %%digest%%.
     *
     *  @example:
     *    key = new SigningKey(id("some-secret"))
     *    digest = id("hello world")
     *    sig = key.sign(digest)
     *
     *    // Notice the signer public key...
     *    key.publicKey
     *    //_result:
     *
     *    // ...is equal to the recovered public key
     *    SigningKey.recoverPublicKey(digest, sig)
     *    //_result:
     *
     */
    static recoverPublicKey(digest, signature2) {
      assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
      const sig = Signature$6.from(signature2);
      let secpSig = secp256k1$3.Signature.fromCompact(getBytesCopy(concat$4([sig.r, sig.s])));
      secpSig = secpSig.addRecoveryBit(sig.yParity);
      const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
      assertArgument(pubKey != null, "invalid signautre for digest", "signature", signature2);
      return "0x" + pubKey.toHex(false);
    }
    /**
     *  Returns the point resulting from adding the ellipic curve points
     *  %%p0%% and %%p1%%.
     *
     *  This is not a common function most developers should require, but
     *  can be useful for certain privacy-specific techniques.
     *
     *  For example, it is used by [[HDNodeWallet]] to compute child
     *  addresses from parent public keys and chain codes.
     */
    static addPoints(p0, p1, compressed) {
      const pub0 = secp256k1$3.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p0).substring(2));
      const pub1 = secp256k1$3.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p1).substring(2));
      return "0x" + pub0.add(pub1).toHex(!!compressed);
    }
  };
  _privateKey = new WeakMap();
  let SigningKey = _SigningKey;
  const BN_0 = BigInt(0);
  const BN_36 = BigInt(36);
  function getChecksumAddress(address2) {
    address2 = address2.toLowerCase();
    const chars = address2.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i2 = 0; i2 < 40; i2++) {
      expanded[i2] = chars[i2].charCodeAt(0);
    }
    const hashed = getBytes(keccak256(expanded));
    for (let i2 = 0; i2 < 40; i2 += 2) {
      if (hashed[i2 >> 1] >> 4 >= 8) {
        chars[i2] = chars[i2].toUpperCase();
      }
      if ((hashed[i2 >> 1] & 15) >= 8) {
        chars[i2 + 1] = chars[i2 + 1].toUpperCase();
      }
    }
    return "0x" + chars.join("");
  }
  const ibanLookup = {};
  for (let i2 = 0; i2 < 10; i2++) {
    ibanLookup[String(i2)] = String(i2);
  }
  for (let i2 = 0; i2 < 26; i2++) {
    ibanLookup[String.fromCharCode(65 + i2)] = String(10 + i2);
  }
  const safeDigits = 15;
  function ibanChecksum(address2) {
    address2 = address2.toUpperCase();
    address2 = address2.substring(4) + address2.substring(0, 2) + "00";
    let expanded = address2.split("").map((c) => {
      return ibanLookup[c];
    }).join("");
    while (expanded.length >= safeDigits) {
      let block2 = expanded.substring(0, safeDigits);
      expanded = parseInt(block2, 10) % 97 + expanded.substring(block2.length);
    }
    let checksum = String(98 - parseInt(expanded, 10) % 97);
    while (checksum.length < 2) {
      checksum = "0" + checksum;
    }
    return checksum;
  }
  const Base36 = function() {
    const result = {};
    for (let i2 = 0; i2 < 36; i2++) {
      const key2 = "0123456789abcdefghijklmnopqrstuvwxyz"[i2];
      result[key2] = BigInt(i2);
    }
    return result;
  }();
  function fromBase36(value) {
    value = value.toLowerCase();
    let result = BN_0;
    for (let i2 = 0; i2 < value.length; i2++) {
      result = result * BN_36 + Base36[value[i2]];
    }
    return result;
  }
  function getAddress(address2) {
    assertArgument(typeof address2 === "string", "invalid address", "address", address2);
    if (address2.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
      if (!address2.startsWith("0x")) {
        address2 = "0x" + address2;
      }
      const result = getChecksumAddress(address2);
      assertArgument(!address2.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address2, "bad address checksum", "address", address2);
      return result;
    }
    if (address2.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
      assertArgument(address2.substring(2, 4) === ibanChecksum(address2), "bad icap checksum", "address", address2);
      let result = fromBase36(address2.substring(4)).toString(16);
      while (result.length < 40) {
        result = "0" + result;
      }
      return getChecksumAddress("0x" + result);
    }
    assertArgument(false, "invalid address", "address", address2);
  }
  function computeAddress(key2) {
    let pubkey;
    if (typeof key2 === "string") {
      pubkey = SigningKey.computePublicKey(key2, false);
    } else {
      pubkey = key2.publicKey;
    }
    return getAddress(keccak256("0x" + pubkey.substring(4)).substring(26));
  }
  function recoverAddress(digest, signature2) {
    return computeAddress(SigningKey.recoverPublicKey(digest, signature2));
  }
  var bitcoreLib = { exports: {} };
  const name$2 = "bitcore-lib";
  const version$2 = "10.0.23";
  const description$2 = "A pure and powerful JavaScript Bitcoin library.";
  const author$1 = "BitPay <dev@bitpay.com>";
  const main$2 = "index.js";
  const scripts$2 = {
    test: "gulp test",
    "test:ci": "npm run test",
    coverage: "gulp coverage",
    build: "gulp",
    pub: "npm run build && npm publish"
  };
  const keywords$2 = [
    "bitcoin",
    "transaction",
    "address",
    "p2p",
    "ecies",
    "cryptocurrency",
    "blockchain",
    "payment",
    "bip21",
    "bip32",
    "bip37",
    "bip69",
    "bip70",
    "multisig"
  ];
  const repository$2 = {
    type: "git",
    url: "https://github.com/bitpay/bitcore/tree/master/packages/bitcore-lib"
  };
  const browser$3 = {
    request: "browser-request"
  };
  const dependencies$2 = {
    bech32: "=2.0.0",
    "bip-schnorr": "=0.6.4",
    "bn.js": "=4.11.8",
    bs58: "^4.0.1",
    "buffer-compare": "=1.1.1",
    elliptic: "^6.5.3",
    inherits: "=2.0.1",
    lodash: "^4.17.20"
  };
  const devDependencies$2 = {
    "bitcore-build": "^10.0.21",
    brfs: "^2.0.1",
    chai: "^4.2.0",
    gulp: "^4.0.0",
    sinon: "^7.1.1"
  };
  const license$1 = "MIT";
  const gitHead = "5dffff0532ac0b236a3e1eb00983d89e2063afdf";
  const require$$0$2 = {
    name: name$2,
    version: version$2,
    description: description$2,
    author: author$1,
    main: main$2,
    scripts: scripts$2,
    keywords: keywords$2,
    repository: repository$2,
    browser: browser$3,
    dependencies: dependencies$2,
    devDependencies: devDependencies$2,
    license: license$1,
    gitHead
  };
  var bn$3 = { exports: {} };
  const __viteBrowserExternal = {};
  const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
  bn$3.exports;
  (function(module2) {
    (function(module3, exports2) {
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number2, base2, endian) {
        if (BN2.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number2 || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require$$1$1.Buffer;
      } catch (e) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init(number2, base2, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base2, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
        }
        if (base2 === 16) {
          this._parseHex(number2, start);
        } else {
          this._parseBase(number2, base2, start);
        }
        if (number2[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initNumber = function _initNumber(number2, base2, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initArray = function _initArray(number2, base2, endian) {
        assert2(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i2 = number2.length - 1, j = 0; i2 >= 0; i2 -= 3) {
            w = number2[i2] | number2[i2 - 1] << 8 | number2[i2 - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i2 = 0, j = 0; i2 < number2.length; i2 += 3) {
            w = number2[i2] | number2[i2 + 1] << 8 | number2[i2 + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r2 = 0;
        var len2 = Math.min(str.length, end);
        for (var i2 = start; i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          r2 <<= 4;
          if (c >= 49 && c <= 54) {
            r2 |= c - 49 + 10;
          } else if (c >= 17 && c <= 22) {
            r2 |= c - 17 + 10;
          } else {
            r2 |= c & 15;
          }
        }
        return r2;
      }
      BN2.prototype._parseHex = function _parseHex(number2, start) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j, w;
        var off = 0;
        for (i2 = number2.length - 6, j = 0; i2 >= start; i2 -= 6) {
          w = parseHex(number2, i2, i2 + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
        if (i2 + 6 !== start) {
          w = parseHex(number2, start, i2 + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r2 = 0;
        var len2 = Math.min(str.length, end);
        for (var i2 = start; i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          r2 *= mul;
          if (c >= 49) {
            r2 += c - 49 + 10;
          } else if (c >= 17) {
            r2 += c - 17 + 10;
          } else {
            r2 += c;
          }
        }
        return r2;
      }
      BN2.prototype._parseBase = function _parseBase(number2, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number2.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i2 = start; i2 < end; i2 += limbLen) {
          word = parseBase(number2, i2, i2 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow3 = 1;
          word = parseBase(number2, i2, number2.length, base2);
          for (i2 = 0; i2 < mod2; i2++) {
            pow3 *= base2;
          }
          this.imuln(pow3);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          dest.words[i2] = this.words[i2];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r2 = new BN2(null);
        this.copy(r2);
        return r2;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w = this.words[i2];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i2 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i2--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r2 = c.modn(groupBase).toString(base2);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer2(endian, length) {
        assert2(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength2 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength2);
        assert2(byteLength2 <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i2;
        var q = this.clone();
        if (!littleEndian) {
          for (i2 = 0; i2 < reqLength - byteLength2; i2++) {
            res[i2] = 0;
          }
          for (i2 = 0; !q.isZero(); i2++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i2 - 1] = b;
          }
        } else {
          for (i2 = 0; !q.isZero(); i2++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i2] = b;
          }
          for (; i2 < reqLength; i2++) {
            res[i2] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w) {
          var t = w;
          var r2 = 0;
          if (t >= 4096) {
            r2 += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r2 += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r2 += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r2 += 2;
            t >>>= 2;
          }
          return r2 + t;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r2 = 0;
        if ((t & 8191) === 0) {
          r2 += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r2 += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r2 += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r2 += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r2 = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          r2 += b;
          if (b !== 26)
            break;
        }
        return r2;
      };
      BN2.prototype.byteLength = function byteLength2() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i2 = 0; i2 < num.length; i2++) {
          this.words[i2] = this.words[i2] | num.words[i2];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = this.words[i2] & num.words[i2];
        }
        this.length = b.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = a.words[i2] ^ b.words[i2];
        }
        if (this !== a) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i2 = 0; i2 < bytesNeeded; i2++) {
          this.words[i2] = ~this.words[i2] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r2 = (a.words[i2] | 0) + (b.words[i2] | 0) + carry;
          this.words[i2] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i2 < a.length; i2++) {
          r2 = (a.words[i2] | 0) + carry;
          this.words[i2] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r2 = (a.words[i2] | 0) - (b.words[i2] | 0) + carry;
          carry = r2 >> 26;
          this.words[i2] = r2 & 67108863;
        }
        for (; carry !== 0 && i2 < a.length; i2++) {
          r2 = (a.words[i2] | 0) + carry;
          carry = r2 >> 26;
          this.words[i2] = r2 & 67108863;
        }
        if (carry === 0 && i2 < a.length && a !== this) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        this.length = Math.max(this.length, i2);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2;
        len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r2 = a * b;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k2 = 1; k2 < len2; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
            var i2 = k2 - j | 0;
            a = self2.words[i2] | 0;
            b = num.words[j] | 0;
            r2 = a * b + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
            var i2 = k2 - j;
            var a = self2.words[i2] | 0;
            var b = num.words[j] | 0;
            var r2 = a * b;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len2 < 63) {
          res = smallMulTo(this, num, out);
        } else if (len2 < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN2.prototype._countBits(N) - 1;
        for (var i2 = 0; i2 < N; i2++) {
          t[i2] = this.revBin(i2, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i2 = 0; i2 < l; i2++) {
          rb |= (x & 1) << l - i2 - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i2 = 0; i2 < N; i2++) {
          rtws[i2] = rws[rbt[i2]];
          itws[i2] = iws[rbt[i2]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s2 = 1; s2 < N; s2 <<= 1) {
          var l = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p2 = 0; p2 < N; p2 += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s2; j++) {
              var re = rtws[p2 + j];
              var ie = itws[p2 + j];
              var ro = rtws[p2 + j + s2];
              var io = itws[p2 + j + s2];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p2 + j] = re + ro;
              itws[p2 + j] = ie + io;
              rtws[p2 + j + s2] = re - ro;
              itws[p2 + j + s2] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m) {
        var N = Math.max(m, n2) | 1;
        var odd = N & 1;
        var i2 = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i2++;
        }
        return 1 << i2 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i2 = 0; i2 < N / 2; i2++) {
          var t = rws[i2];
          rws[i2] = rws[N - i2 - 1];
          rws[N - i2 - 1] = t;
          t = iws[i2];
          iws[i2] = -iws[N - i2 - 1];
          iws[N - i2 - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i2 = 0; i2 < N / 2; i2++) {
          var w = Math.round(ws[2 * i2 + 1] / N) * 8192 + Math.round(ws[2 * i2] / N) + carry;
          ws[i2] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N) {
        var carry = 0;
        for (var i2 = 0; i2 < len2; i2++) {
          carry = carry + (ws[i2] | 0);
          rws[2 * i2] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i2 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i2 = 2 * len2; i2 < N; ++i2) {
          rws[i2] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i2 = 0; i2 < N; i2++) {
          ph[i2] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _2 = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _2, rwst, iwst, N, rbt);
        this.transform(nrws, _2, nrwst, niwst, N, rbt);
        for (var i2 = 0; i2 < N; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
          rwst[i2] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _2, N, rbt);
        this.conjugate(rmws, _2, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i2] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow3(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN2(1);
        var res = this;
        for (var i2 = 0; i2 < w.length; i2++, res = res.sqr()) {
          if (w[i2] !== 0)
            break;
        }
        if (++i2 < w.length) {
          for (var q = res.sqr(); i2 < w.length; i2++, q = q.sqr()) {
            if (w[i2] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i2;
        if (r2 !== 0) {
          var carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask;
            var c = (this.words[i2] | 0) - newCarry << r2;
            this.words[i2] = c | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i2] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i2 = this.length - 1; i2 >= 0; i2--) {
            this.words[i2 + s2] = this.words[i2];
          }
          for (i2 = 0; i2 < s2; i2++) {
            this.words[i2] = 0;
          }
          this.length += s2;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r2 = bits % 26;
        var s2 = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h -= s2;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i2 = 0; i2 < s2; i2++) {
            maskedWords.words[i2] = this.words[i2];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0)
          ;
        else if (this.length > s2) {
          this.length -= s2;
          for (i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = this.words[i2 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s2)
          return false;
        var w = this.words[s2];
        return !!(w & q);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r2 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
          this.words[i2] -= 67108864;
          if (i2 === this.length - 1) {
            this.words[i2 + 1] = 1;
          } else {
            this.words[i2 + 1]++;
          }
        }
        this.length = Math.max(this.length, i2 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
            this.words[i2] += 67108864;
            this.words[i2 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift;
        var i2;
        this._expand(len2);
        var w;
        var carry = 0;
        for (i2 = 0; i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i2 + shift] = w & 67108863;
        }
        for (; i2 < this.length - shift; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i2 + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert2(carry === -1);
        carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          w = -(this.words[i2] | 0) + carry;
          carry = w >> 26;
          this.words[i2] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN2(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i2 = 0; i2 < q.length; i2++) {
            q.words[i2] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert2(num <= 67108863);
        var p2 = (1 << 26) % num;
        var acc = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          acc = (p2 * acc + (this.words[i2] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert2(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p2) {
        assert2(p2.negative === 0);
        assert2(!p2.isZero());
        var x = this;
        var y = p2.clone();
        if (x.negative !== 0) {
          x = x.umod(p2);
        } else {
          x = x.clone();
        }
        var A = new BN2(1);
        var B = new BN2(0);
        var C = new BN2(0);
        var D = new BN2(1);
        var g2 = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g2;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i2 = 0, im = 1; (x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x.iushrn(i2);
            while (i2-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g2)
        };
      };
      BN2.prototype._invmp = function _invmp(p2) {
        assert2(p2.negative === 0);
        assert2(!p2.isZero());
        var a = this;
        var b = p2.clone();
        if (a.negative !== 0) {
          a = a.umod(p2);
        } else {
          a = a.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1; (a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p2);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r2 = a.cmp(b);
          if (r2 < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r2 === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven2() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q;
          return this;
        }
        var carry = q;
        for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i2] = w;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var a = this.words[i2] | 0;
          var b = num.words[i2] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p2) {
        this.name = name2;
        this.p = new BN2(p2, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          r2.strip();
        }
        return r2;
      };
      MPrime.prototype.split = function split2(input2, out) {
        input2.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split2(input2, output2) {
        var mask = 4194303;
        var outLen = Math.min(input2.length, 9);
        for (var i2 = 0; i2 < outLen; i2++) {
          output2.words[i2] = input2.words[i2];
        }
        output2.length = outLen;
        if (input2.length <= 9) {
          input2.words[0] = 0;
          input2.length = 1;
          return;
        }
        var prev = input2.words[9];
        output2.words[output2.length++] = prev & mask;
        for (i2 = 10; i2 < input2.length; i2++) {
          var next = input2.words[i2] | 0;
          input2.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input2.words[i2 - 10] = prev;
        if (prev === 0 && input2.length > 10) {
          input2.length -= 10;
        } else {
          input2.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977;
          num.words[i2] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i2] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN2._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert2(a.negative === 0, "red works only with positives");
        assert2(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert2((a.negative | b.negative) === 0, "red works only with positives");
        assert2(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow3 = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a, pow3);
        }
        var q = this.m.subn(1);
        var s2 = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s2++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one2 = new BN2(1).toRed(this);
        var nOne = one2.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN2(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r2 = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s2;
        while (t.cmp(one2) !== 0) {
          var tmp = t;
          for (var i2 = 0; tmp.cmp(one2) !== 0; i2++) {
            tmp = tmp.redSqr();
          }
          assert2(i2 < m);
          var b = this.pow(c, new BN2(1).iushln(m - i2 - 1));
          r2 = r2.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i2;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow3(a, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a;
        for (var i2 = 2; i2 < wnd.length; i2++) {
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i2 = num.length - 1; i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i2 !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont2(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN2(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(module2, commonjsGlobal);
  })(bn$3);
  var bnExports$2 = bn$3.exports;
  var errors$5 = { exports: {} };
  var lodash = { exports: {} };
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  lodash.exports;
  (function(module2, exports2) {
    (function() {
      var undefined$12;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar2 = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal || freeSelf || Function("return this")();
      var freeExports = exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key2, collection2) {
          if (predicate(value, key2, collection2)) {
            result = key2;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key2) {
        return function(object2) {
          return object2 == null ? undefined$12 : object2[key2];
        };
      }
      function basePropertyOf(object2) {
        return function(key2) {
          return object2 == null ? undefined$12 : object2[key2];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined$12) {
            result = result === undefined$12 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n2, iteratee) {
        var index = -1, result = Array(n2);
        while (++index < n2) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object2, props) {
        return arrayMap(props, function(key2) {
          return [key2, object2[key2]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object2, props) {
        return arrayMap(props, function(key2) {
          return object2[key2];
        });
      }
      function cacheHas(cache2, key2) {
        return cache2.has(key2);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object2, key2) {
        return object2 == null ? undefined$12 : object2[key2];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data2, result = [];
        while (!(data2 = iterator.next()).done) {
          result.push(data2.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key2) {
          result[++index] = [key2, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root2 : _2.defaults(root2.Object(), context, _2.pick(root2, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root2._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined$12, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$12, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$12, symIterator = Symbol2 ? Symbol2.iterator : undefined$12, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$12;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$12, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined$12, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$12, symbolToString = symbolProto ? symbolProto.toString : undefined$12;
        function lodash2(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object2() {
          }
          return function(proto2) {
            if (!isObject(proto2)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto2);
            }
            object2.prototype = proto2;
            var result2 = new object2();
            object2.prototype = undefined$12;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$12;
        }
        lodash2.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash2
          }
        };
        lodash2.prototype = baseLodash.prototype;
        lodash2.prototype.constructor = lodash2;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type2 = data2.type, computed = iteratee2(value);
                if (type2 == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type2 == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash2(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key2) {
          var result2 = this.has(key2) && delete this.__data__[key2];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key2) {
          var data2 = this.__data__;
          if (nativeCreate) {
            var result2 = data2[key2];
            return result2 === HASH_UNDEFINED ? undefined$12 : result2;
          }
          return hasOwnProperty2.call(data2, key2) ? data2[key2] : undefined$12;
        }
        function hashHas(key2) {
          var data2 = this.__data__;
          return nativeCreate ? data2[key2] !== undefined$12 : hasOwnProperty2.call(data2, key2);
        }
        function hashSet(key2, value) {
          var data2 = this.__data__;
          this.size += this.has(key2) ? 0 : 1;
          data2[key2] = nativeCreate && value === undefined$12 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash2.prototype.clear = hashClear;
        Hash2.prototype["delete"] = hashDelete;
        Hash2.prototype.get = hashGet;
        Hash2.prototype.has = hashHas;
        Hash2.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key2) {
          var data2 = this.__data__, index = assocIndexOf(data2, key2);
          if (index < 0) {
            return false;
          }
          var lastIndex = data2.length - 1;
          if (index == lastIndex) {
            data2.pop();
          } else {
            splice.call(data2, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key2) {
          var data2 = this.__data__, index = assocIndexOf(data2, key2);
          return index < 0 ? undefined$12 : data2[index][1];
        }
        function listCacheHas(key2) {
          return assocIndexOf(this.__data__, key2) > -1;
        }
        function listCacheSet(key2, value) {
          var data2 = this.__data__, index = assocIndexOf(data2, key2);
          if (index < 0) {
            ++this.size;
            data2.push([key2, value]);
          } else {
            data2[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash2(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash2()
          };
        }
        function mapCacheDelete(key2) {
          var result2 = getMapData(this, key2)["delete"](key2);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key2) {
          return getMapData(this, key2).get(key2);
        }
        function mapCacheHas(key2) {
          return getMapData(this, key2).has(key2);
        }
        function mapCacheSet(key2, value) {
          var data2 = getMapData(this, key2), size2 = data2.size;
          data2.set(key2, value);
          this.size += data2.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data2 = this.__data__ = new ListCache(entries);
          this.size = data2.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key2) {
          var data2 = this.__data__, result2 = data2["delete"](key2);
          this.size = data2.size;
          return result2;
        }
        function stackGet(key2) {
          return this.__data__.get(key2);
        }
        function stackHas(key2) {
          return this.__data__.has(key2);
        }
        function stackSet(key2, value) {
          var data2 = this.__data__;
          if (data2 instanceof ListCache) {
            var pairs = data2.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key2, value]);
              this.size = ++data2.size;
              return this;
            }
            data2 = this.__data__ = new MapCache(pairs);
          }
          data2.set(key2, value);
          this.size = data2.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key2 in value) {
            if ((inherited || hasOwnProperty2.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
            isIndex(key2, length)))) {
              result2.push(key2);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined$12;
        }
        function arraySampleSize(array, n2) {
          return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object2, key2, value) {
          if (value !== undefined$12 && !eq(object2[key2], value) || value === undefined$12 && !(key2 in object2)) {
            baseAssignValue(object2, key2, value);
          }
        }
        function assignValue(object2, key2, value) {
          var objValue = object2[key2];
          if (!(hasOwnProperty2.call(object2, key2) && eq(objValue, value)) || value === undefined$12 && !(key2 in object2)) {
            baseAssignValue(object2, key2, value);
          }
        }
        function assocIndexOf(array, key2) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key2)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key2, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object2, source) {
          return object2 && copyObject(source, keys(source), object2);
        }
        function baseAssignIn(object2, source) {
          return object2 && copyObject(source, keysIn(source), object2);
        }
        function baseAssignValue(object2, key2, value) {
          if (key2 == "__proto__" && defineProperty) {
            defineProperty(object2, key2, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object2[key2] = value;
          }
        }
        function baseAt(object2, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object2 == null;
          while (++index < length) {
            result2[index] = skip ? undefined$12 : get2(object2, paths[index]);
          }
          return result2;
        }
        function baseClamp(number2, lower, upper) {
          if (number2 === number2) {
            if (upper !== undefined$12) {
              number2 = number2 <= upper ? number2 : upper;
            }
            if (lower !== undefined$12) {
              number2 = number2 >= lower ? number2 : lower;
            }
          }
          return number2;
        }
        function baseClone(value, bitmask, customizer, key2, object2, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object2 ? customizer(value, key2, object2, stack) : customizer(value);
          }
          if (result2 !== undefined$12) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object2) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object2 ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key3) {
              result2.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined$12 : keysFunc(value);
          arrayEach(props || value, function(subValue, key3) {
            if (props) {
              key3 = subValue;
              subValue = value[key3];
            }
            assignValue(result2, key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object2) {
            return baseConformsTo(object2, source, props);
          };
        }
        function baseConformsTo(object2, source, props) {
          var length = props.length;
          if (object2 == null) {
            return !length;
          }
          object2 = Object2(object2);
          while (length--) {
            var key2 = props[length], predicate = source[key2], value = object2[key2];
            if (value === undefined$12 && !(key2 in object2) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() {
            func.apply(undefined$12, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes3 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes3 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes3 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes3(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined$12 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined$12 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object2, iteratee2) {
          return object2 && baseFor(object2, iteratee2, keys);
        }
        function baseForOwnRight(object2, iteratee2) {
          return object2 && baseForRight(object2, iteratee2, keys);
        }
        function baseFunctions(object2, props) {
          return arrayFilter(props, function(key2) {
            return isFunction(object2[key2]);
          });
        }
        function baseGet(object2, path) {
          path = castPath(path, object2);
          var index = 0, length = path.length;
          while (object2 != null && index < length) {
            object2 = object2[toKey(path[index++])];
          }
          return index && index == length ? object2 : undefined$12;
        }
        function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object2);
          return isArray(object2) ? result2 : arrayPush(result2, symbolsFunc(object2));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$12 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object2, key2) {
          return object2 != null && hasOwnProperty2.call(object2, key2);
        }
        function baseHasIn(object2, key2) {
          return object2 != null && key2 in Object2(object2);
        }
        function baseInRange(number2, start, end) {
          return number2 >= nativeMin(start, end) && number2 < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes3 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$12;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes3(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache2 = caches[othIndex];
                  if (!(cache2 ? cacheHas(cache2, computed) : includes3(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object2, setter, iteratee2, accumulator) {
          baseForOwn(object2, function(value, key2, object3) {
            setter(accumulator, iteratee2(value), key2, object3);
          });
          return accumulator;
        }
        function baseInvoke(object2, path, args) {
          path = castPath(path, object2);
          object2 = parent(object2, path);
          var func = object2 == null ? object2 : object2[toKey(last(path))];
          return func == null ? undefined$12 : apply(func, object2, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object2)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray2(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object2, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object2 == null) {
            return !length;
          }
          object2 = Object2(object2);
          while (index--) {
            var data2 = matchData[index];
            if (noCustomizer && data2[2] ? data2[1] !== object2[data2[0]] : !(data2[0] in object2)) {
              return false;
            }
          }
          while (++index < length) {
            data2 = matchData[index];
            var key2 = data2[0], objValue = object2[key2], srcValue = data2[1];
            if (noCustomizer && data2[2]) {
              if (objValue === undefined$12 && !(key2 in object2)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key2, object2, source, stack);
              }
              if (!(result2 === undefined$12 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object2) {
          if (!isPrototype(object2)) {
            return nativeKeys(object2);
          }
          var result2 = [];
          for (var key2 in Object2(object2)) {
            if (hasOwnProperty2.call(object2, key2) && key2 != "constructor") {
              result2.push(key2);
            }
          }
          return result2;
        }
        function baseKeysIn(object2) {
          if (!isObject(object2)) {
            return nativeKeysIn(object2);
          }
          var isProto = isPrototype(object2), result2 = [];
          for (var key2 in object2) {
            if (!(key2 == "constructor" && (isProto || !hasOwnProperty2.call(object2, key2)))) {
              result2.push(key2);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key2, collection2) {
            result2[++index] = iteratee2(value, key2, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object2) {
            return object2 === source || baseIsMatch(object2, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object2) {
            var objValue = get2(object2, path);
            return objValue === undefined$12 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object2, source, srcIndex, customizer, stack) {
          if (object2 === source) {
            return;
          }
          baseFor(source, function(srcValue, key2) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object2, source, key2, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object2, key2), srcValue, key2 + "", object2, source, stack) : undefined$12;
              if (newValue === undefined$12) {
                newValue = srcValue;
              }
              assignMergeValue(object2, key2, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object2, source, key2, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object2, key2), srcValue = safeGet(source, key2), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object2, key2, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object2, source, stack) : undefined$12;
          var isCommon = newValue === undefined$12;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments2(srcValue)) {
              newValue = objValue;
              if (isArguments2(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object2, key2, newValue);
        }
        function baseNth(array, n2) {
          var length = array.length;
          if (!length) {
            return;
          }
          n2 += n2 < 0 ? length : 0;
          return isIndex(n2, length) ? array[n2] : undefined$12;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key2, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object2, other) {
            return compareMultiple(object2, other, orders);
          });
        }
        function basePick(object2, paths) {
          return basePickBy(object2, paths, function(value, path) {
            return hasIn(object2, path);
          });
        }
        function basePickBy(object2, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object2, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object2), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object2) {
            return baseGet(object2, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n2) {
          var result2 = "";
          if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n2 % 2) {
              result2 += string;
            }
            n2 = nativeFloor(n2 / 2);
            if (n2) {
              string += string;
            }
          } while (n2);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n2) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n2, 0, array.length));
        }
        function baseSet(object2, path, value, customizer) {
          if (!isObject(object2)) {
            return object2;
          }
          path = castPath(path, object2);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object2;
          while (nested != null && ++index < length) {
            var key2 = toKey(path[index]), newValue = value;
            if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
              return object2;
            }
            if (index != lastIndex) {
              var objValue = nested[key2];
              newValue = customizer ? customizer(objValue, key2, nested) : undefined$12;
              if (newValue === undefined$12) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key2, newValue);
            nested = nested[key2];
          }
          return object2;
        }
        var baseSetData = !metaMap ? identity : function(func, data2) {
          metaMap.set(func, data2);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$12;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$12, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes3 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes3 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes3 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes3(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object2, path) {
          path = castPath(path, object2);
          object2 = parent(object2, path);
          return object2 == null || delete object2[toKey(last(path))];
        }
        function baseUpdate(object2, path, updater, customizer) {
          return baseSet(object2, path, updater(baseGet(object2, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined$12;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object2) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object2) ? [value] : stringToPath2(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined$12 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout = ctxClearTimeout || function(id) {
          return root2.clearTimeout(id);
        };
        function cloneBuffer(buffer2, isDeep) {
          if (isDeep) {
            return buffer2.slice();
          }
          var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
          buffer2.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$12, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined$12, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object2, other, orders) {
          var index = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object2.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object2, customizer) {
          var isNew = !object2;
          object2 || (object2 = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key2 = props[index];
            var newValue = customizer ? customizer(object2[key2], source[key2], key2, object2, source) : undefined$12;
            if (newValue === undefined$12) {
              newValue = source[key2];
            }
            if (isNew) {
              baseAssignValue(object2, key2, newValue);
            } else {
              assignValue(object2, key2, newValue);
            }
          }
          return object2;
        }
        function copySymbols(source, object2) {
          return copyObject(source, getSymbols(source), object2);
        }
        function copySymbolsIn(source, object2) {
          return copyObject(source, getSymbolsIn(source), object2);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object2, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$12, guard = length > 2 ? sources[2] : undefined$12;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$12;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined$12 : customizer;
              length = 1;
            }
            object2 = Object2(object2);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object2, source, index, customizer);
              }
            }
            return object2;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object2, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object2), props = keysFunc(object2), length = props.length;
            while (length--) {
              var key2 = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key2], key2, iterable) === false) {
                break;
              }
            }
            return object2;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$12;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined$12,
                args,
                holders,
                undefined$12,
                undefined$12,
                arity - length
              );
            }
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key2) {
                return iteratee2(iterable[key2], key2, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$12;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData(func) : undefined$12;
              if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
                wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$12 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root2 && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object2, iteratee2) {
            return baseInverter(object2, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined$12 && other === undefined$12) {
              return defaultValue;
            }
            if (value !== undefined$12) {
              result2 = value;
            }
            if (other !== undefined$12) {
              if (result2 === undefined$12) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined$12 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined$12;
            }
            start = toFinite(start);
            if (end === undefined$12) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined$12 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$12, newHoldersRight = isCurry ? undefined$12 : holders, newPartials = isCurry ? partials : undefined$12, newPartialsRight = isCurry ? undefined$12 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined$12, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number2, precision) {
            number2 = toNumber(number2);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number2)) {
              var pair = (toString(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number2);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object2) {
            var tag = getTag(object2);
            if (tag == mapTag) {
              return mapToArray(object2);
            }
            if (tag == setTag) {
              return setToPairs(object2);
            }
            return baseToPairs(object2, keysFunc(object2));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined$12;
          }
          ary2 = ary2 === undefined$12 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined$12 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined$12;
          }
          var data2 = isBindKey ? undefined$12 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data2) {
            mergeData(newData, data2);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined$12 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined$12, newData);
          }
          var setter = data2 ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key2, object2) {
          if (objValue === undefined$12 || eq(objValue, objectProto[key2]) && !hasOwnProperty2.call(object2, key2)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key2, object2, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined$12, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined$12 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$12;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined$12) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
                return false;
              }
              object2 = object2.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object2, +other);
            case errorTag:
              return object2.name == other.name && object2.message == other.message;
            case regexpTag:
            case stringTag:
              return object2 == other + "";
            case mapTag:
              var convert2 = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert2 || (convert2 = setToArray);
              if (object2.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object2);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object2, other);
              var result2 = equalArrays(convert2(object2), convert2(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object2);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object2) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key2 = objProps[index];
            if (!(isPartial ? key2 in other : hasOwnProperty2.call(other, key2))) {
              return false;
            }
          }
          var objStacked = stack.get(object2);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object2;
          }
          var result2 = true;
          stack.set(object2, other);
          stack.set(other, object2);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key2 = objProps[index];
            var objValue = object2[key2], othValue = other[key2];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key2, other, object2, stack) : customizer(objValue, othValue, key2, object2, other, stack);
            }
            if (!(compared === undefined$12 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key2 == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object2.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object2);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined$12, flatten), func + "");
        }
        function getAllKeys(object2) {
          return baseGetAllKeys(object2, keys, getSymbols);
        }
        function getAllKeysIn(object2) {
          return baseGetAllKeys(object2, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop2 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data2 = array[length], otherFunc = data2.func;
            if (otherFunc == null || otherFunc == func) {
              return data2.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object2 = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
          return object2.placeholder;
        }
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key2) {
          var data2 = map2.__data__;
          return isKeyable(key2) ? data2[typeof key2 == "string" ? "string" : "hash"] : data2.map;
        }
        function getMatchData(object2) {
          var result2 = keys(object2), length = result2.length;
          while (length--) {
            var key2 = result2[length], value = object2[key2];
            result2[length] = [key2, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object2, key2) {
          var value = getValue(object2, key2);
          return baseIsNative(value) ? value : undefined$12;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined$12;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
          if (object2 == null) {
            return [];
          }
          object2 = Object2(object2);
          return arrayFilter(nativeGetSymbols(object2), function(symbol) {
            return propertyIsEnumerable.call(object2, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
          var result2 = [];
          while (object2) {
            arrayPush(result2, getSymbols(object2));
            object2 = getPrototype(object2);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$12, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data2 = transforms[index], size2 = data2.size;
            switch (data2.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object2, path, hasFunc) {
          path = castPath(path, object2);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key2 = toKey(path[index]);
            if (!(result2 = object2 != null && hasFunc(object2, key2))) {
              break;
            }
            object2 = object2[key2];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object2 == null ? 0 : object2.length;
          return !!length && isLength(length) && isIndex(key2, length) && (isArray(object2) || isArguments2(object2));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object2) {
          return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
        }
        function initCloneByTag(object2, tag, isDeep) {
          var Ctor = object2.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object2);
            case boolTag:
            case dateTag:
              return new Ctor(+object2);
            case dataViewTag:
              return cloneDataView(object2, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object2, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object2);
            case regexpTag:
              return cloneRegExp(object2);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object2);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments2(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type2 = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object2) {
          if (!isObject(object2)) {
            return false;
          }
          var type2 = typeof index;
          if (type2 == "number" ? isArrayLike(object2) && isIndex(index, object2.length) : type2 == "string" && index in object2) {
            return eq(object2[index], value);
          }
          return false;
        }
        function isKey(value, object2) {
          if (isArray(value)) {
            return false;
          }
          var type2 = typeof value;
          if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object2(object2);
        }
        function isKeyable(value) {
          var type2 = typeof value;
          return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash2[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data2 = getData(other);
          return !!data2 && func === data2[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto2;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key2, srcValue) {
          return function(object2) {
            if (object2 == null) {
              return false;
            }
            return object2[key2] === srcValue && (srcValue !== undefined$12 || key2 in Object2(object2));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key2) {
            if (cache2.size === MAX_MEMOIZE_SIZE) {
              cache2.clear();
            }
            return key2;
          });
          var cache2 = result2.cache;
          return result2;
        }
        function mergeData(data2, source) {
          var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data2;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data2[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data2[3];
            data2[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data2[5];
            data2[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data2[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data2[8] = data2[8] == null ? source[8] : nativeMin(data2[8], source[8]);
          }
          if (data2[9] == null) {
            data2[9] = source[9];
          }
          data2[0] = source[0];
          data2[1] = newBitmask;
          return data2;
        }
        function nativeKeysIn(object2) {
          var result2 = [];
          if (object2 != null) {
            for (var key2 in Object2(object2)) {
              result2.push(key2);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined$12 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object2, path) {
          return path.length < 2 ? object2 : baseGet(object2, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$12;
          }
          return array;
        }
        function safeGet(object2, key2) {
          if (key2 === "constructor" && typeof object2[key2] === "function") {
            return;
          }
          if (key2 == "__proto__") {
            return;
          }
          return object2[key2];
        }
        var setData = shortOut(baseSetData);
        var setTimeout = ctxSetTimeout || function(func, wait) {
          return root2.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined$12, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined$12 ? length : size2;
          while (++index < size2) {
            var rand2 = baseRandom(index, lastIndex), value = array[rand2];
            array[rand2] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath2 = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName2, function(match, number2, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar2, "$1") : number2 || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$12) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat2() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$12;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$12;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$12, comparator) : [];
        });
        function drop(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined$12 ? 1 : toInteger(n2);
          return baseSlice(array, n2 < 0 ? 0 : n2, length);
        }
        function dropRight(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined$12 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined$12) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined$12 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined$12;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined$12;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined$12;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$12, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined$12;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined$12) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n2) {
          return array && array.length ? baseNth(array, toInteger(n2)) : undefined$12;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$12, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice2(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined$12 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n2, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n2 = guard || n2 === undefined$12 ? 1 : toInteger(n2);
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function takeRight(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined$12 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array, n2 < 0 ? 0 : n2, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$12;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$12;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$12, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined$12;
          return array && array.length ? baseUniq(array, undefined$12, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined$12, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$12;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$12;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$12, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$12;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$12;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash2(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object2) {
            return baseAt(object2, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined$12
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined$12);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined$12) {
            this.__values__ = toArray2(this.value());
          }
          var done2 = this.__index__ >= this.__values__.length, value = done2 ? undefined$12 : this.__values__[this.__index__++];
          return { "done": done2, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined$12;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined$12
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key2) {
          if (hasOwnProperty2.call(result2, key2)) {
            ++result2[key2];
          } else {
            baseAssignValue(result2, key2, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$12;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined$12 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach2(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key2) {
          if (hasOwnProperty2.call(result2, key2)) {
            result2[key2].push(value);
          } else {
            baseAssignValue(result2, key2, [value]);
          }
        });
        function includes2(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key2) {
          baseAssignValue(result2, key2, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$12 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key2) {
          result2[key2 ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n2, guard) {
          if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined$12) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n2);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$12;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root2.Date.now();
        };
        function after(n2, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n2, guard) {
          n2 = guard ? undefined$12 : n2;
          n2 = func && n2 == null ? func.length : n2;
          return createWrap(func, WRAP_ARY_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, n2);
        }
        function before(n2, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n2 <= 1) {
              func = undefined$12;
            }
            return result2;
          };
        }
        var bind2 = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind2));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object2, key2, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key2, bitmask, object2, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined$12 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, undefined$12, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$12 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, undefined$12, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined$12;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined$12 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined$12;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$12;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined$12) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$12;
          }
          function flush() {
            return timerId === undefined$12 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined$12) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$12) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
            if (cache2.has(key2)) {
              return cache2.get(key2);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache2.set(key2, result2) || cache2;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once2(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$12, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$12, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$12, undefined$12, undefined$12, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined$12 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$12;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$12;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object2, source) {
          return source == null || baseConformsTo(object2, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments2 = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray2(value) || isArguments2(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key2 in value) {
            if (hasOwnProperty2.call(value, key2)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$12;
          var result2 = customizer ? customizer(value, other) : undefined$12;
          return result2 === undefined$12 ? baseIsEqual(value, other, undefined$12, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type2 = typeof value;
          return value != null && (type2 == "object" || type2 == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object2, source) {
          return object2 === source || baseIsMatch(object2, source, getMatchData(source));
        }
        function isMatchWith(object2, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$12;
          return baseIsMatch(object2, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto2 = getPrototype(value);
          if (proto2 === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto2, "constructor") && proto2.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined$12;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray2(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign2 = value < 0 ? -1 : 1;
            return sign2 * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object2, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object2);
            return;
          }
          for (var key2 in source) {
            if (hasOwnProperty2.call(source, key2)) {
              assignValue(object2, key2, source[key2]);
            }
          }
        });
        var assignIn = createAssigner(function(object2, source) {
          copyObject(source, keysIn(source), object2);
        });
        var assignInWith = createAssigner(function(object2, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object2, customizer);
        });
        var assignWith = createAssigner(function(object2, source, srcIndex, customizer) {
          copyObject(source, keys(source), object2, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object2, sources) {
          object2 = Object2(object2);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined$12;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key2 = props[propsIndex];
              var value = object2[key2];
              if (value === undefined$12 || eq(value, objectProto[key2]) && !hasOwnProperty2.call(object2, key2)) {
                object2[key2] = source[key2];
              }
            }
          }
          return object2;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined$12, customDefaultsMerge);
          return apply(mergeWith, undefined$12, args);
        });
        function findKey(object2, predicate) {
          return baseFindKey(object2, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object2, predicate) {
          return baseFindKey(object2, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object2, iteratee2) {
          return object2 == null ? object2 : baseFor(object2, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object2, iteratee2) {
          return object2 == null ? object2 : baseForRight(object2, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object2, iteratee2) {
          return object2 && baseForOwn(object2, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object2, iteratee2) {
          return object2 && baseForOwnRight(object2, getIteratee(iteratee2, 3));
        }
        function functions(object2) {
          return object2 == null ? [] : baseFunctions(object2, keys(object2));
        }
        function functionsIn(object2) {
          return object2 == null ? [] : baseFunctions(object2, keysIn(object2));
        }
        function get2(object2, path, defaultValue) {
          var result2 = object2 == null ? undefined$12 : baseGet(object2, path);
          return result2 === undefined$12 ? defaultValue : result2;
        }
        function has(object2, path) {
          return object2 != null && hasPath(object2, path, baseHas);
        }
        function hasIn(object2, path) {
          return object2 != null && hasPath(object2, path, baseHasIn);
        }
        var invert2 = createInverter(function(result2, value, key2) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key2;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key2) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key2);
          } else {
            result2[value] = [key2];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
        }
        function keysIn(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
        }
        function mapKeys(object2, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object2, function(value, key2, object3) {
            baseAssignValue(result2, iteratee2(value, key2, object3), value);
          });
          return result2;
        }
        function mapValues(object2, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object2, function(value, key2, object3) {
            baseAssignValue(result2, key2, iteratee2(value, key2, object3));
          });
          return result2;
        }
        var merge = createAssigner(function(object2, source, srcIndex) {
          baseMerge(object2, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object2, source, srcIndex, customizer) {
          baseMerge(object2, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object2, paths) {
          var result2 = {};
          if (object2 == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object2);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object2, getAllKeysIn(object2), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object2, predicate) {
          return pickBy(object2, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object2, paths) {
          return object2 == null ? {} : basePick(object2, paths);
        });
        function pickBy(object2, predicate) {
          if (object2 == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object2), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object2, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object2, path, defaultValue) {
          path = castPath(path, object2);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object2 = undefined$12;
          }
          while (++index < length) {
            var value = object2 == null ? undefined$12 : object2[toKey(path[index])];
            if (value === undefined$12) {
              index = length;
              value = defaultValue;
            }
            object2 = isFunction(value) ? value.call(object2) : value;
          }
          return object2;
        }
        function set(object2, path, value) {
          return object2 == null ? object2 : baseSet(object2, path, value);
        }
        function setWith(object2, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$12;
          return object2 == null ? object2 : baseSet(object2, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object2, iteratee2, accumulator) {
          var isArr = isArray(object2), isArrLike = isArr || isBuffer(object2) || isTypedArray2(object2);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object2 && object2.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object2)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object2)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index, object3) {
            return iteratee2(accumulator, value, index, object3);
          });
          return accumulator;
        }
        function unset(object2, path) {
          return object2 == null ? true : baseUnset(object2, path);
        }
        function update(object2, path, updater) {
          return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater));
        }
        function updateWith(object2, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$12;
          return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater), customizer);
        }
        function values(object2) {
          return object2 == null ? [] : baseValues(object2, keys(object2));
        }
        function valuesIn(object2) {
          return object2 == null ? [] : baseValues(object2, keysIn(object2));
        }
        function clamp(number2, lower, upper) {
          if (upper === undefined$12) {
            upper = lower;
            lower = undefined$12;
          }
          if (upper !== undefined$12) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined$12) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number2), lower, upper);
        }
        function inRange(number2, start, end) {
          start = toFinite(start);
          if (end === undefined$12) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number2 = toNumber(number2);
          return baseInRange(number2, start, end);
        }
        function random2(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined$12;
          }
          if (floating === undefined$12) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined$12;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined$12;
            }
          }
          if (lower === undefined$12 && upper === undefined$12) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined$12) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand2 = nativeRandom();
            return nativeMin(lower + rand2 * (upper - lower + freeParseFloat("1e-" + ((rand2 + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith2(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined$12 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n2, guard) {
          if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined$12) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          return baseRepeat(toString(string), n2);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split2(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined$12;
          }
          limit = limit === undefined$12 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith2(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash2.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined$12;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$12, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$12)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$12)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$12)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined$12) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined$12 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined$12 : pattern;
          if (pattern === undefined$12) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined$12, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object2, methodNames) {
          arrayEach(methodNames, function(key2) {
            key2 = toKey(key2);
            baseAssignValue(object2, key2, bind2(object2[key2], object2));
          });
          return object2;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method2 = baseRest(function(path, args) {
          return function(object2) {
            return baseInvoke(object2, path, args);
          };
        });
        var methodOf = baseRest(function(object2, args) {
          return function(path) {
            return baseInvoke(object2, path, args);
          };
        });
        function mixin(object2, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object2;
            object2 = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object2);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object2[methodName] = func;
            if (isFunc) {
              object2.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object2(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object2 });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object2, arrayPush([this.value()], arguments));
              };
            }
          });
          return object2;
        }
        function noConflict() {
          if (root2._ === this) {
            root2._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n2) {
          n2 = toInteger(n2);
          return baseRest(function(args) {
            return baseNth(args, n2);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object2) {
          return function(path) {
            return object2 == null ? undefined$12 : baseGet(object2, path);
          };
        }
        var range2 = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n2, iteratee2) {
          n2 = toInteger(n2);
          if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n2 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n2) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath2(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max2(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$12;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$12;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$12;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$12;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash2.after = after;
        lodash2.ary = ary;
        lodash2.assign = assign;
        lodash2.assignIn = assignIn;
        lodash2.assignInWith = assignInWith;
        lodash2.assignWith = assignWith;
        lodash2.at = at;
        lodash2.before = before;
        lodash2.bind = bind2;
        lodash2.bindAll = bindAll;
        lodash2.bindKey = bindKey;
        lodash2.castArray = castArray;
        lodash2.chain = chain;
        lodash2.chunk = chunk;
        lodash2.compact = compact;
        lodash2.concat = concat2;
        lodash2.cond = cond;
        lodash2.conforms = conforms;
        lodash2.constant = constant;
        lodash2.countBy = countBy;
        lodash2.create = create;
        lodash2.curry = curry;
        lodash2.curryRight = curryRight;
        lodash2.debounce = debounce;
        lodash2.defaults = defaults;
        lodash2.defaultsDeep = defaultsDeep;
        lodash2.defer = defer;
        lodash2.delay = delay;
        lodash2.difference = difference;
        lodash2.differenceBy = differenceBy;
        lodash2.differenceWith = differenceWith;
        lodash2.drop = drop;
        lodash2.dropRight = dropRight;
        lodash2.dropRightWhile = dropRightWhile;
        lodash2.dropWhile = dropWhile;
        lodash2.fill = fill;
        lodash2.filter = filter;
        lodash2.flatMap = flatMap;
        lodash2.flatMapDeep = flatMapDeep;
        lodash2.flatMapDepth = flatMapDepth;
        lodash2.flatten = flatten;
        lodash2.flattenDeep = flattenDeep;
        lodash2.flattenDepth = flattenDepth;
        lodash2.flip = flip;
        lodash2.flow = flow;
        lodash2.flowRight = flowRight;
        lodash2.fromPairs = fromPairs;
        lodash2.functions = functions;
        lodash2.functionsIn = functionsIn;
        lodash2.groupBy = groupBy;
        lodash2.initial = initial;
        lodash2.intersection = intersection;
        lodash2.intersectionBy = intersectionBy;
        lodash2.intersectionWith = intersectionWith;
        lodash2.invert = invert2;
        lodash2.invertBy = invertBy;
        lodash2.invokeMap = invokeMap;
        lodash2.iteratee = iteratee;
        lodash2.keyBy = keyBy;
        lodash2.keys = keys;
        lodash2.keysIn = keysIn;
        lodash2.map = map;
        lodash2.mapKeys = mapKeys;
        lodash2.mapValues = mapValues;
        lodash2.matches = matches;
        lodash2.matchesProperty = matchesProperty;
        lodash2.memoize = memoize;
        lodash2.merge = merge;
        lodash2.mergeWith = mergeWith;
        lodash2.method = method2;
        lodash2.methodOf = methodOf;
        lodash2.mixin = mixin;
        lodash2.negate = negate;
        lodash2.nthArg = nthArg;
        lodash2.omit = omit;
        lodash2.omitBy = omitBy;
        lodash2.once = once2;
        lodash2.orderBy = orderBy;
        lodash2.over = over;
        lodash2.overArgs = overArgs;
        lodash2.overEvery = overEvery;
        lodash2.overSome = overSome;
        lodash2.partial = partial;
        lodash2.partialRight = partialRight;
        lodash2.partition = partition;
        lodash2.pick = pick;
        lodash2.pickBy = pickBy;
        lodash2.property = property;
        lodash2.propertyOf = propertyOf;
        lodash2.pull = pull;
        lodash2.pullAll = pullAll;
        lodash2.pullAllBy = pullAllBy;
        lodash2.pullAllWith = pullAllWith;
        lodash2.pullAt = pullAt;
        lodash2.range = range2;
        lodash2.rangeRight = rangeRight;
        lodash2.rearg = rearg;
        lodash2.reject = reject;
        lodash2.remove = remove;
        lodash2.rest = rest;
        lodash2.reverse = reverse;
        lodash2.sampleSize = sampleSize;
        lodash2.set = set;
        lodash2.setWith = setWith;
        lodash2.shuffle = shuffle;
        lodash2.slice = slice2;
        lodash2.sortBy = sortBy;
        lodash2.sortedUniq = sortedUniq;
        lodash2.sortedUniqBy = sortedUniqBy;
        lodash2.split = split2;
        lodash2.spread = spread;
        lodash2.tail = tail;
        lodash2.take = take;
        lodash2.takeRight = takeRight;
        lodash2.takeRightWhile = takeRightWhile;
        lodash2.takeWhile = takeWhile;
        lodash2.tap = tap;
        lodash2.throttle = throttle;
        lodash2.thru = thru;
        lodash2.toArray = toArray2;
        lodash2.toPairs = toPairs;
        lodash2.toPairsIn = toPairsIn;
        lodash2.toPath = toPath;
        lodash2.toPlainObject = toPlainObject;
        lodash2.transform = transform;
        lodash2.unary = unary;
        lodash2.union = union;
        lodash2.unionBy = unionBy;
        lodash2.unionWith = unionWith;
        lodash2.uniq = uniq;
        lodash2.uniqBy = uniqBy;
        lodash2.uniqWith = uniqWith;
        lodash2.unset = unset;
        lodash2.unzip = unzip;
        lodash2.unzipWith = unzipWith;
        lodash2.update = update;
        lodash2.updateWith = updateWith;
        lodash2.values = values;
        lodash2.valuesIn = valuesIn;
        lodash2.without = without;
        lodash2.words = words;
        lodash2.wrap = wrap;
        lodash2.xor = xor;
        lodash2.xorBy = xorBy;
        lodash2.xorWith = xorWith;
        lodash2.zip = zip;
        lodash2.zipObject = zipObject;
        lodash2.zipObjectDeep = zipObjectDeep;
        lodash2.zipWith = zipWith;
        lodash2.entries = toPairs;
        lodash2.entriesIn = toPairsIn;
        lodash2.extend = assignIn;
        lodash2.extendWith = assignInWith;
        mixin(lodash2, lodash2);
        lodash2.add = add;
        lodash2.attempt = attempt;
        lodash2.camelCase = camelCase;
        lodash2.capitalize = capitalize;
        lodash2.ceil = ceil;
        lodash2.clamp = clamp;
        lodash2.clone = clone;
        lodash2.cloneDeep = cloneDeep;
        lodash2.cloneDeepWith = cloneDeepWith;
        lodash2.cloneWith = cloneWith;
        lodash2.conformsTo = conformsTo;
        lodash2.deburr = deburr;
        lodash2.defaultTo = defaultTo;
        lodash2.divide = divide;
        lodash2.endsWith = endsWith2;
        lodash2.eq = eq;
        lodash2.escape = escape;
        lodash2.escapeRegExp = escapeRegExp;
        lodash2.every = every;
        lodash2.find = find;
        lodash2.findIndex = findIndex;
        lodash2.findKey = findKey;
        lodash2.findLast = findLast;
        lodash2.findLastIndex = findLastIndex;
        lodash2.findLastKey = findLastKey;
        lodash2.floor = floor;
        lodash2.forEach = forEach2;
        lodash2.forEachRight = forEachRight;
        lodash2.forIn = forIn;
        lodash2.forInRight = forInRight;
        lodash2.forOwn = forOwn;
        lodash2.forOwnRight = forOwnRight;
        lodash2.get = get2;
        lodash2.gt = gt;
        lodash2.gte = gte;
        lodash2.has = has;
        lodash2.hasIn = hasIn;
        lodash2.head = head;
        lodash2.identity = identity;
        lodash2.includes = includes2;
        lodash2.indexOf = indexOf;
        lodash2.inRange = inRange;
        lodash2.invoke = invoke;
        lodash2.isArguments = isArguments2;
        lodash2.isArray = isArray;
        lodash2.isArrayBuffer = isArrayBuffer;
        lodash2.isArrayLike = isArrayLike;
        lodash2.isArrayLikeObject = isArrayLikeObject;
        lodash2.isBoolean = isBoolean;
        lodash2.isBuffer = isBuffer;
        lodash2.isDate = isDate;
        lodash2.isElement = isElement;
        lodash2.isEmpty = isEmpty;
        lodash2.isEqual = isEqual;
        lodash2.isEqualWith = isEqualWith;
        lodash2.isError = isError;
        lodash2.isFinite = isFinite2;
        lodash2.isFunction = isFunction;
        lodash2.isInteger = isInteger;
        lodash2.isLength = isLength;
        lodash2.isMap = isMap;
        lodash2.isMatch = isMatch;
        lodash2.isMatchWith = isMatchWith;
        lodash2.isNaN = isNaN2;
        lodash2.isNative = isNative;
        lodash2.isNil = isNil;
        lodash2.isNull = isNull;
        lodash2.isNumber = isNumber;
        lodash2.isObject = isObject;
        lodash2.isObjectLike = isObjectLike;
        lodash2.isPlainObject = isPlainObject;
        lodash2.isRegExp = isRegExp;
        lodash2.isSafeInteger = isSafeInteger;
        lodash2.isSet = isSet;
        lodash2.isString = isString;
        lodash2.isSymbol = isSymbol;
        lodash2.isTypedArray = isTypedArray2;
        lodash2.isUndefined = isUndefined;
        lodash2.isWeakMap = isWeakMap;
        lodash2.isWeakSet = isWeakSet;
        lodash2.join = join;
        lodash2.kebabCase = kebabCase;
        lodash2.last = last;
        lodash2.lastIndexOf = lastIndexOf;
        lodash2.lowerCase = lowerCase;
        lodash2.lowerFirst = lowerFirst;
        lodash2.lt = lt;
        lodash2.lte = lte;
        lodash2.max = max2;
        lodash2.maxBy = maxBy;
        lodash2.mean = mean;
        lodash2.meanBy = meanBy;
        lodash2.min = min;
        lodash2.minBy = minBy;
        lodash2.stubArray = stubArray;
        lodash2.stubFalse = stubFalse;
        lodash2.stubObject = stubObject;
        lodash2.stubString = stubString;
        lodash2.stubTrue = stubTrue;
        lodash2.multiply = multiply;
        lodash2.nth = nth;
        lodash2.noConflict = noConflict;
        lodash2.noop = noop2;
        lodash2.now = now;
        lodash2.pad = pad;
        lodash2.padEnd = padEnd;
        lodash2.padStart = padStart;
        lodash2.parseInt = parseInt2;
        lodash2.random = random2;
        lodash2.reduce = reduce;
        lodash2.reduceRight = reduceRight;
        lodash2.repeat = repeat;
        lodash2.replace = replace;
        lodash2.result = result;
        lodash2.round = round;
        lodash2.runInContext = runInContext2;
        lodash2.sample = sample;
        lodash2.size = size;
        lodash2.snakeCase = snakeCase;
        lodash2.some = some;
        lodash2.sortedIndex = sortedIndex;
        lodash2.sortedIndexBy = sortedIndexBy;
        lodash2.sortedIndexOf = sortedIndexOf;
        lodash2.sortedLastIndex = sortedLastIndex;
        lodash2.sortedLastIndexBy = sortedLastIndexBy;
        lodash2.sortedLastIndexOf = sortedLastIndexOf;
        lodash2.startCase = startCase;
        lodash2.startsWith = startsWith2;
        lodash2.subtract = subtract;
        lodash2.sum = sum;
        lodash2.sumBy = sumBy;
        lodash2.template = template;
        lodash2.times = times;
        lodash2.toFinite = toFinite;
        lodash2.toInteger = toInteger;
        lodash2.toLength = toLength;
        lodash2.toLower = toLower;
        lodash2.toNumber = toNumber;
        lodash2.toSafeInteger = toSafeInteger;
        lodash2.toString = toString;
        lodash2.toUpper = toUpper;
        lodash2.trim = trim;
        lodash2.trimEnd = trimEnd;
        lodash2.trimStart = trimStart;
        lodash2.truncate = truncate;
        lodash2.unescape = unescape;
        lodash2.uniqueId = uniqueId;
        lodash2.upperCase = upperCase;
        lodash2.upperFirst = upperFirst;
        lodash2.each = forEach2;
        lodash2.eachRight = forEachRight;
        lodash2.first = head;
        mixin(lodash2, function() {
          var source = {};
          baseForOwn(lodash2, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash2.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash2[methodName].placeholder = lodash2;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n2) {
            n2 = n2 === undefined$12 ? 1 : nativeMax(toInteger(n2), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n2) {
            return this.reverse()[methodName](n2).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type2 = index + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type2
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined$12) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash2.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$12 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash2.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash2[methodName];
          if (lodashFunc) {
            var key2 = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key2)) {
              realNames[key2] = [];
            }
            realNames[key2].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined$12, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined$12
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash2.prototype.at = wrapperAt;
        lodash2.prototype.chain = wrapperChain;
        lodash2.prototype.commit = wrapperCommit;
        lodash2.prototype.next = wrapperNext;
        lodash2.prototype.plant = wrapperPlant;
        lodash2.prototype.reverse = wrapperReverse;
        lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
        lodash2.prototype.first = lodash2.prototype.head;
        if (symIterator) {
          lodash2.prototype[symIterator] = wrapperToIterator;
        }
        return lodash2;
      };
      var _2 = runInContext();
      if (freeModule) {
        (freeModule.exports = _2)._ = _2;
        freeExports._ = _2;
      } else {
        root2._ = _2;
      }
    }).call(commonjsGlobal);
  })(lodash, lodash.exports);
  var lodashExports = lodash.exports;
  var spec;
  var hasRequiredSpec;
  function requireSpec() {
    if (hasRequiredSpec)
      return spec;
    hasRequiredSpec = 1;
    var docsURL = "http://bitcore.io/";
    spec = [{
      name: "InvalidB58Char",
      message: "Invalid Base58 character: {0} in {1}"
    }, {
      name: "InvalidB58Checksum",
      message: "Invalid Base58 checksum for {0}"
    }, {
      name: "InvalidNetwork",
      message: "Invalid version for network: got {0}"
    }, {
      name: "InvalidState",
      message: "Invalid state: {0}"
    }, {
      name: "NotImplemented",
      message: "Function {0} was not implemented yet"
    }, {
      name: "InvalidNetworkArgument",
      message: 'Invalid network: must be "livenet" or "testnet", got {0}'
    }, {
      name: "InvalidArgument",
      message: function() {
        return "Invalid Argument" + (arguments[0] ? ": " + arguments[0] : "") + (arguments[1] ? " Documentation: " + docsURL + arguments[1] : "");
      }
    }, {
      name: "AbstractMethodInvoked",
      message: "Abstract Method Invocation: {0}"
    }, {
      name: "InvalidArgumentType",
      message: function() {
        return "Invalid Argument for " + arguments[2] + ", expected " + arguments[1] + " but got " + typeof arguments[0];
      }
    }, {
      name: "Unit",
      message: "Internal Error on Unit {0}",
      errors: [{
        "name": "UnknownCode",
        "message": "Unrecognized unit code: {0}"
      }, {
        "name": "InvalidRate",
        "message": "Invalid exchange rate: {0}"
      }]
    }, {
      name: "MerkleBlock",
      message: "Internal Error on MerkleBlock {0}",
      errors: [{
        "name": "InvalidMerkleTree",
        "message": "This MerkleBlock contain an invalid Merkle Tree"
      }]
    }, {
      name: "Transaction",
      message: "Internal Error on Transaction {0}",
      errors: [{
        name: "Input",
        message: "Internal Error on Input {0}",
        errors: [
          {
            name: "MissingScript",
            message: "Need a script to create an input"
          },
          {
            name: "UnsupportedScript",
            message: "Unsupported input script type: {0}"
          },
          {
            name: "MissingPreviousOutput",
            message: "No previous output information."
          },
          {
            name: "BlockHeightOutOfRange",
            message: "Block Height can only be between 0 and 65535"
          },
          {
            name: "LockTimeRange",
            message: "Seconds needs to be more that 0 and less that 33553920"
          }
        ]
      }, {
        name: "NeedMoreInfo",
        message: "{0}"
      }, {
        name: "InvalidSorting",
        message: "The sorting function provided did not return the change output as one of the array elements"
      }, {
        name: "InvalidOutputAmountSum",
        message: "{0}"
      }, {
        name: "MissingSignatures",
        message: "Some inputs have not been fully signed"
      }, {
        name: "InvalidIndex",
        message: "Invalid index: {0} is not between 0, {1}"
      }, {
        name: "UnableToVerifySignature",
        message: "Unable to verify signature: {0}"
      }, {
        name: "DustOutputs",
        message: "Dust amount detected in one output"
      }, {
        name: "InvalidSatoshis",
        message: "Output satoshis are invalid"
      }, {
        name: "FeeError",
        message: "Internal Error on Fee {0}",
        errors: [{
          name: "TooSmall",
          message: "Fee is too small: {0}"
        }, {
          name: "TooLarge",
          message: "Fee is too large: {0}"
        }, {
          name: "Different",
          message: "Unspent value is different from specified fee: {0}"
        }]
      }, {
        name: "ChangeAddressMissing",
        message: "Change address is missing"
      }, {
        name: "BlockHeightTooHigh",
        message: "Block Height can be at most 2^32 -1"
      }, {
        name: "NLockTimeOutOfRange",
        message: "Block Height can only be between 0 and 499 999 999"
      }, {
        name: "LockTimeTooEarly",
        message: "Lock Time can't be earlier than UNIX date 500 000 000"
      }]
    }, {
      name: "Script",
      message: "Internal Error on Script {0}",
      errors: [{
        name: "UnrecognizedAddress",
        message: "Expected argument {0} to be an address"
      }, {
        name: "CantDeriveAddress",
        message: "Can't derive address associated with script {0}, needs to be p2pkh in, p2pkh out, p2sh in, or p2sh out."
      }, {
        name: "InvalidBuffer",
        message: "Invalid script buffer: can't parse valid script from given buffer {0}"
      }]
    }, {
      name: "HDPrivateKey",
      message: "Internal Error on HDPrivateKey {0}",
      errors: [{
        name: "InvalidDerivationArgument",
        message: "Invalid derivation argument {0}, expected string, or number and boolean"
      }, {
        name: "InvalidEntropyArgument",
        message: "Invalid entropy: must be an hexa string or binary buffer, got {0}",
        errors: [{
          name: "TooMuchEntropy",
          message: 'Invalid entropy: more than 512 bits is non standard, got "{0}"'
        }, {
          name: "NotEnoughEntropy",
          message: 'Invalid entropy: at least 128 bits needed, got "{0}"'
        }]
      }, {
        name: "InvalidLength",
        message: "Invalid length for xprivkey string in {0}"
      }, {
        name: "InvalidPath",
        message: "Invalid derivation path: {0}"
      }, {
        name: "UnrecognizedArgument",
        message: 'Invalid argument: creating a HDPrivateKey requires a string, buffer, json or object, got "{0}"'
      }]
    }, {
      name: "HDPublicKey",
      message: "Internal Error on HDPublicKey {0}",
      errors: [{
        name: "ArgumentIsPrivateExtended",
        message: "Argument is an extended private key: {0}"
      }, {
        name: "InvalidDerivationArgument",
        message: "Invalid derivation argument: got {0}"
      }, {
        name: "InvalidLength",
        message: 'Invalid length for xpubkey: got "{0}"'
      }, {
        name: "InvalidPath",
        message: 'Invalid derivation path, it should look like: "m/1/100", got "{0}"'
      }, {
        name: "InvalidIndexCantDeriveHardened",
        message: "Invalid argument: creating a hardened path requires an HDPrivateKey"
      }, {
        name: "MustSupplyArgument",
        message: "Must supply an argument to create a HDPublicKey"
      }, {
        name: "UnrecognizedArgument",
        message: "Invalid argument for creation, must be string, json, buffer, or object"
      }]
    }];
    return spec;
  }
  var _$f = lodashExports;
  function format(message2, args) {
    return message2.replace("{0}", args[0]).replace("{1}", args[1]).replace("{2}", args[2]);
  }
  var traverseNode = function(parent, errorDefinition) {
    var NodeError = function() {
      if (_$f.isString(errorDefinition.message)) {
        this.message = format(errorDefinition.message, arguments);
      } else if (_$f.isFunction(errorDefinition.message)) {
        this.message = errorDefinition.message.apply(null, arguments);
      } else {
        throw new Error("Invalid error definition for " + errorDefinition.name);
      }
      this.stack = this.message + "\n" + new Error().stack;
    };
    NodeError.prototype = Object.create(parent.prototype);
    NodeError.prototype.name = parent.prototype.name + errorDefinition.name;
    parent[errorDefinition.name] = NodeError;
    if (errorDefinition.errors) {
      childDefinitions(NodeError, errorDefinition.errors);
    }
    return NodeError;
  };
  var childDefinitions = function(parent, childDefinitions2) {
    _$f.each(childDefinitions2, function(childDefinition) {
      traverseNode(parent, childDefinition);
    });
  };
  var traverseRoot = function(parent, errorsDefinition) {
    childDefinitions(parent, errorsDefinition);
    return parent;
  };
  var bitcore = {};
  bitcore.Error = function() {
    this.message = "Internal error";
    this.stack = this.message + "\n" + new Error().stack;
  };
  bitcore.Error.prototype = Object.create(Error.prototype);
  bitcore.Error.prototype.name = "bitcore.Error";
  var data = requireSpec();
  traverseRoot(bitcore.Error, data);
  errors$5.exports = bitcore.Error;
  errors$5.exports.extend = function(spec2) {
    return traverseNode(bitcore.Error, spec2);
  };
  var errorsExports = errors$5.exports;
  var errors$4 = errorsExports;
  var _$e = lodashExports;
  var preconditions = {
    checkState: function(condition, message2) {
      if (!condition) {
        throw new errors$4.InvalidState(message2);
      }
    },
    checkArgument: function(condition, argumentName, message2, docsPath) {
      if (!condition) {
        throw new errors$4.InvalidArgument(argumentName, message2, docsPath);
      }
    },
    checkArgumentType: function(argument, type2, argumentName) {
      argumentName = argumentName || "(unknown name)";
      if (_$e.isString(type2)) {
        if (type2 === "Buffer") {
          var buffer2 = buffer$2;
          if (!buffer2.Buffer.isBuffer(argument)) {
            throw new errors$4.InvalidArgumentType(argument, type2, argumentName);
          }
        } else if (typeof argument !== type2) {
          throw new errors$4.InvalidArgumentType(argument, type2, argumentName);
        }
      } else {
        if (!(argument instanceof type2)) {
          throw new errors$4.InvalidArgumentType(argument, type2.name, argumentName);
        }
      }
    }
  };
  var BN$f = bnExports$2;
  var $$8 = preconditions;
  var _$d = lodashExports;
  var reversebuf = function(buf) {
    var buf2 = buffer$2.Buffer.alloc(buf.length);
    for (var i2 = 0; i2 < buf.length; i2++) {
      buf2[i2] = buf[buf.length - 1 - i2];
    }
    return buf2;
  };
  BN$f.Zero = new BN$f(0);
  BN$f.One = new BN$f(1);
  BN$f.Minus1 = new BN$f(-1);
  BN$f.fromNumber = function(n2) {
    $$8.checkArgument(_$d.isNumber(n2));
    return new BN$f(n2);
  };
  BN$f.fromString = function(str, base2) {
    $$8.checkArgument(_$d.isString(str));
    return new BN$f(str, base2);
  };
  BN$f.fromBuffer = function(buf, opts) {
    if (typeof opts !== "undefined" && opts.endian === "little") {
      buf = reversebuf(buf);
    }
    var hex = buf.toString("hex");
    var bn2 = new BN$f(hex, 16);
    return bn2;
  };
  BN$f.fromSM = function(buf, opts) {
    var ret;
    if (buf.length === 0) {
      return BN$f.fromBuffer(buffer$2.Buffer.from([0]));
    }
    var endian = "big";
    if (opts) {
      endian = opts.endian;
    }
    if (endian === "little") {
      buf = reversebuf(buf);
    }
    if (buf[0] & 128) {
      buf[0] = buf[0] & 127;
      ret = BN$f.fromBuffer(buf);
      ret.neg().copy(ret);
    } else {
      ret = BN$f.fromBuffer(buf);
    }
    return ret;
  };
  BN$f.prototype.toNumber = function() {
    return parseInt(this.toString(10), 10);
  };
  BN$f.prototype.toBuffer = function(opts) {
    var buf, hex;
    if (opts && opts.size) {
      hex = this.toString(16, 2);
      var natlen = hex.length / 2;
      buf = buffer$2.Buffer.from(hex, "hex");
      if (natlen === opts.size) {
        buf = buf;
      } else if (natlen > opts.size) {
        buf = BN$f.trim(buf, natlen);
      } else if (natlen < opts.size) {
        buf = BN$f.pad(buf, natlen, opts.size);
      }
    } else {
      hex = this.toString(16, 2);
      buf = buffer$2.Buffer.from(hex, "hex");
    }
    if (typeof opts !== "undefined" && opts.endian === "little") {
      buf = reversebuf(buf);
    }
    return buf;
  };
  BN$f.prototype.toSMBigEndian = function() {
    var buf;
    if (this.cmp(BN$f.Zero) === -1) {
      buf = this.neg().toBuffer();
      if (buf[0] & 128) {
        buf = buffer$2.Buffer.concat([buffer$2.Buffer.from([128]), buf]);
      } else {
        buf[0] = buf[0] | 128;
      }
    } else {
      buf = this.toBuffer();
      if (buf[0] & 128) {
        buf = buffer$2.Buffer.concat([buffer$2.Buffer.from([0]), buf]);
      }
    }
    if (buf.length === 1 & buf[0] === 0) {
      buf = buffer$2.Buffer.from([]);
    }
    return buf;
  };
  BN$f.prototype.toSM = function(opts) {
    var endian = opts ? opts.endian : "big";
    var buf = this.toSMBigEndian();
    if (endian === "little") {
      buf = reversebuf(buf);
    }
    return buf;
  };
  BN$f.fromScriptNumBuffer = function(buf, fRequireMinimal, size) {
    var nMaxNumSize = size || 4;
    $$8.checkArgument(buf.length <= nMaxNumSize, new Error("script number overflow"));
    if (fRequireMinimal && buf.length > 0) {
      if ((buf[buf.length - 1] & 127) === 0) {
        if (buf.length <= 1 || (buf[buf.length - 2] & 128) === 0) {
          throw new Error("non-minimally encoded script number");
        }
      }
    }
    return BN$f.fromSM(buf, {
      endian: "little"
    });
  };
  BN$f.prototype.toScriptNumBuffer = function() {
    return this.toSM({
      endian: "little"
    });
  };
  BN$f.trim = function(buf, natlen) {
    return buf.slice(natlen - buf.length, buf.length);
  };
  BN$f.pad = function(buf, natlen, size) {
    var rbuf = buffer$2.Buffer.alloc(size);
    for (var i2 = 0; i2 < buf.length; i2++) {
      rbuf[rbuf.length - 1 - i2] = buf[buf.length - 1 - i2];
    }
    for (i2 = 0; i2 < size - natlen; i2++) {
      rbuf[i2] = 0;
    }
    return rbuf;
  };
  var bn$2 = BN$f;
  var buffer$1 = { exports: {} };
  var assert$l = { exports: {} };
  var errors$3 = {};
  var util = {};
  var types$1 = {};
  var shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (sym in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  var hasSymbols$3 = shams$1;
  var shams = function hasToStringTagShams() {
    return hasSymbols$3() && !!Symbol.toStringTag;
  };
  var esErrors = Error;
  var _eval = EvalError;
  var range = RangeError;
  var ref = ReferenceError;
  var syntax = SyntaxError;
  var type = TypeError;
  var uri$1 = URIError;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = shams$1;
  var hasSymbols$2 = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  var test = {
    foo: {}
  };
  var $Object = Object;
  var hasProto$1 = function hasProto2() {
    return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
  };
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr$4 = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i2 = 0; i2 < a.length; i2 += 1) {
      arr[i2] = a[i2];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i2 = offset || 0, j = 0; i2 < arrLike.length; i2 += 1, j += 1) {
      arr[j] = arrLike[i2];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i2 = 0; i2 < arr.length; i2 += 1) {
      str += arr[i2];
      if (i2 + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  var implementation$7 = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr$4.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i2 = 0; i2 < boundLength; i2++) {
      boundArgs[i2] = "$" + i2;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  var implementation$6 = implementation$7;
  var functionBind = Function.prototype.bind || implementation$6;
  var call$1 = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind$1 = functionBind;
  var hasown = bind$1.call(call$1, $hasOwn);
  var undefined$1;
  var $Error = esErrors;
  var $EvalError = _eval;
  var $RangeError = range;
  var $ReferenceError = ref;
  var $SyntaxError$1 = syntax;
  var $TypeError$2 = type;
  var $URIError = uri$1;
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD$1 = Object.getOwnPropertyDescriptor;
  if ($gOPD$1) {
    try {
      $gOPD$1({}, "");
    } catch (e) {
      $gOPD$1 = null;
    }
  }
  var throwTypeError = function() {
    throw new $TypeError$2();
  };
  var ThrowTypeError = $gOPD$1 ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD$1(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols$1 = hasSymbols$2();
  var hasProto = hasProto$1();
  var getProto$1 = Object.getPrototypeOf || (hasProto ? function(x) {
    return x.__proto__;
  } : null);
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols$1 && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols$1 && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$1 || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$1 || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols$1 && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError$1,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError$2,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
  };
  if (getProto$1) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto$1(getProto$1(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name2) {
    var value;
    if (name2 === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name2 === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name2 === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name2 === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name2 === "%AsyncIteratorPrototype%") {
      var gen2 = doEval2("%AsyncGenerator%");
      if (gen2 && getProto$1) {
        value = getProto$1(gen2.prototype);
      }
    }
    INTRINSICS[name2] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = functionBind;
  var hasOwn = hasown;
  var $concat = bind.call(Function.call, Array.prototype.concat);
  var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
  var $replace = bind.call(Function.call, String.prototype.replace);
  var $strSlice = bind.call(Function.call, String.prototype.slice);
  var $exec = bind.call(Function.call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number2, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
    var intrinsicName = name2;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError$2("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError$1("intrinsic " + name2 + " does not exist!");
  };
  var getIntrinsic = function GetIntrinsic2(name2, allowMissing) {
    if (typeof name2 !== "string" || name2.length === 0) {
      throw new $TypeError$2("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError$2('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name2) === null) {
      throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name2);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
      var part = parts[i2];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError$1("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError$2("base intrinsic for " + name2 + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD$1 && i2 + 1 >= parts.length) {
          var desc = $gOPD$1(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  var callBind$2 = { exports: {} };
  var esDefineProperty;
  var hasRequiredEsDefineProperty;
  function requireEsDefineProperty() {
    if (hasRequiredEsDefineProperty)
      return esDefineProperty;
    hasRequiredEsDefineProperty = 1;
    var GetIntrinsic2 = getIntrinsic;
    var $defineProperty2 = GetIntrinsic2("%Object.defineProperty%", true) || false;
    if ($defineProperty2) {
      try {
        $defineProperty2({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty2 = false;
      }
    }
    esDefineProperty = $defineProperty2;
    return esDefineProperty;
  }
  var GetIntrinsic$2 = getIntrinsic;
  var $gOPD = GetIntrinsic$2("%Object.getOwnPropertyDescriptor%", true);
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  var gopd$1 = $gOPD;
  var $defineProperty$1 = requireEsDefineProperty();
  var $SyntaxError = syntax;
  var $TypeError$1 = type;
  var gopd = gopd$1;
  var defineDataProperty = function defineDataProperty2(obj, property, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError$1("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError$1("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError$1("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd && gopd(obj, property);
    if ($defineProperty$1) {
      $defineProperty$1(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
  var $defineProperty = requireEsDefineProperty();
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    return !!$defineProperty;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!$defineProperty) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  var hasPropertyDescriptors_1 = hasPropertyDescriptors;
  var GetIntrinsic$1 = getIntrinsic;
  var define = defineDataProperty;
  var hasDescriptors = hasPropertyDescriptors_1();
  var gOPD$1 = gopd$1;
  var $TypeError = type;
  var $floor = GetIntrinsic$1("%Math.floor%");
  var setFunctionLength = function setFunctionLength2(fn, length) {
    if (typeof fn !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
      throw new $TypeError("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn && gOPD$1) {
      var desc = gOPD$1(fn, "length");
      if (desc && !desc.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc && !desc.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length,
          true,
          true
        );
      } else {
        define(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length
        );
      }
    }
    return fn;
  };
  (function(module2) {
    var bind2 = functionBind;
    var GetIntrinsic2 = getIntrinsic;
    var setFunctionLength$1 = setFunctionLength;
    var $TypeError2 = type;
    var $apply = GetIntrinsic2("%Function.prototype.apply%");
    var $call = GetIntrinsic2("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic2("%Reflect.apply%", true) || bind2.call($call, $apply);
    var $defineProperty2 = requireEsDefineProperty();
    var $max = GetIntrinsic2("%Math.max%");
    module2.exports = function callBind2(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError2("a function is required");
      }
      var func = $reflectApply(bind2, $call, arguments);
      return setFunctionLength$1(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind2, $apply, arguments);
    };
    if ($defineProperty2) {
      $defineProperty2(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  })(callBind$2);
  var callBindExports = callBind$2.exports;
  var GetIntrinsic = getIntrinsic;
  var callBind$1 = callBindExports;
  var $indexOf$1 = callBind$1(GetIntrinsic("String.prototype.indexOf"));
  var callBound$3 = function callBoundIntrinsic(name2, allowMissing) {
    var intrinsic = GetIntrinsic(name2, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf$1(name2, ".prototype.") > -1) {
      return callBind$1(intrinsic);
    }
    return intrinsic;
  };
  var hasToStringTag$3 = shams();
  var callBound$2 = callBound$3;
  var $toString$1 = callBound$2("Object.prototype.toString");
  var isStandardArguments = function isArguments2(value) {
    if (hasToStringTag$3 && value && typeof value === "object" && Symbol.toStringTag in value) {
      return false;
    }
    return $toString$1(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments2(value) {
    if (isStandardArguments(value)) {
      return true;
    }
    return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString$1(value) !== "[object Array]" && $toString$1(value.callee) === "[object Function]";
  };
  var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
  }();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  var toStr$3 = Object.prototype.toString;
  var fnToStr$1 = Function.prototype.toString;
  var isFnRegex = /^\s*(?:function)?\*/;
  var hasToStringTag$2 = shams();
  var getProto = Object.getPrototypeOf;
  var getGeneratorFunc = function() {
    if (!hasToStringTag$2) {
      return false;
    }
    try {
      return Function("return function*() {}")();
    } catch (e) {
    }
  };
  var GeneratorFunction;
  var isGeneratorFunction = function isGeneratorFunction2(fn) {
    if (typeof fn !== "function") {
      return false;
    }
    if (isFnRegex.test(fnToStr$1.call(fn))) {
      return true;
    }
    if (!hasToStringTag$2) {
      var str = toStr$3.call(fn);
      return str === "[object GeneratorFunction]";
    }
    if (!getProto) {
      return false;
    }
    if (typeof GeneratorFunction === "undefined") {
      var generatorFunc = getGeneratorFunc();
      GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
    }
    return getProto(fn) === GeneratorFunction;
  };
  var fnToStr = Function.prototype.toString;
  var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
  var badArrayLike;
  var isCallableMarker;
  if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
    try {
      badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
          throw isCallableMarker;
        }
      });
      isCallableMarker = {};
      reflectApply(function() {
        throw 42;
      }, null, badArrayLike);
    } catch (_2) {
      if (_2 !== isCallableMarker) {
        reflectApply = null;
      }
    }
  } else {
    reflectApply = null;
  }
  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value) {
    try {
      var fnStr = fnToStr.call(value);
      return constructorRegex.test(fnStr);
    } catch (e) {
      return false;
    }
  };
  var tryFunctionObject = function tryFunctionToStr(value) {
    try {
      if (isES6ClassFn(value)) {
        return false;
      }
      fnToStr.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr$2 = Object.prototype.toString;
  var objectClass = "[object Object]";
  var fnClass = "[object Function]";
  var genClass = "[object GeneratorFunction]";
  var ddaClass = "[object HTMLAllCollection]";
  var ddaClass2 = "[object HTML document.all class]";
  var ddaClass3 = "[object HTMLCollection]";
  var hasToStringTag$1 = typeof Symbol === "function" && !!Symbol.toStringTag;
  var isIE68 = !(0 in [,]);
  var isDDA = function isDocumentDotAll() {
    return false;
  };
  if (typeof document === "object") {
    var all = document.all;
    if (toStr$2.call(all) === toStr$2.call(document.all)) {
      isDDA = function isDocumentDotAll(value) {
        if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
          try {
            var str = toStr$2.call(value);
            return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
          } catch (e) {
          }
        }
        return false;
      };
    }
  }
  var isCallable$1 = reflectApply ? function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    try {
      reflectApply(value, null, badArrayLike);
    } catch (e) {
      if (e !== isCallableMarker) {
        return false;
      }
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
  } : function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (hasToStringTag$1) {
      return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
      return false;
    }
    var strClass = toStr$2.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
      return false;
    }
    return tryFunctionObject(value);
  };
  var isCallable = isCallable$1;
  var toStr$1 = Object.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var forEachArray = function forEachArray2(array, iterator, receiver) {
    for (var i2 = 0, len2 = array.length; i2 < len2; i2++) {
      if (hasOwnProperty.call(array, i2)) {
        if (receiver == null) {
          iterator(array[i2], i2, array);
        } else {
          iterator.call(receiver, array[i2], i2, array);
        }
      }
    }
  };
  var forEachString = function forEachString2(string, iterator, receiver) {
    for (var i2 = 0, len2 = string.length; i2 < len2; i2++) {
      if (receiver == null) {
        iterator(string.charAt(i2), i2, string);
      } else {
        iterator.call(receiver, string.charAt(i2), i2, string);
      }
    }
  };
  var forEachObject = function forEachObject2(object2, iterator, receiver) {
    for (var k2 in object2) {
      if (hasOwnProperty.call(object2, k2)) {
        if (receiver == null) {
          iterator(object2[k2], k2, object2);
        } else {
          iterator.call(receiver, object2[k2], k2, object2);
        }
      }
    }
  };
  var forEach$1 = function forEach2(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
      throw new TypeError("iterator must be a function");
    }
    var receiver;
    if (arguments.length >= 3) {
      receiver = thisArg;
    }
    if (toStr$1.call(list) === "[object Array]") {
      forEachArray(list, iterator, receiver);
    } else if (typeof list === "string") {
      forEachString(list, iterator, receiver);
    } else {
      forEachObject(list, iterator, receiver);
    }
  };
  var forEach_1 = forEach$1;
  var possibleNames = [
    "BigInt64Array",
    "BigUint64Array",
    "Float32Array",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray"
  ];
  var g$1 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var availableTypedArrays$1 = function availableTypedArrays2() {
    var out = [];
    for (var i2 = 0; i2 < possibleNames.length; i2++) {
      if (typeof g$1[possibleNames[i2]] === "function") {
        out[out.length] = possibleNames[i2];
      }
    }
    return out;
  };
  var forEach = forEach_1;
  var availableTypedArrays = availableTypedArrays$1;
  var callBind = callBindExports;
  var callBound$1 = callBound$3;
  var gOPD = gopd$1;
  var $toString = callBound$1("Object.prototype.toString");
  var hasToStringTag = shams();
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var typedArrays = availableTypedArrays();
  var $slice = callBound$1("String.prototype.slice");
  var getPrototypeOf = Object.getPrototypeOf;
  var $indexOf = callBound$1("Array.prototype.indexOf", true) || /** @type {(array: readonly unknown[], value: unknown) => keyof array} */
  function indexOf(array, value) {
    for (var i2 = 0; i2 < array.length; i2 += 1) {
      if (array[i2] === value) {
        return i2;
      }
    }
    return -1;
  };
  var cache = { __proto__: null };
  if (hasToStringTag && gOPD && getPrototypeOf) {
    forEach(typedArrays, function(typedArray) {
      var arr = new g[typedArray]();
      if (Symbol.toStringTag in arr) {
        var proto2 = getPrototypeOf(arr);
        var descriptor = gOPD(proto2, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf(proto2);
          descriptor = gOPD(superProto, Symbol.toStringTag);
        }
        cache["$" + typedArray] = callBind(descriptor.get);
      }
    });
  } else {
    forEach(typedArrays, function(typedArray) {
      var arr = new g[typedArray]();
      var fn = arr.slice || arr.set;
      if (fn) {
        cache["$" + typedArray] = callBind(fn);
      }
    });
  }
  var tryTypedArrays = function tryAllTypedArrays(value) {
    var found = false;
    forEach(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, typeof cache>} */
      /** @type {any} */
      cache,
      /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
      function(getter, typedArray) {
        if (!found) {
          try {
            if ("$" + getter(value) === typedArray) {
              found = $slice(typedArray, 1);
            }
          } catch (e) {
          }
        }
      }
    );
    return found;
  };
  var trySlices = function tryAllSlices(value) {
    var found = false;
    forEach(
      // eslint-disable-next-line no-extra-parens
      /** @type {any} */
      cache,
      /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
      function(getter, name2) {
        if (!found) {
          try {
            getter(value);
            found = $slice(name2, 1);
          } catch (e) {
          }
        }
      }
    );
    return found;
  };
  var whichTypedArray$1 = function whichTypedArray2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    if (!hasToStringTag) {
      var tag = $slice($toString(value), 8, -1);
      if ($indexOf(typedArrays, tag) > -1) {
        return tag;
      }
      if (tag !== "Object") {
        return false;
      }
      return trySlices(value);
    }
    if (!gOPD) {
      return null;
    }
    return tryTypedArrays(value);
  };
  var whichTypedArray = whichTypedArray$1;
  var isTypedArray = function isTypedArray2(value) {
    return !!whichTypedArray(value);
  };
  (function(exports2) {
    var isArgumentsObject = isArguments$1;
    var isGeneratorFunction$1 = isGeneratorFunction;
    var whichTypedArray2 = whichTypedArray$1;
    var isTypedArray$1 = isTypedArray;
    function uncurryThis(f2) {
      return f2.call.bind(f2);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.isArgumentsObject = isArgumentsObject;
    exports2.isGeneratorFunction = isGeneratorFunction$1;
    exports2.isTypedArray = isTypedArray$1;
    function isPromise(input2) {
      return typeof Promise !== "undefined" && input2 instanceof Promise || input2 !== null && typeof input2 === "object" && typeof input2.then === "function" && typeof input2.catch === "function";
    }
    exports2.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray$1(value) || isDataView(value);
    }
    exports2.isArrayBufferView = isArrayBufferView;
    function isUint8Array2(value) {
      return whichTypedArray2(value) === "Uint8Array";
    }
    exports2.isUint8Array = isUint8Array2;
    function isUint8ClampedArray(value) {
      return whichTypedArray2(value) === "Uint8ClampedArray";
    }
    exports2.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray2(value) === "Uint16Array";
    }
    exports2.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray2(value) === "Uint32Array";
    }
    exports2.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray2(value) === "Int8Array";
    }
    exports2.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray2(value) === "Int16Array";
    }
    exports2.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray2(value) === "Int32Array";
    }
    exports2.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray2(value) === "Float32Array";
    }
    exports2.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray2(value) === "Float64Array";
    }
    exports2.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray2(value) === "BigInt64Array";
    }
    exports2.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray2(value) === "BigUint64Array";
    }
    exports2.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports2.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports2.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports2.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports2.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports2.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports2.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports2.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports2.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports2.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports2.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports2.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports2.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports2.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports2.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports2.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports2.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports2.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports2.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method2) {
      Object.defineProperty(exports2, method2, {
        enumerable: false,
        value: function() {
          throw new Error(method2 + " is not supported in userland");
        }
      });
    });
  })(types$1);
  var isBufferBrowser = function isBuffer(arg) {
    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
  };
  var inherits_browser$1 = { exports: {} };
  if (typeof Object.create === "function") {
    inherits_browser$1.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser$1.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  var inherits_browserExports$1 = inherits_browser$1.exports;
  (function(exports2) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i2 = 0; i2 < keys.length; i2++) {
        descriptors[keys[i2]] = Object.getOwnPropertyDescriptor(obj, keys[i2]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports2.format = function(f2) {
      if (!isString(f2)) {
        var objects = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          objects.push(inspect(arguments[i2]));
        }
        return objects.join(" ");
      }
      var i2 = 1;
      var args = arguments;
      var len2 = args.length;
      var str = String(f2).replace(formatRegExp, function(x2) {
        if (x2 === "%%")
          return "%";
        if (i2 >= len2)
          return x2;
        switch (x2) {
          case "%s":
            return String(args[i2++]);
          case "%d":
            return Number(args[i2++]);
          case "%j":
            try {
              return JSON.stringify(args[i2++]);
            } catch (_2) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i2]; i2 < len2; x = args[++i2]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports2.deprecate = function(fn, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports2.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process.env.NODE_DEBUG) {
      var debugEnv = process.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    exports2.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports2.format.apply(exports2, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports2._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports2.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash2 = {};
      array.forEach(function(val, idx) {
        hash2[val] = true;
      });
      return hash2;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name2 = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name2 + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base2 = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n2 = value.name ? ": " + value.name : "";
        base2 = " [Function" + n2 + "]";
      }
      if (isRegExp(value)) {
        base2 = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base2 = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base2 = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base2 + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output2;
      if (array) {
        output2 = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output2 = keys.map(function(key2) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output2, base2, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output2 = [];
      for (var i2 = 0, l = value.length; i2 < l; ++i2) {
        if (hasOwnProperty2(value, String(i2))) {
          output2.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i2),
            true
          ));
        } else {
          output2.push("");
        }
      }
      keys.forEach(function(key2) {
        if (!key2.match(/^\d+$/)) {
          output2.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key2,
            true
          ));
        }
      });
      return output2;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array) {
      var name2, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key2) || { value: value[key2] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty2(visibleKeys, key2)) {
        name2 = "[" + key2 + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name2)) {
        if (array && key2.match(/^\d+$/)) {
          return str;
        }
        name2 = JSON.stringify("" + key2);
        if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name2 = name2.slice(1, -1);
          name2 = ctx.stylize(name2, "name");
        } else {
          name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name2 = ctx.stylize(name2, "string");
        }
      }
      return name2 + ": " + str;
    }
    function reduceToSingleString(output2, base2, braces) {
      var length = output2.reduce(function(prev, cur) {
        if (cur.indexOf("\n") >= 0)
          ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output2.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base2 + " " + output2.join(", ") + " " + braces[1];
    }
    exports2.types = types$1;
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    exports2.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    exports2.types.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports2.isError = isError;
    exports2.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = isBufferBrowser;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n2) {
      return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports2.log = function() {
      console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
    };
    exports2.inherits = inherits_browserExports$1;
    exports2._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys = Object.keys(add);
      var i2 = keys.length;
      while (i2--) {
        origin[keys[i2]] = add[keys[i2]];
      }
      return origin;
    };
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports2.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          args.push(arguments[i2]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports2.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          args.push(arguments[i2]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports2.callbackify = callbackify;
  })(util);
  var hasRequiredErrors;
  function requireErrors() {
    if (hasRequiredErrors)
      return errors$3;
    hasRequiredErrors = 1;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key2 = _toPrimitive(arg, "string");
      return _typeof(key2) === "symbol" ? key2 : String(key2);
    }
    function _toPrimitive(input2, hint) {
      if (_typeof(input2) !== "object" || input2 === null)
        return input2;
      var prim = input2[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input2, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input2);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
        o2.__proto__ = p3;
        return o2;
      };
      return _setPrototypeOf(o, p2);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call2) {
      if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
        return call2;
      } else if (call2 !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var codes2 = {};
    var assert2;
    var util$1;
    function createErrorType2(code2, message2, Base2) {
      if (!Base2) {
        Base2 = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message2 === "string") {
          return message2;
        } else {
          return message2(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inherits(NodeError2, _Base);
        var _super = _createSuper(NodeError2);
        function NodeError2(arg1, arg2, arg3) {
          var _this;
          _classCallCheck(this, NodeError2);
          _this = _super.call(this, getMessage(arg1, arg2, arg3));
          _this.code = code2;
          return _this;
        }
        return _createClass(NodeError2);
      }(Base2);
      codes2[code2] = NodeError;
    }
    function oneOf2(expected, thing) {
      if (Array.isArray(expected)) {
        var len2 = expected.length;
        expected = expected.map(function(i2) {
          return String(i2);
        });
        if (len2 > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len2 - 1).join(", "), ", or ") + expected[len2 - 1];
        } else if (len2 === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith2(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith2(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes2(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType2("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
    createErrorType2("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
      if (assert2 === void 0)
        assert2 = requireAssert();
      assert2(typeof name2 === "string", "'name' must be a string");
      var determiner;
      if (typeof expected === "string" && startsWith2(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith2(name2, " argument")) {
        msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf2(expected, "type"));
      } else {
        var type2 = includes2(name2, ".") ? "property" : "argument";
        msg = 'The "'.concat(name2, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf2(expected, "type"));
      }
      msg += ". Received type ".concat(_typeof(actual));
      return msg;
    }, TypeError);
    createErrorType2("ERR_INVALID_ARG_VALUE", function(name2, value) {
      var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
      if (util$1 === void 0)
        util$1 = util;
      var inspected = util$1.inspect(value);
      if (inspected.length > 128) {
        inspected = "".concat(inspected.slice(0, 128), "...");
      }
      return "The argument '".concat(name2, "' ").concat(reason, ". Received ").concat(inspected);
    }, TypeError);
    createErrorType2("ERR_INVALID_RETURN_VALUE", function(input2, name2, value) {
      var type2;
      if (value && value.constructor && value.constructor.name) {
        type2 = "instance of ".concat(value.constructor.name);
      } else {
        type2 = "type ".concat(_typeof(value));
      }
      return "Expected ".concat(input2, ' to be returned from the "').concat(name2, '"') + " function but got ".concat(type2, ".");
    }, TypeError);
    createErrorType2("ERR_MISSING_ARGS", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (assert2 === void 0)
        assert2 = requireAssert();
      assert2(args.length > 0, "At least one arg needs to be specified");
      var msg = "The ";
      var len2 = args.length;
      args = args.map(function(a) {
        return '"'.concat(a, '"');
      });
      switch (len2) {
        case 1:
          msg += "".concat(args[0], " argument");
          break;
        case 2:
          msg += "".concat(args[0], " and ").concat(args[1], " arguments");
          break;
        default:
          msg += args.slice(0, len2 - 1).join(", ");
          msg += ", and ".concat(args[len2 - 1], " arguments");
          break;
      }
      return "".concat(msg, " must be specified");
    }, TypeError);
    errors$3.codes = codes2;
    return errors$3;
  }
  var assertion_error;
  var hasRequiredAssertion_error;
  function requireAssertion_error() {
    if (hasRequiredAssertion_error)
      return assertion_error;
    hasRequiredAssertion_error = 1;
    function ownKeys(e, r2) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys(Object(t), true).forEach(function(r3) {
          _defineProperty(e, r3, t[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
        });
      }
      return e;
    }
    function _defineProperty(obj, key2, value) {
      key2 = _toPropertyKey(key2);
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key2 = _toPrimitive(arg, "string");
      return _typeof(key2) === "symbol" ? key2 : String(key2);
    }
    function _toPrimitive(input2, hint) {
      if (_typeof(input2) !== "object" || input2 === null)
        return input2;
      var prim = input2[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input2, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input2);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call2) {
      if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
        return call2;
      } else if (call2 !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _setPrototypeOf(o, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
        o2.__proto__ = p3;
        return o2;
      };
      return _setPrototypeOf(o, p2);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    var _require = util, inspect = _require.inspect;
    var _require2 = requireErrors(), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
    function endsWith2(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function repeat(str, count) {
      count = Math.floor(count);
      if (str.length == 0 || count == 0)
        return "";
      var maxCount = str.length * count;
      count = Math.floor(Math.log(count) / Math.log(2));
      while (count) {
        str += str;
        count--;
      }
      str += str.substring(0, maxCount - str.length);
      return str;
    }
    var blue = "";
    var green = "";
    var red = "";
    var white = "";
    var kReadableOperator = {
      deepStrictEqual: "Expected values to be strictly deep-equal:",
      strictEqual: "Expected values to be strictly equal:",
      strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
      deepEqual: "Expected values to be loosely deep-equal:",
      equal: "Expected values to be loosely equal:",
      notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
      notStrictEqual: 'Expected "actual" to be strictly unequal to:',
      notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
      notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
      notEqual: 'Expected "actual" to be loosely unequal to:',
      notIdentical: "Values identical but not reference-equal:"
    };
    var kMaxShortLength = 10;
    function copyError(source) {
      var keys = Object.keys(source);
      var target = Object.create(Object.getPrototypeOf(source));
      keys.forEach(function(key2) {
        target[key2] = source[key2];
      });
      Object.defineProperty(target, "message", {
        value: source.message
      });
      return target;
    }
    function inspectValue(val) {
      return inspect(val, {
        compact: false,
        customInspect: false,
        depth: 1e3,
        maxArrayLength: Infinity,
        // Assert compares only enumerable properties (with a few exceptions).
        showHidden: false,
        // Having a long line as error is better than wrapping the line for
        // comparison for now.
        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
        // have meta information about the inspected properties (i.e., know where
        // in what line the property starts and ends).
        breakLength: Infinity,
        // Assert does not detect proxies currently.
        showProxy: false,
        sorted: true,
        // Inspect getters as we also check them when comparing entries.
        getters: true
      });
    }
    function createErrDiff(actual, expected, operator) {
      var other = "";
      var res = "";
      var lastPos = 0;
      var end = "";
      var skipped = false;
      var actualInspected = inspectValue(actual);
      var actualLines = actualInspected.split("\n");
      var expectedLines = inspectValue(expected).split("\n");
      var i2 = 0;
      var indicator = "";
      if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) {
        operator = "strictEqualObject";
      }
      if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
        var inputLength = actualLines[0].length + expectedLines[0].length;
        if (inputLength <= kMaxShortLength) {
          if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
            return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
          }
        } else if (operator !== "strictEqualObject") {
          var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
          if (inputLength < maxLength) {
            while (actualLines[0][i2] === expectedLines[0][i2]) {
              i2++;
            }
            if (i2 > 2) {
              indicator = "\n  ".concat(repeat(" ", i2), "^");
              i2 = 0;
            }
          }
        }
      }
      var a = actualLines[actualLines.length - 1];
      var b = expectedLines[expectedLines.length - 1];
      while (a === b) {
        if (i2++ < 2) {
          end = "\n  ".concat(a).concat(end);
        } else {
          other = a;
        }
        actualLines.pop();
        expectedLines.pop();
        if (actualLines.length === 0 || expectedLines.length === 0)
          break;
        a = actualLines[actualLines.length - 1];
        b = expectedLines[expectedLines.length - 1];
      }
      var maxLines = Math.max(actualLines.length, expectedLines.length);
      if (maxLines === 0) {
        var _actualLines = actualInspected.split("\n");
        if (_actualLines.length > 30) {
          _actualLines[26] = "".concat(blue, "...").concat(white);
          while (_actualLines.length > 27) {
            _actualLines.pop();
          }
        }
        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
      }
      if (i2 > 3) {
        end = "\n".concat(blue, "...").concat(white).concat(end);
        skipped = true;
      }
      if (other !== "") {
        end = "\n  ".concat(other).concat(end);
        other = "";
      }
      var printedLines = 0;
      var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
      var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
      for (i2 = 0; i2 < maxLines; i2++) {
        var cur = i2 - lastPos;
        if (actualLines.length < i2 + 1) {
          if (cur > 1 && i2 > 2) {
            if (cur > 4) {
              res += "\n".concat(blue, "...").concat(white);
              skipped = true;
            } else if (cur > 3) {
              res += "\n  ".concat(expectedLines[i2 - 2]);
              printedLines++;
            }
            res += "\n  ".concat(expectedLines[i2 - 1]);
            printedLines++;
          }
          lastPos = i2;
          other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i2]);
          printedLines++;
        } else if (expectedLines.length < i2 + 1) {
          if (cur > 1 && i2 > 2) {
            if (cur > 4) {
              res += "\n".concat(blue, "...").concat(white);
              skipped = true;
            } else if (cur > 3) {
              res += "\n  ".concat(actualLines[i2 - 2]);
              printedLines++;
            }
            res += "\n  ".concat(actualLines[i2 - 1]);
            printedLines++;
          }
          lastPos = i2;
          res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i2]);
          printedLines++;
        } else {
          var expectedLine = expectedLines[i2];
          var actualLine = actualLines[i2];
          var divergingLines = actualLine !== expectedLine && (!endsWith2(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
          if (divergingLines && endsWith2(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
            divergingLines = false;
            actualLine += ",";
          }
          if (divergingLines) {
            if (cur > 1 && i2 > 2) {
              if (cur > 4) {
                res += "\n".concat(blue, "...").concat(white);
                skipped = true;
              } else if (cur > 3) {
                res += "\n  ".concat(actualLines[i2 - 2]);
                printedLines++;
              }
              res += "\n  ".concat(actualLines[i2 - 1]);
              printedLines++;
            }
            lastPos = i2;
            res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
            printedLines += 2;
          } else {
            res += other;
            other = "";
            if (cur === 1 || i2 === 0) {
              res += "\n  ".concat(actualLine);
              printedLines++;
            }
          }
        }
        if (printedLines > 20 && i2 < maxLines - 2) {
          return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
        }
      }
      return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
    }
    var AssertionError = /* @__PURE__ */ function(_Error, _inspect$custom) {
      _inherits(AssertionError2, _Error);
      var _super = _createSuper(AssertionError2);
      function AssertionError2(options) {
        var _this;
        _classCallCheck(this, AssertionError2);
        if (_typeof(options) !== "object" || options === null) {
          throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        var message2 = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
        var actual = options.actual, expected = options.expected;
        var limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        if (message2 != null) {
          _this = _super.call(this, String(message2));
        } else {
          if (process.stderr && process.stderr.isTTY) {
            if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
              blue = "\x1B[34m";
              green = "\x1B[32m";
              white = "\x1B[39m";
              red = "\x1B[31m";
            } else {
              blue = "";
              green = "";
              white = "";
              red = "";
            }
          }
          if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
            actual = copyError(actual);
            expected = copyError(expected);
          }
          if (operator === "deepStrictEqual" || operator === "strictEqual") {
            _this = _super.call(this, createErrDiff(actual, expected, operator));
          } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
            var base2 = kReadableOperator[operator];
            var res = inspectValue(actual).split("\n");
            if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) {
              base2 = kReadableOperator.notStrictEqualObject;
            }
            if (res.length > 30) {
              res[26] = "".concat(blue, "...").concat(white);
              while (res.length > 27) {
                res.pop();
              }
            }
            if (res.length === 1) {
              _this = _super.call(this, "".concat(base2, " ").concat(res[0]));
            } else {
              _this = _super.call(this, "".concat(base2, "\n\n").concat(res.join("\n"), "\n"));
            }
          } else {
            var _res = inspectValue(actual);
            var other = "";
            var knownOperators = kReadableOperator[operator];
            if (operator === "notDeepEqual" || operator === "notEqual") {
              _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
              if (_res.length > 1024) {
                _res = "".concat(_res.slice(0, 1021), "...");
              }
            } else {
              other = "".concat(inspectValue(expected));
              if (_res.length > 512) {
                _res = "".concat(_res.slice(0, 509), "...");
              }
              if (other.length > 512) {
                other = "".concat(other.slice(0, 509), "...");
              }
              if (operator === "deepEqual" || operator === "equal") {
                _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
              } else {
                other = " ".concat(operator, " ").concat(other);
              }
            }
            _this = _super.call(this, "".concat(_res).concat(other));
          }
        }
        Error.stackTraceLimit = limit;
        _this.generatedMessage = !message2;
        Object.defineProperty(_assertThisInitialized(_this), "name", {
          value: "AssertionError [ERR_ASSERTION]",
          enumerable: false,
          writable: true,
          configurable: true
        });
        _this.code = "ERR_ASSERTION";
        _this.actual = actual;
        _this.expected = expected;
        _this.operator = operator;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
        }
        _this.stack;
        _this.name = "AssertionError";
        return _possibleConstructorReturn(_this);
      }
      _createClass(AssertionError2, [{
        key: "toString",
        value: function toString() {
          return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
        }
      }, {
        key: _inspect$custom,
        value: function value(recurseTimes, ctx) {
          return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
            customInspect: false,
            depth: 0
          }));
        }
      }]);
      return AssertionError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error), inspect.custom);
    assertion_error = AssertionError;
    return assertion_error;
  }
  var toStr = Object.prototype.toString;
  var isArguments = function isArguments2(value) {
    var str = toStr.call(value);
    var isArgs2 = str === "[object Arguments]";
    if (!isArgs2) {
      isArgs2 = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
    }
    return isArgs2;
  };
  var implementation$5;
  var hasRequiredImplementation$1;
  function requireImplementation$1() {
    if (hasRequiredImplementation$1)
      return implementation$5;
    hasRequiredImplementation$1 = 1;
    var keysShim2;
    if (!Object.keys) {
      var has = Object.prototype.hasOwnProperty;
      var toStr2 = Object.prototype.toString;
      var isArgs2 = isArguments;
      var isEnumerable = Object.prototype.propertyIsEnumerable;
      var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      var hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      var dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      var equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      var excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      var hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k2 in window) {
          try {
            if (!excludedKeys["$" + k2] && has.call(window, k2) && window[k2] !== null && typeof window[k2] === "object") {
              try {
                equalsConstructorPrototype(window[k2]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      var equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim2 = function keys(object2) {
        var isObject = object2 !== null && typeof object2 === "object";
        var isFunction = toStr2.call(object2) === "[object Function]";
        var isArguments2 = isArgs2(object2);
        var isString = isObject && toStr2.call(object2) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments2) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object2.length > 0 && !has.call(object2, 0)) {
          for (var i2 = 0; i2 < object2.length; ++i2) {
            theKeys.push(String(i2));
          }
        }
        if (isArguments2 && object2.length > 0) {
          for (var j = 0; j < object2.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name2 in object2) {
            if (!(skipProto && name2 === "prototype") && has.call(object2, name2)) {
              theKeys.push(String(name2));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object2);
          for (var k2 = 0; k2 < dontEnums.length; ++k2) {
            if (!(skipConstructor && dontEnums[k2] === "constructor") && has.call(object2, dontEnums[k2])) {
              theKeys.push(dontEnums[k2]);
            }
          }
        }
        return theKeys;
      };
    }
    implementation$5 = keysShim2;
    return implementation$5;
  }
  var slice = Array.prototype.slice;
  var isArgs = isArguments;
  var origKeys = Object.keys;
  var keysShim = origKeys ? function keys(o) {
    return origKeys(o);
  } : requireImplementation$1();
  var originalKeys = Object.keys;
  keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
      var keysWorksWithArguments = function() {
        var args = Object.keys(arguments);
        return args && args.length === arguments.length;
      }(1, 2);
      if (!keysWorksWithArguments) {
        Object.keys = function keys(object2) {
          if (isArgs(object2)) {
            return originalKeys(slice.call(object2));
          }
          return originalKeys(object2);
        };
      }
    } else {
      Object.keys = keysShim;
    }
    return Object.keys || keysShim;
  };
  var objectKeys$1 = keysShim;
  var objectKeys = objectKeys$1;
  var hasSymbols = shams$1();
  var callBound = callBound$3;
  var toObject = Object;
  var $push = callBound("Array.prototype.push");
  var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
  var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;
  var implementation$4 = function assign(target, source1) {
    if (target == null) {
      throw new TypeError("target must be an object");
    }
    var to = toObject(target);
    if (arguments.length === 1) {
      return to;
    }
    for (var s2 = 1; s2 < arguments.length; ++s2) {
      var from = toObject(arguments[s2]);
      var keys = objectKeys(from);
      var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
      if (getSymbols) {
        var syms = getSymbols(from);
        for (var j = 0; j < syms.length; ++j) {
          var key2 = syms[j];
          if ($propIsEnumerable(from, key2)) {
            $push(keys, key2);
          }
        }
      }
      for (var i2 = 0; i2 < keys.length; ++i2) {
        var nextKey = keys[i2];
        if ($propIsEnumerable(from, nextKey)) {
          var propValue = from[nextKey];
          to[nextKey] = propValue;
        }
      }
    }
    return to;
  };
  var implementation$3 = implementation$4;
  var lacksProperEnumerationOrder = function() {
    if (!Object.assign) {
      return false;
    }
    var str = "abcdefghijklmnopqrst";
    var letters = str.split("");
    var map = {};
    for (var i2 = 0; i2 < letters.length; ++i2) {
      map[letters[i2]] = letters[i2];
    }
    var obj = Object.assign({}, map);
    var actual = "";
    for (var k2 in obj) {
      actual += k2;
    }
    return str !== actual;
  };
  var assignHasPendingExceptions = function() {
    if (!Object.assign || !Object.preventExtensions) {
      return false;
    }
    var thrower = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(thrower, "xy");
    } catch (e) {
      return thrower[1] === "y";
    }
    return false;
  };
  var polyfill$2 = function getPolyfill() {
    if (!Object.assign) {
      return implementation$3;
    }
    if (lacksProperEnumerationOrder()) {
      return implementation$3;
    }
    if (assignHasPendingExceptions()) {
      return implementation$3;
    }
    return Object.assign;
  };
  var numberIsNaN = function(value) {
    return value !== value;
  };
  var implementation$2 = function is(a, b) {
    if (a === 0 && b === 0) {
      return 1 / a === 1 / b;
    }
    if (a === b) {
      return true;
    }
    if (numberIsNaN(a) && numberIsNaN(b)) {
      return true;
    }
    return false;
  };
  var implementation$1 = implementation$2;
  var polyfill$1 = function getPolyfill() {
    return typeof Object.is === "function" ? Object.is : implementation$1;
  };
  var defineProperties_1;
  var hasRequiredDefineProperties;
  function requireDefineProperties() {
    if (hasRequiredDefineProperties)
      return defineProperties_1;
    hasRequiredDefineProperties = 1;
    var keys = objectKeys$1;
    var hasSymbols2 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr2 = Object.prototype.toString;
    var concat2 = Array.prototype.concat;
    var defineDataProperty$1 = defineDataProperty;
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr2.call(fn) === "[object Function]";
    };
    var supportsDescriptors = hasPropertyDescriptors_1();
    var defineProperty = function(object2, name2, value, predicate) {
      if (name2 in object2) {
        if (predicate === true) {
          if (object2[name2] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty$1(object2, name2, value, true);
      } else {
        defineDataProperty$1(object2, name2, value);
      }
    };
    var defineProperties2 = function(object2, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols2) {
        props = concat2.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i2 = 0; i2 < props.length; i2 += 1) {
        defineProperty(object2, props[i2], map[props[i2]], predicates[props[i2]]);
      }
    };
    defineProperties2.supportsDescriptors = !!supportsDescriptors;
    defineProperties_1 = defineProperties2;
    return defineProperties_1;
  }
  var shim$1;
  var hasRequiredShim$1;
  function requireShim$1() {
    if (hasRequiredShim$1)
      return shim$1;
    hasRequiredShim$1 = 1;
    var getPolyfill = polyfill$1;
    var define2 = requireDefineProperties();
    shim$1 = function shimObjectIs() {
      var polyfill2 = getPolyfill();
      define2(Object, { is: polyfill2 }, {
        is: function testObjectIs() {
          return Object.is !== polyfill2;
        }
      });
      return polyfill2;
    };
    return shim$1;
  }
  var objectIs;
  var hasRequiredObjectIs;
  function requireObjectIs() {
    if (hasRequiredObjectIs)
      return objectIs;
    hasRequiredObjectIs = 1;
    var define2 = requireDefineProperties();
    var callBind2 = callBindExports;
    var implementation2 = implementation$2;
    var getPolyfill = polyfill$1;
    var shim2 = requireShim$1();
    var polyfill2 = callBind2(getPolyfill(), Object);
    define2(polyfill2, {
      getPolyfill,
      implementation: implementation2,
      shim: shim2
    });
    objectIs = polyfill2;
    return objectIs;
  }
  var implementation;
  var hasRequiredImplementation;
  function requireImplementation() {
    if (hasRequiredImplementation)
      return implementation;
    hasRequiredImplementation = 1;
    implementation = function isNaN2(value) {
      return value !== value;
    };
    return implementation;
  }
  var polyfill;
  var hasRequiredPolyfill;
  function requirePolyfill() {
    if (hasRequiredPolyfill)
      return polyfill;
    hasRequiredPolyfill = 1;
    var implementation2 = requireImplementation();
    polyfill = function getPolyfill() {
      if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
        return Number.isNaN;
      }
      return implementation2;
    };
    return polyfill;
  }
  var shim;
  var hasRequiredShim;
  function requireShim() {
    if (hasRequiredShim)
      return shim;
    hasRequiredShim = 1;
    var define2 = requireDefineProperties();
    var getPolyfill = requirePolyfill();
    shim = function shimNumberIsNaN() {
      var polyfill2 = getPolyfill();
      define2(Number, { isNaN: polyfill2 }, {
        isNaN: function testIsNaN() {
          return Number.isNaN !== polyfill2;
        }
      });
      return polyfill2;
    };
    return shim;
  }
  var isNan;
  var hasRequiredIsNan;
  function requireIsNan() {
    if (hasRequiredIsNan)
      return isNan;
    hasRequiredIsNan = 1;
    var callBind2 = callBindExports;
    var define2 = requireDefineProperties();
    var implementation2 = requireImplementation();
    var getPolyfill = requirePolyfill();
    var shim2 = requireShim();
    var polyfill2 = callBind2(getPolyfill(), Number);
    define2(polyfill2, {
      getPolyfill,
      implementation: implementation2,
      shim: shim2
    });
    isNan = polyfill2;
    return isNan;
  }
  var comparisons;
  var hasRequiredComparisons;
  function requireComparisons() {
    if (hasRequiredComparisons)
      return comparisons;
    hasRequiredComparisons = 1;
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len2) {
      if (len2 == null || len2 > arr.length)
        len2 = arr.length;
      for (var i2 = 0, arr2 = new Array(len2); i2 < len2; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    function _iterableToArrayLimit(r2, l) {
      var t = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (null != t) {
        var e, n2, i2, u, a = [], f2 = true, o = false;
        try {
          if (i2 = (t = t.call(r2)).next, 0 === l) {
            if (Object(t) !== t)
              return;
            f2 = false;
          } else
            for (; !(f2 = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f2 = true)
              ;
        } catch (r3) {
          o = true, n2 = r3;
        } finally {
          try {
            if (!f2 && null != t.return && (u = t.return(), Object(u) !== u))
              return;
          } finally {
            if (o)
              throw n2;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    var regexFlagsSupported = /a/g.flags !== void 0;
    var arrayFromSet = function arrayFromSet2(set) {
      var array = [];
      set.forEach(function(value) {
        return array.push(value);
      });
      return array;
    };
    var arrayFromMap = function arrayFromMap2(map) {
      var array = [];
      map.forEach(function(value, key2) {
        return array.push([key2, value]);
      });
      return array;
    };
    var objectIs2 = Object.is ? Object.is : requireObjectIs();
    var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
      return [];
    };
    var numberIsNaN2 = Number.isNaN ? Number.isNaN : requireIsNan();
    function uncurryThis(f2) {
      return f2.call.bind(f2);
    }
    var hasOwnProperty2 = uncurryThis(Object.prototype.hasOwnProperty);
    var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
    var objectToString = uncurryThis(Object.prototype.toString);
    var _require$types = util.types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
    function isNonIndex(key2) {
      if (key2.length === 0 || key2.length > 10)
        return true;
      for (var i2 = 0; i2 < key2.length; i2++) {
        var code2 = key2.charCodeAt(i2);
        if (code2 < 48 || code2 > 57)
          return true;
      }
      return key2.length === 10 && key2 >= Math.pow(2, 32);
    }
    function getOwnNonIndexProperties(value) {
      return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
    }
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */
    function compare(a, b) {
      if (a === b) {
        return 0;
      }
      var x = a.length;
      var y = b.length;
      for (var i2 = 0, len2 = Math.min(x, y); i2 < len2; ++i2) {
        if (a[i2] !== b[i2]) {
          x = a[i2];
          y = b[i2];
          break;
        }
      }
      if (x < y) {
        return -1;
      }
      if (y < x) {
        return 1;
      }
      return 0;
    }
    var kStrict = true;
    var kLoose = false;
    var kNoIterator = 0;
    var kIsArray = 1;
    var kIsSet = 2;
    var kIsMap = 3;
    function areSimilarRegExps(a, b) {
      return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
    }
    function areSimilarFloatArrays(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (var offset = 0; offset < a.byteLength; offset++) {
        if (a[offset] !== b[offset]) {
          return false;
        }
      }
      return true;
    }
    function areSimilarTypedArrays(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
    }
    function areEqualArrayBuffers(buf1, buf2) {
      return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
    }
    function isEqualBoxedPrimitive(val1, val2) {
      if (isNumberObject(val1)) {
        return isNumberObject(val2) && objectIs2(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
      }
      if (isStringObject(val1)) {
        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
      }
      if (isBooleanObject(val1)) {
        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
      }
      if (isBigIntObject(val1)) {
        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
      }
      return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
    }
    function innerDeepEqual(val1, val2, strict, memos) {
      if (val1 === val2) {
        if (val1 !== 0)
          return true;
        return strict ? objectIs2(val1, val2) : true;
      }
      if (strict) {
        if (_typeof(val1) !== "object") {
          return typeof val1 === "number" && numberIsNaN2(val1) && numberIsNaN2(val2);
        }
        if (_typeof(val2) !== "object" || val1 === null || val2 === null) {
          return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
          return false;
        }
      } else {
        if (val1 === null || _typeof(val1) !== "object") {
          if (val2 === null || _typeof(val2) !== "object") {
            return val1 == val2;
          }
          return false;
        }
        if (val2 === null || _typeof(val2) !== "object") {
          return false;
        }
      }
      var val1Tag = objectToString(val1);
      var val2Tag = objectToString(val2);
      if (val1Tag !== val2Tag) {
        return false;
      }
      if (Array.isArray(val1)) {
        if (val1.length !== val2.length) {
          return false;
        }
        var keys1 = getOwnNonIndexProperties(val1);
        var keys2 = getOwnNonIndexProperties(val2);
        if (keys1.length !== keys2.length) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
      }
      if (val1Tag === "[object Object]") {
        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
          return false;
        }
      }
      if (isDate(val1)) {
        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
          return false;
        }
      } else if (isRegExp(val1)) {
        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
          return false;
        }
      } else if (isNativeError(val1) || val1 instanceof Error) {
        if (val1.message !== val2.message || val1.name !== val2.name) {
          return false;
        }
      } else if (isArrayBufferView(val1)) {
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
          if (!areSimilarFloatArrays(val1, val2)) {
            return false;
          }
        } else if (!areSimilarTypedArrays(val1, val2)) {
          return false;
        }
        var _keys = getOwnNonIndexProperties(val1);
        var _keys2 = getOwnNonIndexProperties(val2);
        if (_keys.length !== _keys2.length) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
      } else if (isSet(val1)) {
        if (!isSet(val2) || val1.size !== val2.size) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsSet);
      } else if (isMap(val1)) {
        if (!isMap(val2) || val1.size !== val2.size) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsMap);
      } else if (isAnyArrayBuffer(val1)) {
        if (!areEqualArrayBuffers(val1, val2)) {
          return false;
        }
      } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kNoIterator);
    }
    function getEnumerables(val, keys) {
      return keys.filter(function(k2) {
        return propertyIsEnumerable(val, k2);
      });
    }
    function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
      if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        var bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
          return false;
        }
      }
      var i2 = 0;
      for (; i2 < aKeys.length; i2++) {
        if (!hasOwnProperty2(val2, aKeys[i2])) {
          return false;
        }
      }
      if (strict && arguments.length === 5) {
        var symbolKeysA = objectGetOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
          var count = 0;
          for (i2 = 0; i2 < symbolKeysA.length; i2++) {
            var key2 = symbolKeysA[i2];
            if (propertyIsEnumerable(val1, key2)) {
              if (!propertyIsEnumerable(val2, key2)) {
                return false;
              }
              aKeys.push(key2);
              count++;
            } else if (propertyIsEnumerable(val2, key2)) {
              return false;
            }
          }
          var symbolKeysB = objectGetOwnPropertySymbols(val2);
          if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
            return false;
          }
        } else {
          var _symbolKeysB = objectGetOwnPropertySymbols(val2);
          if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
            return false;
          }
        }
      }
      if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
        return true;
      }
      if (memos === void 0) {
        memos = {
          val1: /* @__PURE__ */ new Map(),
          val2: /* @__PURE__ */ new Map(),
          position: 0
        };
      } else {
        var val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== void 0) {
          var val2MemoB = memos.val2.get(val2);
          if (val2MemoB !== void 0) {
            return val2MemoA === val2MemoB;
          }
        }
        memos.position++;
      }
      memos.val1.set(val1, memos.position);
      memos.val2.set(val2, memos.position);
      var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
      memos.val1.delete(val1);
      memos.val2.delete(val2);
      return areEq;
    }
    function setHasEqualElement(set, val1, strict, memo) {
      var setValues = arrayFromSet(set);
      for (var i2 = 0; i2 < setValues.length; i2++) {
        var val2 = setValues[i2];
        if (innerDeepEqual(val1, val2, strict, memo)) {
          set.delete(val2);
          return true;
        }
      }
      return false;
    }
    function findLooseMatchingPrimitives(prim) {
      switch (_typeof(prim)) {
        case "undefined":
          return null;
        case "object":
          return void 0;
        case "symbol":
          return false;
        case "string":
          prim = +prim;
        case "number":
          if (numberIsNaN2(prim)) {
            return false;
          }
      }
      return true;
    }
    function setMightHaveLoosePrim(a, b, prim) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null)
        return altValue;
      return b.has(altValue) && !a.has(altValue);
    }
    function mapMightHaveLoosePrim(a, b, prim, item, memo) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null) {
        return altValue;
      }
      var curB = b.get(altValue);
      if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
        return false;
      }
      return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
    }
    function setEquiv(a, b, strict, memo) {
      var set = null;
      var aValues = arrayFromSet(a);
      for (var i2 = 0; i2 < aValues.length; i2++) {
        var val = aValues[i2];
        if (_typeof(val) === "object" && val !== null) {
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(val);
        } else if (!b.has(val)) {
          if (strict)
            return false;
          if (!setMightHaveLoosePrim(a, b, val)) {
            return false;
          }
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(val);
        }
      }
      if (set !== null) {
        var bValues = arrayFromSet(b);
        for (var _i = 0; _i < bValues.length; _i++) {
          var _val = bValues[_i];
          if (_typeof(_val) === "object" && _val !== null) {
            if (!setHasEqualElement(set, _val, strict, memo))
              return false;
          } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
            return false;
          }
        }
        return set.size === 0;
      }
      return true;
    }
    function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
      var setValues = arrayFromSet(set);
      for (var i2 = 0; i2 < setValues.length; i2++) {
        var key2 = setValues[i2];
        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
          set.delete(key2);
          return true;
        }
      }
      return false;
    }
    function mapEquiv(a, b, strict, memo) {
      var set = null;
      var aEntries = arrayFromMap(a);
      for (var i2 = 0; i2 < aEntries.length; i2++) {
        var _aEntries$i = _slicedToArray(aEntries[i2], 2), key2 = _aEntries$i[0], item1 = _aEntries$i[1];
        if (_typeof(key2) === "object" && key2 !== null) {
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(key2);
        } else {
          var item2 = b.get(key2);
          if (item2 === void 0 && !b.has(key2) || !innerDeepEqual(item1, item2, strict, memo)) {
            if (strict)
              return false;
            if (!mapMightHaveLoosePrim(a, b, key2, item1, memo))
              return false;
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(key2);
          }
        }
      }
      if (set !== null) {
        var bEntries = arrayFromMap(b);
        for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
          var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), _key = _bEntries$_i[0], item = _bEntries$_i[1];
          if (_typeof(_key) === "object" && _key !== null) {
            if (!mapHasEqualEntry(set, a, _key, item, strict, memo))
              return false;
          } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) {
            return false;
          }
        }
        return set.size === 0;
      }
      return true;
    }
    function objEquiv(a, b, strict, keys, memos, iterationType) {
      var i2 = 0;
      if (iterationType === kIsSet) {
        if (!setEquiv(a, b, strict, memos)) {
          return false;
        }
      } else if (iterationType === kIsMap) {
        if (!mapEquiv(a, b, strict, memos)) {
          return false;
        }
      } else if (iterationType === kIsArray) {
        for (; i2 < a.length; i2++) {
          if (hasOwnProperty2(a, i2)) {
            if (!hasOwnProperty2(b, i2) || !innerDeepEqual(a[i2], b[i2], strict, memos)) {
              return false;
            }
          } else if (hasOwnProperty2(b, i2)) {
            return false;
          } else {
            var keysA = Object.keys(a);
            for (; i2 < keysA.length; i2++) {
              var key2 = keysA[i2];
              if (!hasOwnProperty2(b, key2) || !innerDeepEqual(a[key2], b[key2], strict, memos)) {
                return false;
              }
            }
            if (keysA.length !== Object.keys(b).length) {
              return false;
            }
            return true;
          }
        }
      }
      for (i2 = 0; i2 < keys.length; i2++) {
        var _key2 = keys[i2];
        if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {
          return false;
        }
      }
      return true;
    }
    function isDeepEqual(val1, val2) {
      return innerDeepEqual(val1, val2, kLoose);
    }
    function isDeepStrictEqual(val1, val2) {
      return innerDeepEqual(val1, val2, kStrict);
    }
    comparisons = {
      isDeepEqual,
      isDeepStrictEqual
    };
    return comparisons;
  }
  var hasRequiredAssert;
  function requireAssert() {
    if (hasRequiredAssert)
      return assert$l.exports;
    hasRequiredAssert = 1;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key2 = _toPrimitive(arg, "string");
      return _typeof(key2) === "symbol" ? key2 : String(key2);
    }
    function _toPrimitive(input2, hint) {
      if (_typeof(input2) !== "object" || input2 === null)
        return input2;
      var prim = input2[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input2, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input2);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var _require = requireErrors(), _require$codes2 = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes2.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes2.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes2.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS2 = _require$codes2.ERR_MISSING_ARGS;
    var AssertionError = requireAssertion_error();
    var _require2 = util, inspect = _require2.inspect;
    var _require$types = util.types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
    var objectAssign = polyfill$2();
    var objectIs2 = polyfill$1();
    var RegExpPrototypeTest = callBound$3("RegExp.prototype.test");
    var isDeepEqual;
    var isDeepStrictEqual;
    function lazyLoadComparison() {
      var comparison = requireComparisons();
      isDeepEqual = comparison.isDeepEqual;
      isDeepStrictEqual = comparison.isDeepStrictEqual;
    }
    var warned = false;
    var assert2 = assert$l.exports = ok;
    var NO_EXCEPTION_SENTINEL = {};
    function innerFail(obj) {
      if (obj.message instanceof Error)
        throw obj.message;
      throw new AssertionError(obj);
    }
    function fail(actual, expected, message2, operator, stackStartFn) {
      var argsLen = arguments.length;
      var internalMessage;
      if (argsLen === 0) {
        internalMessage = "Failed";
      } else if (argsLen === 1) {
        message2 = actual;
        actual = void 0;
      } else {
        if (warned === false) {
          warned = true;
          var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
          warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
        }
        if (argsLen === 2)
          operator = "!=";
      }
      if (message2 instanceof Error)
        throw message2;
      var errArgs = {
        actual,
        expected,
        operator: operator === void 0 ? "fail" : operator,
        stackStartFn: stackStartFn || fail
      };
      if (message2 !== void 0) {
        errArgs.message = message2;
      }
      var err = new AssertionError(errArgs);
      if (internalMessage) {
        err.message = internalMessage;
        err.generatedMessage = true;
      }
      throw err;
    }
    assert2.fail = fail;
    assert2.AssertionError = AssertionError;
    function innerOk(fn, argLen, value, message2) {
      if (!value) {
        var generatedMessage = false;
        if (argLen === 0) {
          generatedMessage = true;
          message2 = "No value argument passed to `assert.ok()`";
        } else if (message2 instanceof Error) {
          throw message2;
        }
        var err = new AssertionError({
          actual: value,
          expected: true,
          message: message2,
          operator: "==",
          stackStartFn: fn
        });
        err.generatedMessage = generatedMessage;
        throw err;
      }
    }
    function ok() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      innerOk.apply(void 0, [ok, args.length].concat(args));
    }
    assert2.ok = ok;
    assert2.equal = function equal(actual, expected, message2) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS2("actual", "expected");
      }
      if (actual != expected) {
        innerFail({
          actual,
          expected,
          message: message2,
          operator: "==",
          stackStartFn: equal
        });
      }
    };
    assert2.notEqual = function notEqual(actual, expected, message2) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS2("actual", "expected");
      }
      if (actual == expected) {
        innerFail({
          actual,
          expected,
          message: message2,
          operator: "!=",
          stackStartFn: notEqual
        });
      }
    };
    assert2.deepEqual = function deepEqual(actual, expected, message2) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS2("actual", "expected");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      if (!isDeepEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message: message2,
          operator: "deepEqual",
          stackStartFn: deepEqual
        });
      }
    };
    assert2.notDeepEqual = function notDeepEqual(actual, expected, message2) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS2("actual", "expected");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      if (isDeepEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message: message2,
          operator: "notDeepEqual",
          stackStartFn: notDeepEqual
        });
      }
    };
    assert2.deepStrictEqual = function deepStrictEqual(actual, expected, message2) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS2("actual", "expected");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      if (!isDeepStrictEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message: message2,
          operator: "deepStrictEqual",
          stackStartFn: deepStrictEqual
        });
      }
    };
    assert2.notDeepStrictEqual = notDeepStrictEqual;
    function notDeepStrictEqual(actual, expected, message2) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS2("actual", "expected");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      if (isDeepStrictEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message: message2,
          operator: "notDeepStrictEqual",
          stackStartFn: notDeepStrictEqual
        });
      }
    }
    assert2.strictEqual = function strictEqual(actual, expected, message2) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS2("actual", "expected");
      }
      if (!objectIs2(actual, expected)) {
        innerFail({
          actual,
          expected,
          message: message2,
          operator: "strictEqual",
          stackStartFn: strictEqual
        });
      }
    };
    assert2.notStrictEqual = function notStrictEqual(actual, expected, message2) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS2("actual", "expected");
      }
      if (objectIs2(actual, expected)) {
        innerFail({
          actual,
          expected,
          message: message2,
          operator: "notStrictEqual",
          stackStartFn: notStrictEqual
        });
      }
    };
    var Comparison = /* @__PURE__ */ _createClass(function Comparison2(obj, keys, actual) {
      var _this = this;
      _classCallCheck(this, Comparison2);
      keys.forEach(function(key2) {
        if (key2 in obj) {
          if (actual !== void 0 && typeof actual[key2] === "string" && isRegExp(obj[key2]) && RegExpPrototypeTest(obj[key2], actual[key2])) {
            _this[key2] = actual[key2];
          } else {
            _this[key2] = obj[key2];
          }
        }
      });
    });
    function compareExceptionKey(actual, expected, key2, message2, keys, fn) {
      if (!(key2 in actual) || !isDeepStrictEqual(actual[key2], expected[key2])) {
        if (!message2) {
          var a = new Comparison(actual, keys);
          var b = new Comparison(expected, keys, actual);
          var err = new AssertionError({
            actual: a,
            expected: b,
            operator: "deepStrictEqual",
            stackStartFn: fn
          });
          err.actual = actual;
          err.expected = expected;
          err.operator = fn.name;
          throw err;
        }
        innerFail({
          actual,
          expected,
          message: message2,
          operator: fn.name,
          stackStartFn: fn
        });
      }
    }
    function expectedException(actual, expected, msg, fn) {
      if (typeof expected !== "function") {
        if (isRegExp(expected))
          return RegExpPrototypeTest(expected, actual);
        if (arguments.length === 2) {
          throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
        }
        if (_typeof(actual) !== "object" || actual === null) {
          var err = new AssertionError({
            actual,
            expected,
            message: msg,
            operator: "deepStrictEqual",
            stackStartFn: fn
          });
          err.operator = fn.name;
          throw err;
        }
        var keys = Object.keys(expected);
        if (expected instanceof Error) {
          keys.push("name", "message");
        } else if (keys.length === 0) {
          throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
        }
        if (isDeepEqual === void 0)
          lazyLoadComparison();
        keys.forEach(function(key2) {
          if (typeof actual[key2] === "string" && isRegExp(expected[key2]) && RegExpPrototypeTest(expected[key2], actual[key2])) {
            return;
          }
          compareExceptionKey(actual, expected, key2, msg, keys, fn);
        });
        return true;
      }
      if (expected.prototype !== void 0 && actual instanceof expected) {
        return true;
      }
      if (Error.isPrototypeOf(expected)) {
        return false;
      }
      return expected.call({}, actual) === true;
    }
    function getActual(fn) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
      }
      try {
        fn();
      } catch (e) {
        return e;
      }
      return NO_EXCEPTION_SENTINEL;
    }
    function checkIsPromise(obj) {
      return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
    }
    function waitForActual(promiseFn) {
      return Promise.resolve().then(function() {
        var resultPromise;
        if (typeof promiseFn === "function") {
          resultPromise = promiseFn();
          if (!checkIsPromise(resultPromise)) {
            throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
          }
        } else if (checkIsPromise(promiseFn)) {
          resultPromise = promiseFn;
        } else {
          throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
        }
        return Promise.resolve().then(function() {
          return resultPromise;
        }).then(function() {
          return NO_EXCEPTION_SENTINEL;
        }).catch(function(e) {
          return e;
        });
      });
    }
    function expectsError(stackStartFn, actual, error, message2) {
      if (typeof error === "string") {
        if (arguments.length === 4) {
          throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
        }
        if (_typeof(actual) === "object" && actual !== null) {
          if (actual.message === error) {
            throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
          }
        } else if (actual === error) {
          throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
        }
        message2 = error;
        error = void 0;
      } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") {
        throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
      }
      if (actual === NO_EXCEPTION_SENTINEL) {
        var details = "";
        if (error && error.name) {
          details += " (".concat(error.name, ")");
        }
        details += message2 ? ": ".concat(message2) : ".";
        var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
        innerFail({
          actual: void 0,
          expected: error,
          operator: stackStartFn.name,
          message: "Missing expected ".concat(fnType).concat(details),
          stackStartFn
        });
      }
      if (error && !expectedException(actual, error, message2, stackStartFn)) {
        throw actual;
      }
    }
    function expectsNoError(stackStartFn, actual, error, message2) {
      if (actual === NO_EXCEPTION_SENTINEL)
        return;
      if (typeof error === "string") {
        message2 = error;
        error = void 0;
      }
      if (!error || expectedException(actual, error)) {
        var details = message2 ? ": ".concat(message2) : ".";
        var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
        innerFail({
          actual,
          expected: error,
          operator: stackStartFn.name,
          message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
          stackStartFn
        });
      }
      throw actual;
    }
    assert2.throws = function throws(promiseFn) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
    };
    assert2.rejects = function rejects(promiseFn) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return waitForActual(promiseFn).then(function(result) {
        return expectsError.apply(void 0, [rejects, result].concat(args));
      });
    };
    assert2.doesNotThrow = function doesNotThrow(fn) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
    };
    assert2.doesNotReject = function doesNotReject(fn) {
      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }
      return waitForActual(fn).then(function(result) {
        return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
      });
    };
    assert2.ifError = function ifError(err) {
      if (err !== null && err !== void 0) {
        var message2 = "ifError got unwanted exception: ";
        if (_typeof(err) === "object" && typeof err.message === "string") {
          if (err.message.length === 0 && err.constructor) {
            message2 += err.constructor.name;
          } else {
            message2 += err.message;
          }
        } else {
          message2 += inspect(err);
        }
        var newErr = new AssertionError({
          actual: err,
          expected: null,
          operator: "ifError",
          message: message2,
          stackStartFn: ifError
        });
        var origStack = err.stack;
        if (typeof origStack === "string") {
          var tmp2 = origStack.split("\n");
          tmp2.shift();
          var tmp1 = newErr.stack.split("\n");
          for (var i2 = 0; i2 < tmp2.length; i2++) {
            var pos = tmp1.indexOf(tmp2[i2]);
            if (pos !== -1) {
              tmp1 = tmp1.slice(0, pos);
              break;
            }
          }
          newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
        }
        throw newErr;
      }
    };
    function internalMatch(string, regexp, message2, fn, fnName) {
      if (!isRegExp(regexp)) {
        throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
      }
      var match = fnName === "match";
      if (typeof string !== "string" || RegExpPrototypeTest(regexp, string) !== match) {
        if (message2 instanceof Error) {
          throw message2;
        }
        var generatedMessage = !message2;
        message2 = message2 || (typeof string !== "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
        var err = new AssertionError({
          actual: string,
          expected: regexp,
          message: message2,
          operator: fnName,
          stackStartFn: fn
        });
        err.generatedMessage = generatedMessage;
        throw err;
      }
    }
    assert2.match = function match(string, regexp, message2) {
      internalMatch(string, regexp, message2, match, "match");
    };
    assert2.doesNotMatch = function doesNotMatch(string, regexp, message2) {
      internalMatch(string, regexp, message2, doesNotMatch, "doesNotMatch");
    };
    function strict() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      innerOk.apply(void 0, [strict, args.length].concat(args));
    }
    assert2.strict = objectAssign(strict, assert2, {
      equal: assert2.strictEqual,
      deepEqual: assert2.deepStrictEqual,
      notEqual: assert2.notStrictEqual,
      notDeepEqual: assert2.notDeepStrictEqual
    });
    assert2.strict.strict = assert2.strict;
    return assert$l.exports;
  }
  var _$c = lodashExports;
  var isHexa = function isHexa2(value) {
    if (!_$c.isString(value)) {
      return false;
    }
    return /^[0-9a-fA-F]+$/.test(value);
  };
  var js$1 = {
    /**
     * Test if an argument is a valid JSON object. If it is, returns a truthy
     * value (the json object decoded), so no double JSON.parse call is necessary
     *
     * @param {string} arg
     * @return {Object|boolean} false if the argument is not a JSON string.
     */
    isValidJSON: function isValidJSON(arg) {
      var parsed;
      if (!_$c.isString(arg)) {
        return false;
      }
      try {
        parsed = JSON.parse(arg);
      } catch (e) {
        return false;
      }
      if (typeof parsed === "object") {
        return true;
      }
      return false;
    },
    isHexa,
    isHexaString: isHexa,
    /**
     * Clone an array
     */
    cloneArray: function(array) {
      return [].concat(array);
    },
    /**
     * Define immutable properties on a target object
     *
     * @param {Object} target - An object to be extended
     * @param {Object} values - An object of properties
     * @return {Object} The target object
     */
    defineImmutable: function defineImmutable(target, values) {
      Object.keys(values).forEach(function(key2) {
        Object.defineProperty(target, key2, {
          configurable: false,
          enumerable: true,
          value: values[key2]
        });
      });
      return target;
    },
    /**
     * Checks that a value is a natural number, a positive integer or zero.
     *
     * @param {*} value
     * @return {Boolean}
     */
    isNaturalNumber: function isNaturalNumber(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value && value >= 0;
    }
  };
  (function(module2) {
    var buffer2 = buffer$2;
    requireAssert();
    var $2 = preconditions;
    function equals(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      var length = a.length;
      for (var i2 = 0; i2 < length; i2++) {
        if (a[i2] !== b[i2]) {
          return false;
        }
      }
      return true;
    }
    module2.exports = {
      /**
       * Fill a buffer with a value.
       *
       * @param {Buffer} buffer
       * @param {number} value
       * @return {Buffer}
       */
      fill: function fill(buffer3, value) {
        $2.checkArgumentType(buffer3, "Buffer", "buffer");
        $2.checkArgumentType(value, "number", "value");
        var length = buffer3.length;
        for (var i2 = 0; i2 < length; i2++) {
          buffer3[i2] = value;
        }
        return buffer3;
      },
      /**
       * Return a copy of a buffer
       *
       * @param {Buffer} original
       * @return {Buffer}
       */
      copy: function(original) {
        var buffer3 = buffer$2.Buffer.alloc(original.length);
        original.copy(buffer3);
        return buffer3;
      },
      /**
       * Returns true if the given argument is an instance of a buffer. Tests for
       * both node's Buffer and Uint8Array
       *
       * @param {*} arg
       * @return {boolean}
       */
      isBuffer: function isBuffer(arg) {
        return buffer2.Buffer.isBuffer(arg) || arg instanceof Uint8Array;
      },
      /**
       * Returns a zero-filled byte array
       *
       * @param {number} bytes
       * @return {Buffer}
       */
      emptyBuffer: function emptyBuffer(bytes2) {
        $2.checkArgumentType(bytes2, "number", "bytes");
        var result = buffer$2.Buffer.alloc(bytes2);
        for (var i2 = 0; i2 < bytes2; i2++) {
          result.write("\0", i2);
        }
        return result;
      },
      /**
       * Concatenates a buffer
       *
       * Shortcut for <tt>buffer.Buffer.concat</tt>
       */
      concat: buffer2.Buffer.concat,
      equals,
      equal: equals,
      /**
       * Transforms a number from 0 to 255 into a Buffer of size 1 with that value
       *
       * @param {number} integer
       * @return {Buffer}
       */
      integerAsSingleByteBuffer: function integerAsSingleByteBuffer(integer) {
        $2.checkArgumentType(integer, "number", "integer");
        return buffer$2.Buffer.from([integer & 255]);
      },
      /**
       * Transform a 4-byte integer into a Buffer of length 4.
       *
       * @param {number} integer
       * @return {Buffer}
       */
      integerAsBuffer: function integerAsBuffer(integer) {
        $2.checkArgumentType(integer, "number", "integer");
        var bytes2 = [];
        bytes2.push(integer >> 24 & 255);
        bytes2.push(integer >> 16 & 255);
        bytes2.push(integer >> 8 & 255);
        bytes2.push(integer & 255);
        return buffer$2.Buffer.from(bytes2);
      },
      /**
       * Transform the first 4 values of a Buffer into a number, in little endian encoding
       *
       * @param {Buffer} buffer
       * @return {number}
       */
      integerFromBuffer: function integerFromBuffer(buffer3) {
        $2.checkArgumentType(buffer3, "Buffer", "buffer");
        return buffer3[0] << 24 | buffer3[1] << 16 | buffer3[2] << 8 | buffer3[3];
      },
      /**
       * Transforms the first byte of an array into a number ranging from -128 to 127
       * @param {Buffer} buffer
       * @return {number}
       */
      integerFromSingleByteBuffer: function integerFromBuffer(buffer3) {
        $2.checkArgumentType(buffer3, "Buffer", "buffer");
        return buffer3[0];
      },
      /**
       * Transforms a buffer into a string with a number in hexa representation
       *
       * Shorthand for <tt>buffer.toString('hex')</tt>
       *
       * @param {Buffer} buffer
       * @return {string}
       */
      bufferToHex: function bufferToHex(buffer3) {
        $2.checkArgumentType(buffer3, "Buffer", "buffer");
        return buffer3.toString("hex");
      },
      /**
       * Reverse a buffer
       * @param {Buffer} param
       * @return {Buffer}
       */
      reverse: function reverse(param) {
        return buffer$2.Buffer.from(param).reverse();
      }
    };
    module2.exports.NULL_HASH = module2.exports.fill(buffer$2.Buffer.alloc(32), 0);
    module2.exports.EMPTY_BUFFER = buffer$2.Buffer.alloc(0);
  })(buffer$1);
  var bufferExports = buffer$1.exports;
  var elliptic$2 = {};
  const name$1 = "elliptic";
  const version$1 = "6.5.4";
  const description$1 = "EC cryptography";
  const main$1 = "lib/elliptic.js";
  const files = [
    "lib"
  ];
  const scripts$1 = {
    lint: "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    unit: "istanbul test _mocha --reporter=spec test/index.js",
    test: "npm run lint && npm run unit",
    version: "grunt dist && git add dist/"
  };
  const repository$1 = {
    type: "git",
    url: "git@github.com:indutny/elliptic"
  };
  const keywords$1 = [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ];
  const author = "Fedor Indutny <fedor@indutny.com>";
  const license = "MIT";
  const bugs = {
    url: "https://github.com/indutny/elliptic/issues"
  };
  const homepage = "https://github.com/indutny/elliptic";
  const devDependencies$1 = {
    brfs: "^2.0.2",
    coveralls: "^3.1.0",
    eslint: "^7.6.0",
    grunt: "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    istanbul: "^0.4.5",
    mocha: "^8.0.1"
  };
  const dependencies$1 = {
    "bn.js": "^4.11.9",
    brorand: "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    inherits: "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
  };
  const require$$0$1 = {
    name: name$1,
    version: version$1,
    description: description$1,
    main: main$1,
    files,
    scripts: scripts$1,
    repository: repository$1,
    keywords: keywords$1,
    author,
    license,
    bugs,
    homepage,
    devDependencies: devDependencies$1,
    dependencies: dependencies$1
  };
  var utils$m = {};
  var bn$1 = { exports: {} };
  bn$1.exports;
  (function(module2) {
    (function(module3, exports2) {
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number2, base2, endian) {
        if (BN2.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number2 || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require$$1$1.Buffer;
        }
      } catch (e) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init(number2, base2, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base2, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base2 === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number2, base2, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initArray = function _initArray(number2, base2, endian) {
        assert2(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i2 = number2.length - 1, j = 0; i2 >= 0; i2 -= 3) {
            w = number2[i2] | number2[i2 - 1] << 8 | number2[i2 - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i2 = 0, j = 0; i2 < number2.length; i2 += 3) {
            w = number2[i2] | number2[i2 + 1] << 8 | number2[i2 + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r2 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r2;
      }
      BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i2 = number2.length - 1; i2 >= start; i2 -= 2) {
            w = parseHexByte(number2, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number2.length; i2 += 2) {
            w = parseHexByte(number2, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r2 = 0;
        var len2 = Math.min(str.length, end);
        for (var i2 = start; i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          r2 *= mul;
          if (c >= 49) {
            r2 += c - 49 + 10;
          } else if (c >= 17) {
            r2 += c - 17 + 10;
          } else {
            r2 += c;
          }
        }
        return r2;
      }
      BN2.prototype._parseBase = function _parseBase(number2, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number2.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i2 = start; i2 < end; i2 += limbLen) {
          word = parseBase(number2, i2, i2 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow3 = 1;
          word = parseBase(number2, i2, number2.length, base2);
          for (i2 = 0; i2 < mod2; i2++) {
            pow3 *= base2;
          }
          this.imuln(pow3);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          dest.words[i2] = this.words[i2];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r2 = new BN2(null);
        this.copy(r2);
        return r2;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w = this.words[i2];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i2 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i2--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r2 = c.modn(groupBase).toString(base2);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer2(endian, length) {
        assert2(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength2 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength2);
        assert2(byteLength2 <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i2;
        var q = this.clone();
        if (!littleEndian) {
          for (i2 = 0; i2 < reqLength - byteLength2; i2++) {
            res[i2] = 0;
          }
          for (i2 = 0; !q.isZero(); i2++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i2 - 1] = b;
          }
        } else {
          for (i2 = 0; !q.isZero(); i2++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i2] = b;
          }
          for (; i2 < reqLength; i2++) {
            res[i2] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w) {
          var t = w;
          var r2 = 0;
          if (t >= 4096) {
            r2 += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r2 += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r2 += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r2 += 2;
            t >>>= 2;
          }
          return r2 + t;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r2 = 0;
        if ((t & 8191) === 0) {
          r2 += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r2 += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r2 += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r2 += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r2 = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          r2 += b;
          if (b !== 26)
            break;
        }
        return r2;
      };
      BN2.prototype.byteLength = function byteLength2() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i2 = 0; i2 < num.length; i2++) {
          this.words[i2] = this.words[i2] | num.words[i2];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = this.words[i2] & num.words[i2];
        }
        this.length = b.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = a.words[i2] ^ b.words[i2];
        }
        if (this !== a) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i2 = 0; i2 < bytesNeeded; i2++) {
          this.words[i2] = ~this.words[i2] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r2 = (a.words[i2] | 0) + (b.words[i2] | 0) + carry;
          this.words[i2] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i2 < a.length; i2++) {
          r2 = (a.words[i2] | 0) + carry;
          this.words[i2] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r2 = (a.words[i2] | 0) - (b.words[i2] | 0) + carry;
          carry = r2 >> 26;
          this.words[i2] = r2 & 67108863;
        }
        for (; carry !== 0 && i2 < a.length; i2++) {
          r2 = (a.words[i2] | 0) + carry;
          carry = r2 >> 26;
          this.words[i2] = r2 & 67108863;
        }
        if (carry === 0 && i2 < a.length && a !== this) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        this.length = Math.max(this.length, i2);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2;
        len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r2 = a * b;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k2 = 1; k2 < len2; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
            var i2 = k2 - j | 0;
            a = self2.words[i2] | 0;
            b = num.words[j] | 0;
            r2 = a * b + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
            var i2 = k2 - j;
            var a = self2.words[i2] | 0;
            var b = num.words[j] | 0;
            var r2 = a * b;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len2 < 63) {
          res = smallMulTo(this, num, out);
        } else if (len2 < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN2.prototype._countBits(N) - 1;
        for (var i2 = 0; i2 < N; i2++) {
          t[i2] = this.revBin(i2, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i2 = 0; i2 < l; i2++) {
          rb |= (x & 1) << l - i2 - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i2 = 0; i2 < N; i2++) {
          rtws[i2] = rws[rbt[i2]];
          itws[i2] = iws[rbt[i2]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s2 = 1; s2 < N; s2 <<= 1) {
          var l = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p2 = 0; p2 < N; p2 += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s2; j++) {
              var re = rtws[p2 + j];
              var ie = itws[p2 + j];
              var ro = rtws[p2 + j + s2];
              var io = itws[p2 + j + s2];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p2 + j] = re + ro;
              itws[p2 + j] = ie + io;
              rtws[p2 + j + s2] = re - ro;
              itws[p2 + j + s2] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m) {
        var N = Math.max(m, n2) | 1;
        var odd = N & 1;
        var i2 = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i2++;
        }
        return 1 << i2 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i2 = 0; i2 < N / 2; i2++) {
          var t = rws[i2];
          rws[i2] = rws[N - i2 - 1];
          rws[N - i2 - 1] = t;
          t = iws[i2];
          iws[i2] = -iws[N - i2 - 1];
          iws[N - i2 - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i2 = 0; i2 < N / 2; i2++) {
          var w = Math.round(ws[2 * i2 + 1] / N) * 8192 + Math.round(ws[2 * i2] / N) + carry;
          ws[i2] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N) {
        var carry = 0;
        for (var i2 = 0; i2 < len2; i2++) {
          carry = carry + (ws[i2] | 0);
          rws[2 * i2] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i2 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i2 = 2 * len2; i2 < N; ++i2) {
          rws[i2] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i2 = 0; i2 < N; i2++) {
          ph[i2] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _2 = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _2, rwst, iwst, N, rbt);
        this.transform(nrws, _2, nrwst, niwst, N, rbt);
        for (var i2 = 0; i2 < N; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
          rwst[i2] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _2, N, rbt);
        this.conjugate(rmws, _2, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i2] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow3(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN2(1);
        var res = this;
        for (var i2 = 0; i2 < w.length; i2++, res = res.sqr()) {
          if (w[i2] !== 0)
            break;
        }
        if (++i2 < w.length) {
          for (var q = res.sqr(); i2 < w.length; i2++, q = q.sqr()) {
            if (w[i2] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i2;
        if (r2 !== 0) {
          var carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask;
            var c = (this.words[i2] | 0) - newCarry << r2;
            this.words[i2] = c | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i2] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i2 = this.length - 1; i2 >= 0; i2--) {
            this.words[i2 + s2] = this.words[i2];
          }
          for (i2 = 0; i2 < s2; i2++) {
            this.words[i2] = 0;
          }
          this.length += s2;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r2 = bits % 26;
        var s2 = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h -= s2;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i2 = 0; i2 < s2; i2++) {
            maskedWords.words[i2] = this.words[i2];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0)
          ;
        else if (this.length > s2) {
          this.length -= s2;
          for (i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = this.words[i2 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s2)
          return false;
        var w = this.words[s2];
        return !!(w & q);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r2 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
          this.words[i2] -= 67108864;
          if (i2 === this.length - 1) {
            this.words[i2 + 1] = 1;
          } else {
            this.words[i2 + 1]++;
          }
        }
        this.length = Math.max(this.length, i2 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
            this.words[i2] += 67108864;
            this.words[i2 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift;
        var i2;
        this._expand(len2);
        var w;
        var carry = 0;
        for (i2 = 0; i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i2 + shift] = w & 67108863;
        }
        for (; i2 < this.length - shift; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i2 + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert2(carry === -1);
        carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          w = -(this.words[i2] | 0) + carry;
          carry = w >> 26;
          this.words[i2] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN2(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i2 = 0; i2 < q.length; i2++) {
            q.words[i2] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert2(num <= 67108863);
        var p2 = (1 << 26) % num;
        var acc = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          acc = (p2 * acc + (this.words[i2] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert2(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p2) {
        assert2(p2.negative === 0);
        assert2(!p2.isZero());
        var x = this;
        var y = p2.clone();
        if (x.negative !== 0) {
          x = x.umod(p2);
        } else {
          x = x.clone();
        }
        var A = new BN2(1);
        var B = new BN2(0);
        var C = new BN2(0);
        var D = new BN2(1);
        var g2 = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g2;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i2 = 0, im = 1; (x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x.iushrn(i2);
            while (i2-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g2)
        };
      };
      BN2.prototype._invmp = function _invmp(p2) {
        assert2(p2.negative === 0);
        assert2(!p2.isZero());
        var a = this;
        var b = p2.clone();
        if (a.negative !== 0) {
          a = a.umod(p2);
        } else {
          a = a.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1; (a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p2);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r2 = a.cmp(b);
          if (r2 < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r2 === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven2() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q;
          return this;
        }
        var carry = q;
        for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i2] = w;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var a = this.words[i2] | 0;
          var b = num.words[i2] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p2) {
        this.name = name2;
        this.p = new BN2(p2, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      };
      MPrime.prototype.split = function split2(input2, out) {
        input2.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split2(input2, output2) {
        var mask = 4194303;
        var outLen = Math.min(input2.length, 9);
        for (var i2 = 0; i2 < outLen; i2++) {
          output2.words[i2] = input2.words[i2];
        }
        output2.length = outLen;
        if (input2.length <= 9) {
          input2.words[0] = 0;
          input2.length = 1;
          return;
        }
        var prev = input2.words[9];
        output2.words[output2.length++] = prev & mask;
        for (i2 = 10; i2 < input2.length; i2++) {
          var next = input2.words[i2] | 0;
          input2.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input2.words[i2 - 10] = prev;
        if (prev === 0 && input2.length > 10) {
          input2.length -= 10;
        } else {
          input2.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977;
          num.words[i2] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i2] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN2._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert2(a.negative === 0, "red works only with positives");
        assert2(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert2((a.negative | b.negative) === 0, "red works only with positives");
        assert2(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow3 = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a, pow3);
        }
        var q = this.m.subn(1);
        var s2 = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s2++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one2 = new BN2(1).toRed(this);
        var nOne = one2.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN2(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r2 = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s2;
        while (t.cmp(one2) !== 0) {
          var tmp = t;
          for (var i2 = 0; tmp.cmp(one2) !== 0; i2++) {
            tmp = tmp.redSqr();
          }
          assert2(i2 < m);
          var b = this.pow(c, new BN2(1).iushln(m - i2 - 1));
          r2 = r2.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i2;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow3(a, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a;
        for (var i2 = 2; i2 < wnd.length; i2++) {
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i2 = num.length - 1; i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i2 !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont2(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN2(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(module2, commonjsGlobal);
  })(bn$1);
  var bnExports$1 = bn$1.exports;
  var minimalisticAssert = assert$k;
  function assert$k(val, msg) {
    if (!val)
      throw new Error(msg || "Assertion failed");
  }
  assert$k.equal = function assertEqual(l, r2, msg) {
    if (l != r2)
      throw new Error(msg || "Assertion failed: " + l + " != " + r2);
  };
  var utils$l = {};
  (function(exports2) {
    var utils2 = exports2;
    function toArray2(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i2 = 0; i2 < msg.length; i2++)
          res[i2] = msg[i2] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i2 = 0; i2 < msg.length; i2 += 2)
          res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
      } else {
        for (var i2 = 0; i2 < msg.length; i2++) {
          var c = msg.charCodeAt(i2);
          var hi = c >> 8;
          var lo = c & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils2.toArray = toArray2;
    function zero22(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils2.zero2 = zero22;
    function toHex2(msg) {
      var res = "";
      for (var i2 = 0; i2 < msg.length; i2++)
        res += zero22(msg[i2].toString(16));
      return res;
    }
    utils2.toHex = toHex2;
    utils2.encode = function encode2(arr, enc) {
      if (enc === "hex")
        return toHex2(arr);
      else
        return arr;
    };
  })(utils$l);
  (function(exports2) {
    var utils2 = exports2;
    var BN2 = bnExports$1;
    var minAssert = minimalisticAssert;
    var minUtils = utils$l;
    utils2.assert = minAssert;
    utils2.toArray = minUtils.toArray;
    utils2.zero2 = minUtils.zero2;
    utils2.toHex = minUtils.toHex;
    utils2.encode = minUtils.encode;
    function getNAF2(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws = 1 << w + 1;
      var k2 = num.clone();
      for (var i2 = 0; i2 < naf.length; i2++) {
        var z;
        var mod2 = k2.andln(ws - 1);
        if (k2.isOdd()) {
          if (mod2 > (ws >> 1) - 1)
            z = (ws >> 1) - mod2;
          else
            z = mod2;
          k2.isubn(z);
        } else {
          z = 0;
        }
        naf[i2] = z;
        k2.iushrn(1);
      }
      return naf;
    }
    utils2.getNAF = getNAF2;
    function getJSF2(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils2.getJSF = getJSF2;
    function cachedProperty2(obj, name2, computer) {
      var key2 = "_" + name2;
      obj.prototype[name2] = function cachedProperty3() {
        return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
      };
    }
    utils2.cachedProperty = cachedProperty2;
    function parseBytes2(bytes2) {
      return typeof bytes2 === "string" ? utils2.toArray(bytes2, "hex") : bytes2;
    }
    utils2.parseBytes = parseBytes2;
    function intFromLE(bytes2) {
      return new BN2(bytes2, "hex", "le");
    }
    utils2.intFromLE = intFromLE;
  })(utils$m);
  var brorand = { exports: {} };
  var r$1;
  brorand.exports = function rand2(len2) {
    if (!r$1)
      r$1 = new Rand(null);
    return r$1.generate(len2);
  };
  function Rand(rand2) {
    this.rand = rand2;
  }
  brorand.exports.Rand = Rand;
  Rand.prototype.generate = function generate(len2) {
    return this._rand(len2);
  };
  Rand.prototype._rand = function _rand(n2) {
    if (this.rand.getBytes)
      return this.rand.getBytes(n2);
    var res = new Uint8Array(n2);
    for (var i2 = 0; i2 < res.length; i2++)
      res[i2] = this.rand.getByte();
    return res;
  };
  if (typeof self === "object") {
    if (self.crypto && self.crypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n2) {
        var arr = new Uint8Array(n2);
        self.crypto.getRandomValues(arr);
        return arr;
      };
    } else if (self.msCrypto && self.msCrypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n2) {
        var arr = new Uint8Array(n2);
        self.msCrypto.getRandomValues(arr);
        return arr;
      };
    } else if (typeof window === "object") {
      Rand.prototype._rand = function() {
        throw new Error("Not implemented yet");
      };
    }
  } else {
    try {
      var crypto$1 = require$$1$1;
      if (typeof crypto$1.randomBytes !== "function")
        throw new Error("Not supported");
      Rand.prototype._rand = function _rand(n2) {
        return crypto$1.randomBytes(n2);
      };
    } catch (e) {
    }
  }
  var brorandExports = brorand.exports;
  var curve$6 = {};
  var BN$e = bnExports$1;
  var utils$k = utils$m;
  var getNAF = utils$k.getNAF;
  var getJSF = utils$k.getJSF;
  var assert$j = utils$k.assert;
  function BaseCurve(type2, conf) {
    this.type = type2;
    this.p = new BN$e(conf.p, 16);
    this.red = conf.prime ? BN$e.red(conf.prime) : BN$e.mont(this.p);
    this.zero = new BN$e(0).toRed(this.red);
    this.one = new BN$e(1).toRed(this.red);
    this.two = new BN$e(2).toRed(this.red);
    this.n = conf.n && new BN$e(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) {
      this.redN = null;
    } else {
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  }
  var base$1 = BaseCurve;
  BaseCurve.prototype.point = function point2() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype.validate = function validate() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k2) {
    assert$j(p2.precomputed);
    var doubles = p2._getDoubles();
    var naf = getNAF(k2, 1, this._bitLength);
    var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
    var repr = [];
    var j;
    var nafW;
    for (j = 0; j < naf.length; j += doubles.step) {
      nafW = 0;
      for (var l = j + doubles.step - 1; l >= j; l--)
        nafW = (nafW << 1) + naf[l];
      repr.push(nafW);
    }
    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);
    for (var i2 = I; i2 > 0; i2--) {
      for (j = 0; j < repr.length; j++) {
        nafW = repr[j];
        if (nafW === i2)
          b = b.mixedAdd(doubles.points[j]);
        else if (nafW === -i2)
          b = b.mixedAdd(doubles.points[j].neg());
      }
      a = a.add(b);
    }
    return a.toP();
  };
  BaseCurve.prototype._wnafMul = function _wnafMul(p2, k2) {
    var w = 4;
    var nafPoints = p2._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
    var naf = getNAF(k2, w, this._bitLength);
    var acc = this.jpoint(null, null, null);
    for (var i2 = naf.length - 1; i2 >= 0; i2--) {
      for (var l = 0; i2 >= 0 && naf[i2] === 0; i2--)
        l++;
      if (i2 >= 0)
        l++;
      acc = acc.dblp(l);
      if (i2 < 0)
        break;
      var z = naf[i2];
      assert$j(z !== 0);
      if (p2.type === "affine") {
        if (z > 0)
          acc = acc.mixedAdd(wnd[z - 1 >> 1]);
        else
          acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
      } else {
        if (z > 0)
          acc = acc.add(wnd[z - 1 >> 1]);
        else
          acc = acc.add(wnd[-z - 1 >> 1].neg());
      }
    }
    return p2.type === "affine" ? acc.toP() : acc;
  };
  BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len2, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    var max2 = 0;
    var i2;
    var j;
    var p2;
    for (i2 = 0; i2 < len2; i2++) {
      p2 = points[i2];
      var nafPoints = p2._getNAFPoints(defW);
      wndWidth[i2] = nafPoints.wnd;
      wnd[i2] = nafPoints.points;
    }
    for (i2 = len2 - 1; i2 >= 1; i2 -= 2) {
      var a = i2 - 1;
      var b = i2;
      if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
        naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
        naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
        max2 = Math.max(naf[a].length, max2);
        max2 = Math.max(naf[b].length, max2);
        continue;
      }
      var comb = [
        points[a],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        points[b]
        /* 7 */
      ];
      if (points[a].y.cmp(points[b].y) === 0) {
        comb[1] = points[a].add(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].add(points[b].neg());
      } else {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      }
      var index = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ];
      var jsf = getJSF(coeffs[a], coeffs[b]);
      max2 = Math.max(jsf[0].length, max2);
      naf[a] = new Array(max2);
      naf[b] = new Array(max2);
      for (j = 0; j < max2; j++) {
        var ja = jsf[0][j] | 0;
        var jb = jsf[1][j] | 0;
        naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
        naf[b][j] = 0;
        wnd[a] = comb;
      }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for (i2 = max2; i2 >= 0; i2--) {
      var k2 = 0;
      while (i2 >= 0) {
        var zero3 = true;
        for (j = 0; j < len2; j++) {
          tmp[j] = naf[j][i2] | 0;
          if (tmp[j] !== 0)
            zero3 = false;
        }
        if (!zero3)
          break;
        k2++;
        i2--;
      }
      if (i2 >= 0)
        k2++;
      acc = acc.dblp(k2);
      if (i2 < 0)
        break;
      for (j = 0; j < len2; j++) {
        var z = tmp[j];
        if (z === 0)
          continue;
        else if (z > 0)
          p2 = wnd[j][z - 1 >> 1];
        else if (z < 0)
          p2 = wnd[j][-z - 1 >> 1].neg();
        if (p2.type === "affine")
          acc = acc.mixedAdd(p2);
        else
          acc = acc.add(p2);
      }
    }
    for (i2 = 0; i2 < len2; i2++)
      wnd[i2] = null;
    if (jacobianResult)
      return acc;
    else
      return acc.toP();
  };
  function BasePoint(curve2, type2) {
    this.curve = curve2;
    this.type = type2;
    this.precomputed = null;
  }
  BaseCurve.BasePoint = BasePoint;
  BasePoint.prototype.eq = function eq() {
    throw new Error("Not implemented");
  };
  BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
  };
  BaseCurve.prototype.decodePoint = function decodePoint(bytes2, enc) {
    bytes2 = utils$k.toArray(bytes2, enc);
    var len2 = this.p.byteLength();
    if ((bytes2[0] === 4 || bytes2[0] === 6 || bytes2[0] === 7) && bytes2.length - 1 === 2 * len2) {
      if (bytes2[0] === 6)
        assert$j(bytes2[bytes2.length - 1] % 2 === 0);
      else if (bytes2[0] === 7)
        assert$j(bytes2[bytes2.length - 1] % 2 === 1);
      var res = this.point(
        bytes2.slice(1, 1 + len2),
        bytes2.slice(1 + len2, 1 + 2 * len2)
      );
      return res;
    } else if ((bytes2[0] === 2 || bytes2[0] === 3) && bytes2.length - 1 === len2) {
      return this.pointFromX(bytes2.slice(1, 1 + len2), bytes2[0] === 3);
    }
    throw new Error("Unknown point format");
  };
  BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
  };
  BasePoint.prototype._encode = function _encode(compact) {
    var len2 = this.curve.p.byteLength();
    var x = this.getX().toArray("be", len2);
    if (compact)
      return [this.getY().isEven() ? 2 : 3].concat(x);
    return [4].concat(x, this.getY().toArray("be", len2));
  };
  BasePoint.prototype.encode = function encode2(enc, compact) {
    return utils$k.encode(this._encode(compact), enc);
  };
  BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed)
      return this;
    var precomputed = {
      doubles: null,
      naf: null,
      beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
  };
  BasePoint.prototype._hasDoubles = function _hasDoubles(k2) {
    if (!this.precomputed)
      return false;
    var doubles = this.precomputed.doubles;
    if (!doubles)
      return false;
    return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
  };
  BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    var doubles = [this];
    var acc = this;
    for (var i2 = 0; i2 < power; i2 += step) {
      for (var j = 0; j < step; j++)
        acc = acc.dbl();
      doubles.push(acc);
    }
    return {
      step,
      points: doubles
    };
  };
  BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    var res = [this];
    var max2 = (1 << wnd) - 1;
    var dbl = max2 === 1 ? null : this.dbl();
    for (var i2 = 1; i2 < max2; i2++)
      res[i2] = res[i2 - 1].add(dbl);
    return {
      wnd,
      points: res
    };
  };
  BasePoint.prototype._getBeta = function _getBeta() {
    return null;
  };
  BasePoint.prototype.dblp = function dblp(k2) {
    var r2 = this;
    for (var i2 = 0; i2 < k2; i2++)
      r2 = r2.dbl();
    return r2;
  };
  var utils$j = utils$m;
  var BN$d = bnExports$1;
  var inherits$e = inherits_browserExports$1;
  var Base$3 = base$1;
  var assert$i = utils$j.assert;
  function ShortCurve(conf) {
    Base$3.call(this, "short", conf);
    this.a = new BN$d(conf.a, 16).toRed(this.red);
    this.b = new BN$d(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  }
  inherits$e(ShortCurve, Base$3);
  var short = ShortCurve;
  ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
      return;
    var beta;
    var lambda;
    if (conf.beta) {
      beta = new BN$d(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p);
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda) {
      lambda = new BN$d(conf.lambda, 16);
    } else {
      var lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert$i(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }
    var basis;
    if (conf.basis) {
      basis = conf.basis.map(function(vec) {
        return {
          a: new BN$d(vec.a, 16),
          b: new BN$d(vec.b, 16)
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }
    return {
      beta,
      lambda,
      basis
    };
  };
  ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    var red = num === this.p ? this.red : BN$d.mont(num);
    var tinv = new BN$d(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s2 = new BN$d(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s2).fromRed();
    var l2 = ntinv.redSub(s2).fromRed();
    return [l1, l2];
  };
  ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    var u = lambda;
    var v = this.n.clone();
    var x1 = new BN$d(1);
    var y1 = new BN$d(0);
    var x2 = new BN$d(0);
    var y2 = new BN$d(1);
    var a0;
    var b0;
    var a1;
    var b1;
    var a2;
    var b2;
    var prevR;
    var i2 = 0;
    var r2;
    var x;
    while (u.cmpn(0) !== 0) {
      var q = v.div(u);
      r2 = v.sub(q.mul(u));
      x = x2.sub(q.mul(x1));
      var y = y2.sub(q.mul(y1));
      if (!a1 && r2.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r2.neg();
        b1 = x;
      } else if (a1 && ++i2 === 2) {
        break;
      }
      prevR = r2;
      v = u;
      u = r2;
      x2 = x1;
      x1 = x;
      y2 = y1;
      y1 = y;
    }
    a2 = r2.neg();
    b2 = x;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
      a2 = a0;
      b2 = b0;
    }
    if (a1.negative) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a2.negative) {
      a2 = a2.neg();
      b2 = b2.neg();
    }
    return [
      { a: a1, b: b1 },
      { a: a2, b: b2 }
    ];
  };
  ShortCurve.prototype._endoSplit = function _endoSplit(k2) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k2).divRound(this.n);
    var c2 = v1.b.neg().mul(k2).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    var k1 = k2.sub(p1).sub(p2);
    var k22 = q1.add(q2).neg();
    return { k1, k2: k22 };
  };
  ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN$d(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
    return this.point(x, y);
  };
  ShortCurve.prototype.validate = function validate(point2) {
    if (point2.inf)
      return true;
    var x = point2.x;
    var y = point2.y;
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
  };
  ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for (var i2 = 0; i2 < points.length; i2++) {
      var split2 = this._endoSplit(coeffs[i2]);
      var p2 = points[i2];
      var beta = p2._getBeta();
      if (split2.k1.negative) {
        split2.k1.ineg();
        p2 = p2.neg(true);
      }
      if (split2.k2.negative) {
        split2.k2.ineg();
        beta = beta.neg(true);
      }
      npoints[i2 * 2] = p2;
      npoints[i2 * 2 + 1] = beta;
      ncoeffs[i2 * 2] = split2.k1;
      ncoeffs[i2 * 2 + 1] = split2.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
    for (var j = 0; j < i2 * 2; j++) {
      npoints[j] = null;
      ncoeffs[j] = null;
    }
    return res;
  };
  function Point$6(curve2, x, y, isRed) {
    Base$3.BasePoint.call(this, curve2, "affine");
    if (x === null && y === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new BN$d(x, 16);
      this.y = new BN$d(y, 16);
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  }
  inherits$e(Point$6, Base$3.BasePoint);
  ShortCurve.prototype.point = function point2(x, y, isRed) {
    return new Point$6(this, x, y, isRed);
  };
  ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point$6.fromJSON(this, obj, red);
  };
  Point$6.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo)
      return;
    var pre = this.precomputed;
    if (pre && pre.beta)
      return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
      var curve2 = this.curve;
      var endoMul = function(p2) {
        return curve2.point(p2.x.redMul(curve2.endo.beta), p2.y);
      };
      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul)
        }
      };
    }
    return beta;
  };
  Point$6.prototype.toJSON = function toJSON() {
    if (!this.precomputed)
      return [this.x, this.y];
    return [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }];
  };
  Point$6.fromJSON = function fromJSON(curve2, obj, red) {
    if (typeof obj === "string")
      obj = JSON.parse(obj);
    var res = curve2.point(obj[0], obj[1], red);
    if (!obj[2])
      return res;
    function obj2point(obj2) {
      return curve2.point(obj2[0], obj2[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: [res].concat(pre.doubles.points.map(obj2point))
      },
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: [res].concat(pre.naf.points.map(obj2point))
      }
    };
    return res;
  };
  Point$6.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  Point$6.prototype.isInfinity = function isInfinity() {
    return this.inf;
  };
  Point$6.prototype.add = function add(p2) {
    if (this.inf)
      return p2;
    if (p2.inf)
      return this;
    if (this.eq(p2))
      return this.dbl();
    if (this.neg().eq(p2))
      return this.curve.point(null, null);
    if (this.x.cmp(p2.x) === 0)
      return this.curve.point(null, null);
    var c = this.y.redSub(p2.y);
    if (c.cmpn(0) !== 0)
      c = c.redMul(this.x.redSub(p2.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p2.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point$6.prototype.dbl = function dbl() {
    if (this.inf)
      return this;
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0)
      return this.curve.point(null, null);
    var a = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point$6.prototype.getX = function getX() {
    return this.x.fromRed();
  };
  Point$6.prototype.getY = function getY() {
    return this.y.fromRed();
  };
  Point$6.prototype.mul = function mul(k2) {
    k2 = new BN$d(k2, 16);
    if (this.isInfinity())
      return this;
    else if (this._hasDoubles(k2))
      return this.curve._fixedNafMul(this, k2);
    else if (this.curve.endo)
      return this.curve._endoWnafMulAdd([this], [k2]);
    else
      return this.curve._wnafMul(this, k2);
  };
  Point$6.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };
  Point$6.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs, true);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
  };
  Point$6.prototype.eq = function eq(p2) {
    return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
  };
  Point$6.prototype.neg = function neg(_precompute) {
    if (this.inf)
      return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
      var pre = this.precomputed;
      var negate = function(p2) {
        return p2.neg();
      };
      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate)
        }
      };
    }
    return res;
  };
  Point$6.prototype.toJ = function toJ() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };
  function JPoint(curve2, x, y, z) {
    Base$3.BasePoint.call(this, curve2, "jacobian");
    if (x === null && y === null && z === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new BN$d(0);
    } else {
      this.x = new BN$d(x, 16);
      this.y = new BN$d(y, 16);
      this.z = new BN$d(z, 16);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
  }
  inherits$e(JPoint, Base$3.BasePoint);
  ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
  };
  JPoint.prototype.toP = function toP() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
  };
  JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  JPoint.prototype.add = function add(p2) {
    if (this.isInfinity())
      return p2;
    if (p2.isInfinity())
      return this;
    var pz2 = p2.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p2.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p2.z));
    var s2 = p2.y.redMul(z2.redMul(this.z));
    var h = u1.redSub(u2);
    var r2 = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r2.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r2.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p2.z).redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mixedAdd = function mixedAdd(p2) {
    if (this.isInfinity())
      return p2.toJ();
    if (p2.isInfinity())
      return this;
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p2.x.redMul(z2);
    var s1 = this.y;
    var s2 = p2.y.redMul(z2).redMul(this.z);
    var h = u1.redSub(u2);
    var r2 = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r2.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r2.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.dblp = function dblp(pow3) {
    if (pow3 === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!pow3)
      return this.dbl();
    var i2;
    if (this.curve.zeroA || this.curve.threeA) {
      var r2 = this;
      for (i2 = 0; i2 < pow3; i2++)
        r2 = r2.dbl();
      return r2;
    }
    var a = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jyd = jy.redAdd(jy);
    for (i2 = 0; i2 < pow3; i2++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var t1 = jx.redMul(jyd2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var dny = c.redMul(t2);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i2 + 1 < pow3)
        jz4 = jz4.redMul(jyd4);
      jx = nx;
      jz = nz;
      jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };
  JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.zeroA)
      return this._zeroDbl();
    else if (this.curve.threeA)
      return this._threeDbl();
    else
      return this._dbl();
  };
  JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s2 = s2.redIAdd(s2);
      var m = xx.redAdd(xx).redIAdd(xx);
      var t = m.redSqr().redISub(s2).redISub(s2);
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      nx = t;
      ny = m.redMul(s2.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = b.redSqr();
      var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
      d = d.redIAdd(d);
      var e = a.redAdd(a).redIAdd(a);
      var f2 = e.redSqr();
      var c8 = c.redIAdd(c);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);
      nx = f2.redISub(d).redISub(d);
      ny = e.redMul(d.redISub(nx)).redISub(c8);
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s2 = s2.redIAdd(s2);
      var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
      var t = m.redSqr().redISub(s2).redISub(s2);
      nx = t;
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m.redMul(s2.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var delta = this.z.redSqr();
      var gamma = this.y.redSqr();
      var beta = this.x.redMul(gamma);
      var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha);
      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8);
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var zz = this.z.redSqr();
    var yyyy = yy.redSqr();
    var m = xx.redAdd(xx).redIAdd(xx);
    var mm = m.redSqr();
    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    var ee = e.redSqr();
    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    var yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mul = function mul(k2, kbase) {
    k2 = new BN$d(k2, kbase);
    return this.curve._wnafMul(this, k2);
  };
  JPoint.prototype.eq = function eq(p2) {
    if (p2.type === "affine")
      return this.eq(p2.toJ());
    if (this === p2)
      return true;
    var z2 = this.z.redSqr();
    var pz2 = p2.z.redSqr();
    if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
      return false;
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p2.z);
    return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
  };
  JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(zs);
    for (; ; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC JPoint Infinity>";
    return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  JPoint.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  var BN$c = bnExports$1;
  var inherits$d = inherits_browserExports$1;
  var Base$2 = base$1;
  var utils$i = utils$m;
  function MontCurve(conf) {
    Base$2.call(this, "mont", conf);
    this.a = new BN$c(conf.a, 16).toRed(this.red);
    this.b = new BN$c(conf.b, 16).toRed(this.red);
    this.i4 = new BN$c(4).toRed(this.red).redInvm();
    this.two = new BN$c(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  inherits$d(MontCurve, Base$2);
  var mont = MontCurve;
  MontCurve.prototype.validate = function validate(point2) {
    var x = point2.normalize().x;
    var x2 = x.redSqr();
    var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
    var y = rhs.redSqrt();
    return y.redSqr().cmp(rhs) === 0;
  };
  function Point$5(curve2, x, z) {
    Base$2.BasePoint.call(this, curve2, "projective");
    if (x === null && z === null) {
      this.x = this.curve.one;
      this.z = this.curve.zero;
    } else {
      this.x = new BN$c(x, 16);
      this.z = new BN$c(z, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
    }
  }
  inherits$d(Point$5, Base$2.BasePoint);
  MontCurve.prototype.decodePoint = function decodePoint(bytes2, enc) {
    return this.point(utils$i.toArray(bytes2, enc), 1);
  };
  MontCurve.prototype.point = function point2(x, z) {
    return new Point$5(this, x, z);
  };
  MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point$5.fromJSON(this, obj);
  };
  Point$5.prototype.precompute = function precompute() {
  };
  Point$5.prototype._encode = function _encode() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  };
  Point$5.fromJSON = function fromJSON(curve2, obj) {
    return new Point$5(curve2, obj[0], obj[1] || curve2.one);
  };
  Point$5.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Point$5.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  Point$5.prototype.dbl = function dbl() {
    var a = this.x.redAdd(this.z);
    var aa = a.redSqr();
    var b = this.x.redSub(this.z);
    var bb = b.redSqr();
    var c = aa.redSub(bb);
    var nx = aa.redMul(bb);
    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    return this.curve.point(nx, nz);
  };
  Point$5.prototype.add = function add() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point$5.prototype.diffAdd = function diffAdd(p2, diff) {
    var a = this.x.redAdd(this.z);
    var b = this.x.redSub(this.z);
    var c = p2.x.redAdd(p2.z);
    var d = p2.x.redSub(p2.z);
    var da = d.redMul(a);
    var cb = c.redMul(b);
    var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
  };
  Point$5.prototype.mul = function mul(k2) {
    var t = k2.clone();
    var a = this;
    var b = this.curve.point(null, null);
    var c = this;
    for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
      bits.push(t.andln(1));
    for (var i2 = bits.length - 1; i2 >= 0; i2--) {
      if (bits[i2] === 0) {
        a = a.diffAdd(b, c);
        b = b.dbl();
      } else {
        b = a.diffAdd(b, c);
        a = a.dbl();
      }
    }
    return b;
  };
  Point$5.prototype.mulAdd = function mulAdd() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point$5.prototype.jumlAdd = function jumlAdd() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point$5.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
  };
  Point$5.prototype.normalize = function normalize() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
  };
  Point$5.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  var utils$h = utils$m;
  var BN$b = bnExports$1;
  var inherits$c = inherits_browserExports$1;
  var Base$1 = base$1;
  var assert$h = utils$h.assert;
  function EdwardsCurve(conf) {
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    Base$1.call(this, "edwards", conf);
    this.a = new BN$b(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN$b(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN$b(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert$h(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
  }
  inherits$c(EdwardsCurve, Base$1);
  var edwards = EdwardsCurve;
  EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA)
      return num.redNeg();
    else
      return this.a.redMul(num);
  };
  EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC)
      return num;
    else
      return this.c.redMul(num);
  };
  EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
    return this.point(x, y, z, t);
  };
  EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN$b(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
    var x2 = x.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x2));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
    var y2 = rhs.redMul(lhs.redInvm());
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
    return this.point(x, y);
  };
  EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
    y = new BN$b(y, 16);
    if (!y.red)
      y = y.toRed(this.red);
    var y2 = y.redSqr();
    var lhs = y2.redSub(this.c2);
    var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
    var x2 = lhs.redMul(rhs.redInvm());
    if (x2.cmp(this.zero) === 0) {
      if (odd)
        throw new Error("invalid point");
      else
        return this.point(this.zero, y);
    }
    var x = x2.redSqrt();
    if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    if (x.fromRed().isOdd() !== odd)
      x = x.redNeg();
    return this.point(x, y);
  };
  EdwardsCurve.prototype.validate = function validate(point2) {
    if (point2.isInfinity())
      return true;
    point2.normalize();
    var x2 = point2.x.redSqr();
    var y2 = point2.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y2);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
    return lhs.cmp(rhs) === 0;
  };
  function Point$4(curve2, x, y, z, t) {
    Base$1.BasePoint.call(this, curve2, "projective");
    if (x === null && y === null && z === null) {
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      this.zOne = true;
    } else {
      this.x = new BN$b(x, 16);
      this.y = new BN$b(y, 16);
      this.z = z ? new BN$b(z, 16) : this.curve.one;
      this.t = t && new BN$b(t, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      if (this.t && !this.t.red)
        this.t = this.t.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
      if (this.curve.extended && !this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne)
          this.t = this.t.redMul(this.z.redInvm());
      }
    }
  }
  inherits$c(Point$4, Base$1.BasePoint);
  EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point$4.fromJSON(this, obj);
  };
  EdwardsCurve.prototype.point = function point2(x, y, z, t) {
    return new Point$4(this, x, y, z, t);
  };
  Point$4.fromJSON = function fromJSON(curve2, obj) {
    return new Point$4(curve2, obj[0], obj[1], obj[2]);
  };
  Point$4.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Point$4.prototype.isInfinity = function isInfinity() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  };
  Point$4.prototype._extDbl = function _extDbl() {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = this.z.redSqr();
    c = c.redIAdd(c);
    var d = this.curve._mulA(a);
    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
    var g2 = d.redAdd(b);
    var f2 = g2.redSub(c);
    var h = d.redSub(b);
    var nx = e.redMul(f2);
    var ny = g2.redMul(h);
    var nt = e.redMul(h);
    var nz = f2.redMul(g2);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point$4.prototype._projDbl = function _projDbl() {
    var b = this.x.redAdd(this.y).redSqr();
    var c = this.x.redSqr();
    var d = this.y.redSqr();
    var nx;
    var ny;
    var nz;
    var e;
    var h;
    var j;
    if (this.curve.twisted) {
      e = this.curve._mulA(c);
      var f2 = e.redAdd(d);
      if (this.zOne) {
        nx = b.redSub(c).redSub(d).redMul(f2.redSub(this.curve.two));
        ny = f2.redMul(e.redSub(d));
        nz = f2.redSqr().redSub(f2).redSub(f2);
      } else {
        h = this.z.redSqr();
        j = f2.redSub(h).redISub(h);
        nx = b.redSub(c).redISub(d).redMul(j);
        ny = f2.redMul(e.redSub(d));
        nz = f2.redMul(j);
      }
    } else {
      e = c.redAdd(d);
      h = this.curve._mulC(this.z).redSqr();
      j = e.redSub(h).redSub(h);
      nx = this.curve._mulC(b.redISub(e)).redMul(j);
      ny = this.curve._mulC(e).redMul(c.redISub(d));
      nz = e.redMul(j);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point$4.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extDbl();
    else
      return this._projDbl();
  };
  Point$4.prototype._extAdd = function _extAdd(p2) {
    var a = this.y.redSub(this.x).redMul(p2.y.redSub(p2.x));
    var b = this.y.redAdd(this.x).redMul(p2.y.redAdd(p2.x));
    var c = this.t.redMul(this.curve.dd).redMul(p2.t);
    var d = this.z.redMul(p2.z.redAdd(p2.z));
    var e = b.redSub(a);
    var f2 = d.redSub(c);
    var g2 = d.redAdd(c);
    var h = b.redAdd(a);
    var nx = e.redMul(f2);
    var ny = g2.redMul(h);
    var nt = e.redMul(h);
    var nz = f2.redMul(g2);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point$4.prototype._projAdd = function _projAdd(p2) {
    var a = this.z.redMul(p2.z);
    var b = a.redSqr();
    var c = this.x.redMul(p2.x);
    var d = this.y.redMul(p2.y);
    var e = this.curve.d.redMul(c).redMul(d);
    var f2 = b.redSub(e);
    var g2 = b.redAdd(e);
    var tmp = this.x.redAdd(this.y).redMul(p2.x.redAdd(p2.y)).redISub(c).redISub(d);
    var nx = a.redMul(f2).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
      ny = a.redMul(g2).redMul(d.redSub(this.curve._mulA(c)));
      nz = f2.redMul(g2);
    } else {
      ny = a.redMul(g2).redMul(d.redSub(c));
      nz = this.curve._mulC(f2).redMul(g2);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point$4.prototype.add = function add(p2) {
    if (this.isInfinity())
      return p2;
    if (p2.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extAdd(p2);
    else
      return this._projAdd(p2);
  };
  Point$4.prototype.mul = function mul(k2) {
    if (this._hasDoubles(k2))
      return this.curve._fixedNafMul(this, k2);
    else
      return this.curve._wnafMul(this, k2);
  };
  Point$4.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    return this.curve._wnafMulAdd(1, [this, p2], [k1, k2], 2, false);
  };
  Point$4.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    return this.curve._wnafMulAdd(1, [this, p2], [k1, k2], 2, true);
  };
  Point$4.prototype.normalize = function normalize() {
    if (this.zOne)
      return this;
    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t)
      this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
  };
  Point$4.prototype.neg = function neg() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  };
  Point$4.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  Point$4.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
  };
  Point$4.prototype.eq = function eq(other) {
    return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
  };
  Point$4.prototype.eqXToP = function eqXToP(x) {
    var rx = x.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(this.z);
    for (; ; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  Point$4.prototype.toP = Point$4.prototype.normalize;
  Point$4.prototype.mixedAdd = Point$4.prototype.add;
  (function(exports2) {
    var curve2 = exports2;
    curve2.base = base$1;
    curve2.short = short;
    curve2.mont = mont;
    curve2.edwards = edwards;
  })(curve$6);
  var curves$3 = {};
  var hash$6 = {};
  var utils$g = {};
  var assert$g = minimalisticAssert;
  var inherits$b = inherits_browserExports$1;
  utils$g.inherits = inherits$b;
  function isSurrogatePair(msg, i2) {
    if ((msg.charCodeAt(i2) & 64512) !== 55296) {
      return false;
    }
    if (i2 < 0 || i2 + 1 >= msg.length) {
      return false;
    }
    return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
  }
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg === "string") {
      if (!enc) {
        var p2 = 0;
        for (var i2 = 0; i2 < msg.length; i2++) {
          var c = msg.charCodeAt(i2);
          if (c < 128) {
            res[p2++] = c;
          } else if (c < 2048) {
            res[p2++] = c >> 6 | 192;
            res[p2++] = c & 63 | 128;
          } else if (isSurrogatePair(msg, i2)) {
            c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i2) & 1023);
            res[p2++] = c >> 18 | 240;
            res[p2++] = c >> 12 & 63 | 128;
            res[p2++] = c >> 6 & 63 | 128;
            res[p2++] = c & 63 | 128;
          } else {
            res[p2++] = c >> 12 | 224;
            res[p2++] = c >> 6 & 63 | 128;
            res[p2++] = c & 63 | 128;
          }
        }
      } else if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (i2 = 0; i2 < msg.length; i2 += 2)
          res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
      }
    } else {
      for (i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
    }
    return res;
  }
  utils$g.toArray = toArray;
  function toHex(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero2(msg[i2].toString(16));
    return res;
  }
  utils$g.toHex = toHex;
  function htonl(w) {
    var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
    return res >>> 0;
  }
  utils$g.htonl = htonl;
  function toHex32(msg, endian) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++) {
      var w = msg[i2];
      if (endian === "little")
        w = htonl(w);
      res += zero8(w.toString(16));
    }
    return res;
  }
  utils$g.toHex32 = toHex32;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils$g.zero2 = zero2;
  function zero8(word) {
    if (word.length === 7)
      return "0" + word;
    else if (word.length === 6)
      return "00" + word;
    else if (word.length === 5)
      return "000" + word;
    else if (word.length === 4)
      return "0000" + word;
    else if (word.length === 3)
      return "00000" + word;
    else if (word.length === 2)
      return "000000" + word;
    else if (word.length === 1)
      return "0000000" + word;
    else
      return word;
  }
  utils$g.zero8 = zero8;
  function join32(msg, start, end, endian) {
    var len2 = end - start;
    assert$g(len2 % 4 === 0);
    var res = new Array(len2 / 4);
    for (var i2 = 0, k2 = start; i2 < res.length; i2++, k2 += 4) {
      var w;
      if (endian === "big")
        w = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
      else
        w = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
      res[i2] = w >>> 0;
    }
    return res;
  }
  utils$g.join32 = join32;
  function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i2 = 0, k2 = 0; i2 < msg.length; i2++, k2 += 4) {
      var m = msg[i2];
      if (endian === "big") {
        res[k2] = m >>> 24;
        res[k2 + 1] = m >>> 16 & 255;
        res[k2 + 2] = m >>> 8 & 255;
        res[k2 + 3] = m & 255;
      } else {
        res[k2 + 3] = m >>> 24;
        res[k2 + 2] = m >>> 16 & 255;
        res[k2 + 1] = m >>> 8 & 255;
        res[k2] = m & 255;
      }
    }
    return res;
  }
  utils$g.split32 = split32;
  function rotr32$1(w, b) {
    return w >>> b | w << 32 - b;
  }
  utils$g.rotr32 = rotr32$1;
  function rotl32$2(w, b) {
    return w << b | w >>> 32 - b;
  }
  utils$g.rotl32 = rotl32$2;
  function sum32$3(a, b) {
    return a + b >>> 0;
  }
  utils$g.sum32 = sum32$3;
  function sum32_3$1(a, b, c) {
    return a + b + c >>> 0;
  }
  utils$g.sum32_3 = sum32_3$1;
  function sum32_4$2(a, b, c, d) {
    return a + b + c + d >>> 0;
  }
  utils$g.sum32_4 = sum32_4$2;
  function sum32_5$2(a, b, c, d, e) {
    return a + b + c + d + e >>> 0;
  }
  utils$g.sum32_5 = sum32_5$2;
  function sum64$1(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
  }
  utils$g.sum64 = sum64$1;
  function sum64_hi$1(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
  }
  utils$g.sum64_hi = sum64_hi$1;
  function sum64_lo$1(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
  }
  utils$g.sum64_lo = sum64_lo$1;
  function sum64_4_hi$1(ah, al, bh, bl, ch2, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch2 + dh + carry;
    return hi >>> 0;
  }
  utils$g.sum64_4_hi = sum64_4_hi$1;
  function sum64_4_lo$1(ah, al, bh, bl, ch2, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
  }
  utils$g.sum64_4_lo = sum64_4_lo$1;
  function sum64_5_hi$1(ah, al, bh, bl, ch2, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch2 + dh + eh + carry;
    return hi >>> 0;
  }
  utils$g.sum64_5_hi = sum64_5_hi$1;
  function sum64_5_lo$1(ah, al, bh, bl, ch2, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
  }
  utils$g.sum64_5_lo = sum64_5_lo$1;
  function rotr64_hi$1(ah, al, num) {
    var r2 = al << 32 - num | ah >>> num;
    return r2 >>> 0;
  }
  utils$g.rotr64_hi = rotr64_hi$1;
  function rotr64_lo$1(ah, al, num) {
    var r2 = ah << 32 - num | al >>> num;
    return r2 >>> 0;
  }
  utils$g.rotr64_lo = rotr64_lo$1;
  function shr64_hi$1(ah, al, num) {
    return ah >>> num;
  }
  utils$g.shr64_hi = shr64_hi$1;
  function shr64_lo$1(ah, al, num) {
    var r2 = ah << 32 - num | al >>> num;
    return r2 >>> 0;
  }
  utils$g.shr64_lo = shr64_lo$1;
  var common$5 = {};
  var utils$f = utils$g;
  var assert$f = minimalisticAssert;
  function BlockHash$4() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = "big";
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  }
  common$5.BlockHash = BlockHash$4;
  BlockHash$4.prototype.update = function update(msg, enc) {
    msg = utils$f.toArray(msg, enc);
    if (!this.pending)
      this.pending = msg;
    else
      this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    if (this.pending.length >= this._delta8) {
      msg = this.pending;
      var r2 = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r2, msg.length);
      if (this.pending.length === 0)
        this.pending = null;
      msg = utils$f.join32(msg, 0, msg.length - r2, this.endian);
      for (var i2 = 0; i2 < msg.length; i2 += this._delta32)
        this._update(msg, i2, i2 + this._delta32);
    }
    return this;
  };
  BlockHash$4.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert$f(this.pending === null);
    return this._digest(enc);
  };
  BlockHash$4.prototype._pad = function pad() {
    var len2 = this.pendingTotal;
    var bytes2 = this._delta8;
    var k2 = bytes2 - (len2 + this.padLength) % bytes2;
    var res = new Array(k2 + this.padLength);
    res[0] = 128;
    for (var i2 = 1; i2 < k2; i2++)
      res[i2] = 0;
    len2 <<= 3;
    if (this.endian === "big") {
      for (var t = 8; t < this.padLength; t++)
        res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = len2 >>> 24 & 255;
      res[i2++] = len2 >>> 16 & 255;
      res[i2++] = len2 >>> 8 & 255;
      res[i2++] = len2 & 255;
    } else {
      res[i2++] = len2 & 255;
      res[i2++] = len2 >>> 8 & 255;
      res[i2++] = len2 >>> 16 & 255;
      res[i2++] = len2 >>> 24 & 255;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      for (t = 8; t < this.padLength; t++)
        res[i2++] = 0;
    }
    return res;
  };
  var sha$2 = {};
  var common$4 = {};
  var utils$e = utils$g;
  var rotr32 = utils$e.rotr32;
  function ft_1$1(s2, x, y, z) {
    if (s2 === 0)
      return ch32$1(x, y, z);
    if (s2 === 1 || s2 === 3)
      return p32(x, y, z);
    if (s2 === 2)
      return maj32$1(x, y, z);
  }
  common$4.ft_1 = ft_1$1;
  function ch32$1(x, y, z) {
    return x & y ^ ~x & z;
  }
  common$4.ch32 = ch32$1;
  function maj32$1(x, y, z) {
    return x & y ^ x & z ^ y & z;
  }
  common$4.maj32 = maj32$1;
  function p32(x, y, z) {
    return x ^ y ^ z;
  }
  common$4.p32 = p32;
  function s0_256$1(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
  }
  common$4.s0_256 = s0_256$1;
  function s1_256$1(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
  }
  common$4.s1_256 = s1_256$1;
  function g0_256$1(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
  }
  common$4.g0_256 = g0_256$1;
  function g1_256$1(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
  }
  common$4.g1_256 = g1_256$1;
  var utils$d = utils$g;
  var common$3 = common$5;
  var shaCommon$1 = common$4;
  var rotl32$1 = utils$d.rotl32;
  var sum32$2 = utils$d.sum32;
  var sum32_5$1 = utils$d.sum32_5;
  var ft_1 = shaCommon$1.ft_1;
  var BlockHash$3 = common$3.BlockHash;
  var sha1_K = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function SHA1() {
    if (!(this instanceof SHA1))
      return new SHA1();
    BlockHash$3.call(this);
    this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ];
    this.W = new Array(80);
  }
  utils$d.inherits(SHA1, BlockHash$3);
  var _1 = SHA1;
  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;
  SHA1.prototype._update = function _update(msg, start) {
    var W2 = this.W;
    for (var i2 = 0; i2 < 16; i2++)
      W2[i2] = msg[start + i2];
    for (; i2 < W2.length; i2++)
      W2[i2] = rotl32$1(W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16], 1);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for (i2 = 0; i2 < W2.length; i2++) {
      var s2 = ~~(i2 / 20);
      var t = sum32_5$1(rotl32$1(a, 5), ft_1(s2, b, c, d), e, W2[i2], sha1_K[s2]);
      e = d;
      d = c;
      c = rotl32$1(b, 30);
      b = a;
      a = t;
    }
    this.h[0] = sum32$2(this.h[0], a);
    this.h[1] = sum32$2(this.h[1], b);
    this.h[2] = sum32$2(this.h[2], c);
    this.h[3] = sum32$2(this.h[3], d);
    this.h[4] = sum32$2(this.h[4], e);
  };
  SHA1.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$d.toHex32(this.h, "big");
    else
      return utils$d.split32(this.h, "big");
  };
  var utils$c = utils$g;
  var common$2 = common$5;
  var shaCommon = common$4;
  var assert$e = minimalisticAssert;
  var sum32$1 = utils$c.sum32;
  var sum32_4$1 = utils$c.sum32_4;
  var sum32_5 = utils$c.sum32_5;
  var ch32 = shaCommon.ch32;
  var maj32 = shaCommon.maj32;
  var s0_256 = shaCommon.s0_256;
  var s1_256 = shaCommon.s1_256;
  var g0_256 = shaCommon.g0_256;
  var g1_256 = shaCommon.g1_256;
  var BlockHash$2 = common$2.BlockHash;
  var sha256_K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function SHA256$1() {
    if (!(this instanceof SHA256$1))
      return new SHA256$1();
    BlockHash$2.call(this);
    this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ];
    this.k = sha256_K;
    this.W = new Array(64);
  }
  utils$c.inherits(SHA256$1, BlockHash$2);
  var _256 = SHA256$1;
  SHA256$1.blockSize = 512;
  SHA256$1.outSize = 256;
  SHA256$1.hmacStrength = 192;
  SHA256$1.padLength = 64;
  SHA256$1.prototype._update = function _update(msg, start) {
    var W2 = this.W;
    for (var i2 = 0; i2 < 16; i2++)
      W2[i2] = msg[start + i2];
    for (; i2 < W2.length; i2++)
      W2[i2] = sum32_4$1(g1_256(W2[i2 - 2]), W2[i2 - 7], g0_256(W2[i2 - 15]), W2[i2 - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f2 = this.h[5];
    var g2 = this.h[6];
    var h = this.h[7];
    assert$e(this.k.length === W2.length);
    for (i2 = 0; i2 < W2.length; i2++) {
      var T1 = sum32_5(h, s1_256(e), ch32(e, f2, g2), this.k[i2], W2[i2]);
      var T2 = sum32$1(s0_256(a), maj32(a, b, c));
      h = g2;
      g2 = f2;
      f2 = e;
      e = sum32$1(d, T1);
      d = c;
      c = b;
      b = a;
      a = sum32$1(T1, T2);
    }
    this.h[0] = sum32$1(this.h[0], a);
    this.h[1] = sum32$1(this.h[1], b);
    this.h[2] = sum32$1(this.h[2], c);
    this.h[3] = sum32$1(this.h[3], d);
    this.h[4] = sum32$1(this.h[4], e);
    this.h[5] = sum32$1(this.h[5], f2);
    this.h[6] = sum32$1(this.h[6], g2);
    this.h[7] = sum32$1(this.h[7], h);
  };
  SHA256$1.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$c.toHex32(this.h, "big");
    else
      return utils$c.split32(this.h, "big");
  };
  var utils$b = utils$g;
  var SHA256 = _256;
  function SHA224() {
    if (!(this instanceof SHA224))
      return new SHA224();
    SHA256.call(this);
    this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  utils$b.inherits(SHA224, SHA256);
  var _224 = SHA224;
  SHA224.blockSize = 512;
  SHA224.outSize = 224;
  SHA224.hmacStrength = 192;
  SHA224.padLength = 64;
  SHA224.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$b.toHex32(this.h.slice(0, 7), "big");
    else
      return utils$b.split32(this.h.slice(0, 7), "big");
  };
  var utils$a = utils$g;
  var common$1 = common$5;
  var assert$d = minimalisticAssert;
  var rotr64_hi = utils$a.rotr64_hi;
  var rotr64_lo = utils$a.rotr64_lo;
  var shr64_hi = utils$a.shr64_hi;
  var shr64_lo = utils$a.shr64_lo;
  var sum64 = utils$a.sum64;
  var sum64_hi = utils$a.sum64_hi;
  var sum64_lo = utils$a.sum64_lo;
  var sum64_4_hi = utils$a.sum64_4_hi;
  var sum64_4_lo = utils$a.sum64_4_lo;
  var sum64_5_hi = utils$a.sum64_5_hi;
  var sum64_5_lo = utils$a.sum64_5_lo;
  var BlockHash$1 = common$1.BlockHash;
  var sha512_K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function SHA512$2() {
    if (!(this instanceof SHA512$2))
      return new SHA512$2();
    BlockHash$1.call(this);
    this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ];
    this.k = sha512_K;
    this.W = new Array(160);
  }
  utils$a.inherits(SHA512$2, BlockHash$1);
  var _512 = SHA512$2;
  SHA512$2.blockSize = 1024;
  SHA512$2.outSize = 512;
  SHA512$2.hmacStrength = 192;
  SHA512$2.padLength = 128;
  SHA512$2.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W2 = this.W;
    for (var i2 = 0; i2 < 32; i2++)
      W2[i2] = msg[start + i2];
    for (; i2 < W2.length; i2 += 2) {
      var c0_hi = g1_512_hi(W2[i2 - 4], W2[i2 - 3]);
      var c0_lo = g1_512_lo(W2[i2 - 4], W2[i2 - 3]);
      var c1_hi = W2[i2 - 14];
      var c1_lo = W2[i2 - 13];
      var c2_hi = g0_512_hi(W2[i2 - 30], W2[i2 - 29]);
      var c2_lo = g0_512_lo(W2[i2 - 30], W2[i2 - 29]);
      var c3_hi = W2[i2 - 32];
      var c3_lo = W2[i2 - 31];
      W2[i2] = sum64_4_hi(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo
      );
      W2[i2 + 1] = sum64_4_lo(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo
      );
    }
  };
  SHA512$2.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W2 = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch2 = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl2 = this.h[15];
    assert$d(this.k.length === W2.length);
    for (var i2 = 0; i2 < W2.length; i2 += 2) {
      var c0_hi = hh;
      var c0_lo = hl2;
      var c1_hi = s1_512_hi(eh, el);
      var c1_lo = s1_512_lo(eh, el);
      var c2_hi = ch64_hi(eh, el, fh, fl, gh);
      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      var c3_hi = this.k[i2];
      var c3_lo = this.k[i2 + 1];
      var c4_hi = W2[i2];
      var c4_lo = W2[i2 + 1];
      var T1_hi = sum64_5_hi(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo,
        c4_hi,
        c4_lo
      );
      var T1_lo = sum64_5_lo(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo,
        c4_hi,
        c4_lo
      );
      c0_hi = s0_512_hi(ah, al);
      c0_lo = s0_512_lo(ah, al);
      c1_hi = maj64_hi(ah, al, bh, bl, ch2);
      c1_lo = maj64_lo(ah, al, bh, bl, ch2, cl);
      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
      hh = gh;
      hl2 = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);
      dh = ch2;
      dl = cl;
      ch2 = bh;
      cl = bl;
      bh = ah;
      bl = al;
      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch2, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl2);
  };
  SHA512$2.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$a.toHex32(this.h, "big");
    else
      return utils$a.split32(this.h, "big");
  };
  function ch64_hi(xh, xl, yh, yl, zh) {
    var r2 = xh & yh ^ ~xh & zh;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function ch64_lo(xh, xl, yh, yl, zh, zl2) {
    var r2 = xl & yl ^ ~xl & zl2;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function maj64_hi(xh, xl, yh, yl, zh) {
    var r2 = xh & yh ^ xh & zh ^ yh & zh;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function maj64_lo(xh, xl, yh, yl, zh, zl2) {
    var r2 = xl & yl ^ xl & zl2 ^ yl & zl2;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2);
    var c2_hi = rotr64_hi(xl, xh, 7);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2);
    var c2_lo = rotr64_lo(xl, xh, 7);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29);
    var c2_hi = shr64_hi(xh, xl, 6);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29);
    var c2_lo = shr64_lo(xh, xl, 6);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  var utils$9 = utils$g;
  var SHA512$1 = _512;
  function SHA384() {
    if (!(this instanceof SHA384))
      return new SHA384();
    SHA512$1.call(this);
    this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  utils$9.inherits(SHA384, SHA512$1);
  var _384 = SHA384;
  SHA384.blockSize = 1024;
  SHA384.outSize = 384;
  SHA384.hmacStrength = 192;
  SHA384.padLength = 128;
  SHA384.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$9.toHex32(this.h.slice(0, 12), "big");
    else
      return utils$9.split32(this.h.slice(0, 12), "big");
  };
  sha$2.sha1 = _1;
  sha$2.sha224 = _224;
  sha$2.sha256 = _256;
  sha$2.sha384 = _384;
  sha$2.sha512 = _512;
  var ripemd = {};
  var utils$8 = utils$g;
  var common = common$5;
  var rotl32 = utils$8.rotl32;
  var sum32 = utils$8.sum32;
  var sum32_3 = utils$8.sum32_3;
  var sum32_4 = utils$8.sum32_4;
  var BlockHash = common.BlockHash;
  function RIPEMD160$2() {
    if (!(this instanceof RIPEMD160$2))
      return new RIPEMD160$2();
    BlockHash.call(this);
    this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    this.endian = "little";
  }
  utils$8.inherits(RIPEMD160$2, BlockHash);
  ripemd.ripemd160 = RIPEMD160$2;
  RIPEMD160$2.blockSize = 512;
  RIPEMD160$2.outSize = 160;
  RIPEMD160$2.hmacStrength = 192;
  RIPEMD160$2.padLength = 64;
  RIPEMD160$2.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch2 = C;
    var Dh = D;
    var Eh = E;
    for (var j = 0; j < 80; j++) {
      var T = sum32(
        rotl32(
          sum32_4(A, f(j, B, C, D), msg[r[j] + start], K$4(j)),
          s[j]
        ),
        E
      );
      A = E;
      E = D;
      D = rotl32(C, 10);
      C = B;
      B = T;
      T = sum32(
        rotl32(
          sum32_4(Ah, f(79 - j, Bh, Ch2, Dh), msg[rh[j] + start], Kh(j)),
          sh[j]
        ),
        Eh
      );
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch2, 10);
      Ch2 = Bh;
      Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch2);
    this.h[0] = T;
  };
  RIPEMD160$2.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$8.toHex32(this.h, "little");
    else
      return utils$8.split32(this.h, "little");
  };
  function f(j, x, y, z) {
    if (j <= 15)
      return x ^ y ^ z;
    else if (j <= 31)
      return x & y | ~x & z;
    else if (j <= 47)
      return (x | ~y) ^ z;
    else if (j <= 63)
      return x & z | y & ~z;
    else
      return x ^ (y | ~z);
  }
  function K$4(j) {
    if (j <= 15)
      return 0;
    else if (j <= 31)
      return 1518500249;
    else if (j <= 47)
      return 1859775393;
    else if (j <= 63)
      return 2400959708;
    else
      return 2840853838;
  }
  function Kh(j) {
    if (j <= 15)
      return 1352829926;
    else if (j <= 31)
      return 1548603684;
    else if (j <= 47)
      return 1836072691;
    else if (j <= 63)
      return 2053994217;
    else
      return 0;
  }
  var r = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ];
  var rh = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ];
  var s = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ];
  var sh = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  var utils$7 = utils$g;
  var assert$c = minimalisticAssert;
  function Hmac(hash2, key2, enc) {
    if (!(this instanceof Hmac))
      return new Hmac(hash2, key2, enc);
    this.Hash = hash2;
    this.blockSize = hash2.blockSize / 8;
    this.outSize = hash2.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils$7.toArray(key2, enc));
  }
  var hmac = Hmac;
  Hmac.prototype._init = function init(key2) {
    if (key2.length > this.blockSize)
      key2 = new this.Hash().update(key2).digest();
    assert$c(key2.length <= this.blockSize);
    for (var i2 = key2.length; i2 < this.blockSize; i2++)
      key2.push(0);
    for (i2 = 0; i2 < key2.length; i2++)
      key2[i2] ^= 54;
    this.inner = new this.Hash().update(key2);
    for (i2 = 0; i2 < key2.length; i2++)
      key2[i2] ^= 106;
    this.outer = new this.Hash().update(key2);
  };
  Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };
  Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };
  (function(exports2) {
    var hash2 = exports2;
    hash2.utils = utils$g;
    hash2.common = common$5;
    hash2.sha = sha$2;
    hash2.ripemd = ripemd;
    hash2.hmac = hmac;
    hash2.sha1 = hash2.sha.sha1;
    hash2.sha256 = hash2.sha.sha256;
    hash2.sha224 = hash2.sha.sha224;
    hash2.sha384 = hash2.sha.sha384;
    hash2.sha512 = hash2.sha.sha512;
    hash2.ripemd160 = hash2.ripemd.ripemd160;
  })(hash$6);
  var secp256k1$2;
  var hasRequiredSecp256k1;
  function requireSecp256k1() {
    if (hasRequiredSecp256k1)
      return secp256k1$2;
    hasRequiredSecp256k1 = 1;
    secp256k1$2 = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
    return secp256k1$2;
  }
  (function(exports2) {
    var curves2 = exports2;
    var hash2 = hash$6;
    var curve2 = curve$6;
    var utils2 = utils$m;
    var assert2 = utils2.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve2.short(options);
      else if (options.type === "edwards")
        this.curve = new curve2.edwards(options);
      else
        this.curve = new curve2.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert2(this.g.validate(), "Invalid curve");
      assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves2.PresetCurve = PresetCurve;
    function defineCurve(name2, options) {
      Object.defineProperty(curves2, name2, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve3 = new PresetCurve(options);
          Object.defineProperty(curves2, name2, {
            configurable: true,
            enumerable: true,
            value: curve3
          });
          return curve3;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash2.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash2.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = requireSecp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash2.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  })(curves$3);
  var hash$5 = hash$6;
  var utils$6 = utils$l;
  var assert$b = minimalisticAssert;
  function HmacDRBG$1(options) {
    if (!(this instanceof HmacDRBG$1))
      return new HmacDRBG$1(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils$6.toArray(options.entropy, options.entropyEnc || "hex");
    var nonce = utils$6.toArray(options.nonce, options.nonceEnc || "hex");
    var pers = utils$6.toArray(options.pers, options.persEnc || "hex");
    assert$b(
      entropy.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    );
    this._init(entropy, nonce, pers);
  }
  var hmacDrbg = HmacDRBG$1;
  HmacDRBG$1.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for (var i2 = 0; i2 < this.V.length; i2++) {
      this.K[i2] = 0;
      this.V[i2] = 1;
    }
    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 281474976710656;
  };
  HmacDRBG$1.prototype._hmac = function hmac2() {
    return new hash$5.hmac(this.hash, this.K);
  };
  HmacDRBG$1.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([0]);
    if (seed)
      kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed)
      return;
    this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
  };
  HmacDRBG$1.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    if (typeof entropyEnc !== "string") {
      addEnc = add;
      add = entropyEnc;
      entropyEnc = null;
    }
    entropy = utils$6.toArray(entropy, entropyEnc);
    add = utils$6.toArray(add, addEnc);
    assert$b(
      entropy.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    );
    this._update(entropy.concat(add || []));
    this._reseed = 1;
  };
  HmacDRBG$1.prototype.generate = function generate(len2, enc, add, addEnc) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    if (typeof enc !== "string") {
      addEnc = add;
      add = enc;
      enc = null;
    }
    if (add) {
      add = utils$6.toArray(add, addEnc || "hex");
      this._update(add);
    }
    var temp = [];
    while (temp.length < len2) {
      this.V = this._hmac().update(this.V).digest();
      temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len2);
    this._update(add);
    this._reseed++;
    return utils$6.encode(res, enc);
  };
  var BN$a = bnExports$1;
  var utils$5 = utils$m;
  var assert$a = utils$5.assert;
  function KeyPair$3(ec2, options) {
    this.ec = ec2;
    this.priv = null;
    this.pub = null;
    if (options.priv)
      this._importPrivate(options.priv, options.privEnc);
    if (options.pub)
      this._importPublic(options.pub, options.pubEnc);
  }
  var key$1 = KeyPair$3;
  KeyPair$3.fromPublic = function fromPublic(ec2, pub, enc) {
    if (pub instanceof KeyPair$3)
      return pub;
    return new KeyPair$3(ec2, {
      pub,
      pubEnc: enc
    });
  };
  KeyPair$3.fromPrivate = function fromPrivate(ec2, priv, enc) {
    if (priv instanceof KeyPair$3)
      return priv;
    return new KeyPair$3(ec2, {
      priv,
      privEnc: enc
    });
  };
  KeyPair$3.prototype.validate = function validate() {
    var pub = this.getPublic();
    if (pub.isInfinity())
      return { result: false, reason: "Invalid public key" };
    if (!pub.validate())
      return { result: false, reason: "Public key is not a point" };
    if (!pub.mul(this.ec.curve.n).isInfinity())
      return { result: false, reason: "Public key * N != O" };
    return { result: true, reason: null };
  };
  KeyPair$3.prototype.getPublic = function getPublic(compact, enc) {
    if (typeof compact === "string") {
      enc = compact;
      compact = null;
    }
    if (!this.pub)
      this.pub = this.ec.g.mul(this.priv);
    if (!enc)
      return this.pub;
    return this.pub.encode(enc, compact);
  };
  KeyPair$3.prototype.getPrivate = function getPrivate(enc) {
    if (enc === "hex")
      return this.priv.toString(16, 2);
    else
      return this.priv;
  };
  KeyPair$3.prototype._importPrivate = function _importPrivate(key2, enc) {
    this.priv = new BN$a(key2, enc || 16);
    this.priv = this.priv.umod(this.ec.curve.n);
  };
  KeyPair$3.prototype._importPublic = function _importPublic(key2, enc) {
    if (key2.x || key2.y) {
      if (this.ec.curve.type === "mont") {
        assert$a(key2.x, "Need x coordinate");
      } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
        assert$a(key2.x && key2.y, "Need both x and y coordinate");
      }
      this.pub = this.ec.curve.point(key2.x, key2.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(key2, enc);
  };
  KeyPair$3.prototype.derive = function derive(pub) {
    if (!pub.validate()) {
      assert$a(pub.validate(), "public point not validated");
    }
    return pub.mul(this.priv).getX();
  };
  KeyPair$3.prototype.sign = function sign2(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
  };
  KeyPair$3.prototype.verify = function verify2(msg, signature2) {
    return this.ec.verify(msg, signature2, this);
  };
  KeyPair$3.prototype.inspect = function inspect() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
  var BN$9 = bnExports$1;
  var utils$4 = utils$m;
  var assert$9 = utils$4.assert;
  function Signature$5(options, enc) {
    if (options instanceof Signature$5)
      return options;
    if (this._importDER(options, enc))
      return;
    assert$9(options.r && options.s, "Signature without r or s");
    this.r = new BN$9(options.r, 16);
    this.s = new BN$9(options.s, 16);
    if (options.recoveryParam === void 0)
      this.recoveryParam = null;
    else
      this.recoveryParam = options.recoveryParam;
  }
  var signature$4 = Signature$5;
  function Position() {
    this.place = 0;
  }
  function getLength$1(buf, p2) {
    var initial = buf[p2.place++];
    if (!(initial & 128)) {
      return initial;
    }
    var octetLen = initial & 15;
    if (octetLen === 0 || octetLen > 4) {
      return false;
    }
    var val = 0;
    for (var i2 = 0, off = p2.place; i2 < octetLen; i2++, off++) {
      val <<= 8;
      val |= buf[off];
      val >>>= 0;
    }
    if (val <= 127) {
      return false;
    }
    p2.place = off;
    return val;
  }
  function rmPadding(buf) {
    var i2 = 0;
    var len2 = buf.length - 1;
    while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len2) {
      i2++;
    }
    if (i2 === 0) {
      return buf;
    }
    return buf.slice(i2);
  }
  Signature$5.prototype._importDER = function _importDER(data2, enc) {
    data2 = utils$4.toArray(data2, enc);
    var p2 = new Position();
    if (data2[p2.place++] !== 48) {
      return false;
    }
    var len2 = getLength$1(data2, p2);
    if (len2 === false) {
      return false;
    }
    if (len2 + p2.place !== data2.length) {
      return false;
    }
    if (data2[p2.place++] !== 2) {
      return false;
    }
    var rlen = getLength$1(data2, p2);
    if (rlen === false) {
      return false;
    }
    var r2 = data2.slice(p2.place, rlen + p2.place);
    p2.place += rlen;
    if (data2[p2.place++] !== 2) {
      return false;
    }
    var slen = getLength$1(data2, p2);
    if (slen === false) {
      return false;
    }
    if (data2.length !== slen + p2.place) {
      return false;
    }
    var s2 = data2.slice(p2.place, slen + p2.place);
    if (r2[0] === 0) {
      if (r2[1] & 128) {
        r2 = r2.slice(1);
      } else {
        return false;
      }
    }
    if (s2[0] === 0) {
      if (s2[1] & 128) {
        s2 = s2.slice(1);
      } else {
        return false;
      }
    }
    this.r = new BN$9(r2);
    this.s = new BN$9(s2);
    this.recoveryParam = null;
    return true;
  };
  function constructLength(arr, len2) {
    if (len2 < 128) {
      arr.push(len2);
      return;
    }
    var octets = 1 + (Math.log(len2) / Math.LN2 >>> 3);
    arr.push(octets | 128);
    while (--octets) {
      arr.push(len2 >>> (octets << 3) & 255);
    }
    arr.push(len2);
  }
  Signature$5.prototype.toDER = function toDER(enc) {
    var r2 = this.r.toArray();
    var s2 = this.s.toArray();
    if (r2[0] & 128)
      r2 = [0].concat(r2);
    if (s2[0] & 128)
      s2 = [0].concat(s2);
    r2 = rmPadding(r2);
    s2 = rmPadding(s2);
    while (!s2[0] && !(s2[1] & 128)) {
      s2 = s2.slice(1);
    }
    var arr = [2];
    constructLength(arr, r2.length);
    arr = arr.concat(r2);
    arr.push(2);
    constructLength(arr, s2.length);
    var backHalf = arr.concat(s2);
    var res = [48];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils$4.encode(res, enc);
  };
  var BN$8 = bnExports$1;
  var HmacDRBG = hmacDrbg;
  var utils$3 = utils$m;
  var curves$2 = curves$3;
  var rand = brorandExports;
  var assert$8 = utils$3.assert;
  var KeyPair$2 = key$1;
  var Signature$4 = signature$4;
  function EC$2(options) {
    if (!(this instanceof EC$2))
      return new EC$2(options);
    if (typeof options === "string") {
      assert$8(
        Object.prototype.hasOwnProperty.call(curves$2, options),
        "Unknown curve " + options
      );
      options = curves$2[options];
    }
    if (options instanceof curves$2.PresetCurve)
      options = { curve: options };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    this.hash = options.hash || options.curve.hash;
  }
  var ec$2 = EC$2;
  EC$2.prototype.keyPair = function keyPair(options) {
    return new KeyPair$2(this, options);
  };
  EC$2.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair$2.fromPrivate(this, priv, enc);
  };
  EC$2.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair$2.fromPublic(this, pub, enc);
  };
  EC$2.prototype.genKeyPair = function genKeyPair(options) {
    if (!options)
      options = {};
    var drbg = new HmacDRBG({
      hash: this.hash,
      pers: options.pers,
      persEnc: options.persEnc || "utf8",
      entropy: options.entropy || rand(this.hash.hmacStrength),
      entropyEnc: options.entropy && options.entropyEnc || "utf8",
      nonce: this.n.toArray()
    });
    var bytes2 = this.n.byteLength();
    var ns2 = this.n.sub(new BN$8(2));
    for (; ; ) {
      var priv = new BN$8(drbg.generate(bytes2));
      if (priv.cmp(ns2) > 0)
        continue;
      priv.iaddn(1);
      return this.keyFromPrivate(priv);
    }
  };
  EC$2.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0)
      msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };
  EC$2.prototype.sign = function sign2(msg, key2, enc, options) {
    if (typeof enc === "object") {
      options = enc;
      enc = null;
    }
    if (!options)
      options = {};
    key2 = this.keyFromPrivate(key2, enc);
    msg = this._truncateToN(new BN$8(msg, 16));
    var bytes2 = this.n.byteLength();
    var bkey = key2.getPrivate().toArray("be", bytes2);
    var nonce = msg.toArray("be", bytes2);
    var drbg = new HmacDRBG({
      hash: this.hash,
      entropy: bkey,
      nonce,
      pers: options.pers,
      persEnc: options.persEnc || "utf8"
    });
    var ns1 = this.n.sub(new BN$8(1));
    for (var iter = 0; ; iter++) {
      var k2 = options.k ? options.k(iter) : new BN$8(drbg.generate(this.n.byteLength()));
      k2 = this._truncateToN(k2, true);
      if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
        continue;
      var kp = this.g.mul(k2);
      if (kp.isInfinity())
        continue;
      var kpX = kp.getX();
      var r2 = kpX.umod(this.n);
      if (r2.cmpn(0) === 0)
        continue;
      var s2 = k2.invm(this.n).mul(r2.mul(key2.getPrivate()).iadd(msg));
      s2 = s2.umod(this.n);
      if (s2.cmpn(0) === 0)
        continue;
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
      if (options.canonical && s2.cmp(this.nh) > 0) {
        s2 = this.n.sub(s2);
        recoveryParam ^= 1;
      }
      return new Signature$4({ r: r2, s: s2, recoveryParam });
    }
  };
  EC$2.prototype.verify = function verify2(msg, signature2, key2, enc) {
    msg = this._truncateToN(new BN$8(msg, 16));
    key2 = this.keyFromPublic(key2, enc);
    signature2 = new Signature$4(signature2, "hex");
    var r2 = signature2.r;
    var s2 = signature2.s;
    if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
      return false;
    if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
      return false;
    var sinv = s2.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r2).umod(this.n);
    var p2;
    if (!this.curve._maxwellTrick) {
      p2 = this.g.mulAdd(u1, key2.getPublic(), u2);
      if (p2.isInfinity())
        return false;
      return p2.getX().umod(this.n).cmp(r2) === 0;
    }
    p2 = this.g.jmulAdd(u1, key2.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.eqXToP(r2);
  };
  EC$2.prototype.recoverPubKey = function(msg, signature2, j, enc) {
    assert$8((3 & j) === j, "The recovery param is more than two bits");
    signature2 = new Signature$4(signature2, enc);
    var n2 = this.n;
    var e = new BN$8(msg);
    var r2 = signature2.r;
    var s2 = signature2.s;
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
      throw new Error("Unable to find sencond key candinate");
    if (isSecondKey)
      r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
    else
      r2 = this.curve.pointFromX(r2, isYOdd);
    var rInv = signature2.r.invm(n2);
    var s1 = n2.sub(e).mul(rInv).umod(n2);
    var s22 = s2.mul(rInv).umod(n2);
    return this.g.mulAdd(s1, r2, s22);
  };
  EC$2.prototype.getKeyRecoveryParam = function(e, signature2, Q, enc) {
    signature2 = new Signature$4(signature2, enc);
    if (signature2.recoveryParam !== null)
      return signature2.recoveryParam;
    for (var i2 = 0; i2 < 4; i2++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e, signature2, i2);
      } catch (e2) {
        continue;
      }
      if (Qprime.eq(Q))
        return i2;
    }
    throw new Error("Unable to find valid recovery factor");
  };
  var utils$2 = utils$m;
  var assert$7 = utils$2.assert;
  var parseBytes$2 = utils$2.parseBytes;
  var cachedProperty$1 = utils$2.cachedProperty;
  function KeyPair$1(eddsa2, params) {
    this.eddsa = eddsa2;
    this._secret = parseBytes$2(params.secret);
    if (eddsa2.isPoint(params.pub))
      this._pub = params.pub;
    else
      this._pubBytes = parseBytes$2(params.pub);
  }
  KeyPair$1.fromPublic = function fromPublic(eddsa2, pub) {
    if (pub instanceof KeyPair$1)
      return pub;
    return new KeyPair$1(eddsa2, { pub });
  };
  KeyPair$1.fromSecret = function fromSecret(eddsa2, secret) {
    if (secret instanceof KeyPair$1)
      return secret;
    return new KeyPair$1(eddsa2, { secret });
  };
  KeyPair$1.prototype.secret = function secret() {
    return this._secret;
  };
  cachedProperty$1(KeyPair$1, "pubBytes", function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
  });
  cachedProperty$1(KeyPair$1, "pub", function pub() {
    if (this._pubBytes)
      return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
  });
  cachedProperty$1(KeyPair$1, "privBytes", function privBytes() {
    var eddsa2 = this.eddsa;
    var hash2 = this.hash();
    var lastIx = eddsa2.encodingLength - 1;
    var a = hash2.slice(0, eddsa2.encodingLength);
    a[0] &= 248;
    a[lastIx] &= 127;
    a[lastIx] |= 64;
    return a;
  });
  cachedProperty$1(KeyPair$1, "priv", function priv() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  cachedProperty$1(KeyPair$1, "hash", function hash2() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  cachedProperty$1(KeyPair$1, "messagePrefix", function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  KeyPair$1.prototype.sign = function sign2(message2) {
    assert$7(this._secret, "KeyPair can only verify");
    return this.eddsa.sign(message2, this);
  };
  KeyPair$1.prototype.verify = function verify2(message2, sig) {
    return this.eddsa.verify(message2, sig, this);
  };
  KeyPair$1.prototype.getSecret = function getSecret(enc) {
    assert$7(this._secret, "KeyPair is public only");
    return utils$2.encode(this.secret(), enc);
  };
  KeyPair$1.prototype.getPublic = function getPublic(enc) {
    return utils$2.encode(this.pubBytes(), enc);
  };
  var key = KeyPair$1;
  var BN$7 = bnExports$1;
  var utils$1 = utils$m;
  var assert$6 = utils$1.assert;
  var cachedProperty = utils$1.cachedProperty;
  var parseBytes$1 = utils$1.parseBytes;
  function Signature$3(eddsa2, sig) {
    this.eddsa = eddsa2;
    if (typeof sig !== "object")
      sig = parseBytes$1(sig);
    if (Array.isArray(sig)) {
      sig = {
        R: sig.slice(0, eddsa2.encodingLength),
        S: sig.slice(eddsa2.encodingLength)
      };
    }
    assert$6(sig.R && sig.S, "Signature without R or S");
    if (eddsa2.isPoint(sig.R))
      this._R = sig.R;
    if (sig.S instanceof BN$7)
      this._S = sig.S;
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
  }
  cachedProperty(Signature$3, "S", function S() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  cachedProperty(Signature$3, "R", function R() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  cachedProperty(Signature$3, "Rencoded", function Rencoded() {
    return this.eddsa.encodePoint(this.R());
  });
  cachedProperty(Signature$3, "Sencoded", function Sencoded() {
    return this.eddsa.encodeInt(this.S());
  });
  Signature$3.prototype.toBytes = function toBytes2() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Signature$3.prototype.toHex = function toHex2() {
    return utils$1.encode(this.toBytes(), "hex").toUpperCase();
  };
  var signature$3 = Signature$3;
  var hash$4 = hash$6;
  var curves$1 = curves$3;
  var utils = utils$m;
  var assert$5 = utils.assert;
  var parseBytes = utils.parseBytes;
  var KeyPair = key;
  var Signature$2 = signature$3;
  function EDDSA(curve2) {
    assert$5(curve2 === "ed25519", "only tested with ed25519 so far");
    if (!(this instanceof EDDSA))
      return new EDDSA(curve2);
    curve2 = curves$1[curve2].curve;
    this.curve = curve2;
    this.g = curve2.g;
    this.g.precompute(curve2.n.bitLength() + 1);
    this.pointClass = curve2.point().constructor;
    this.encodingLength = Math.ceil(curve2.n.bitLength() / 8);
    this.hash = hash$4.sha512;
  }
  var eddsa = EDDSA;
  EDDSA.prototype.sign = function sign2(message2, secret) {
    message2 = parseBytes(message2);
    var key2 = this.keyFromSecret(secret);
    var r2 = this.hashInt(key2.messagePrefix(), message2);
    var R = this.g.mul(r2);
    var Rencoded = this.encodePoint(R);
    var s_ = this.hashInt(Rencoded, key2.pubBytes(), message2).mul(key2.priv());
    var S = r2.add(s_).umod(this.curve.n);
    return this.makeSignature({ R, S, Rencoded });
  };
  EDDSA.prototype.verify = function verify2(message2, sig, pub) {
    message2 = parseBytes(message2);
    sig = this.makeSignature(sig);
    var key2 = this.keyFromPublic(pub);
    var h = this.hashInt(sig.Rencoded(), key2.pubBytes(), message2);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key2.pub().mul(h));
    return RplusAh.eq(SG);
  };
  EDDSA.prototype.hashInt = function hashInt() {
    var hash2 = this.hash();
    for (var i2 = 0; i2 < arguments.length; i2++)
      hash2.update(arguments[i2]);
    return utils.intFromLE(hash2.digest()).umod(this.curve.n);
  };
  EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return KeyPair.fromPublic(this, pub);
  };
  EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return KeyPair.fromSecret(this, secret);
  };
  EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof Signature$2)
      return sig;
    return new Signature$2(this, sig);
  };
  EDDSA.prototype.encodePoint = function encodePoint(point2) {
    var enc = point2.getY().toArray("le", this.encodingLength);
    enc[this.encodingLength - 1] |= point2.getX().isOdd() ? 128 : 0;
    return enc;
  };
  EDDSA.prototype.decodePoint = function decodePoint(bytes2) {
    bytes2 = utils.parseBytes(bytes2);
    var lastIx = bytes2.length - 1;
    var normed = bytes2.slice(0, lastIx).concat(bytes2[lastIx] & ~128);
    var xIsOdd = (bytes2[lastIx] & 128) !== 0;
    var y = utils.intFromLE(normed);
    return this.curve.pointFromY(y, xIsOdd);
  };
  EDDSA.prototype.encodeInt = function encodeInt(num) {
    return num.toArray("le", this.encodingLength);
  };
  EDDSA.prototype.decodeInt = function decodeInt(bytes2) {
    return utils.intFromLE(bytes2);
  };
  EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
  };
  (function(exports2) {
    var elliptic2 = exports2;
    elliptic2.version = require$$0$1.version;
    elliptic2.utils = utils$m;
    elliptic2.rand = brorandExports;
    elliptic2.curve = curve$6;
    elliptic2.curves = curves$3;
    elliptic2.ec = ec$2;
    elliptic2.eddsa = eddsa;
  })(elliptic$2);
  var BN$6 = bn$2;
  var BufferUtil$7 = bufferExports;
  var EC$1 = elliptic$2.ec;
  var ec$1 = new EC$1("secp256k1");
  var ecPoint = ec$1.curve.point.bind(ec$1.curve);
  var ecPointFromX = ec$1.curve.pointFromX.bind(ec$1.curve);
  var Point$3 = function Point2(x, y, isRed) {
    try {
      var point2 = ecPoint(x, y, isRed);
    } catch (e) {
      throw new Error("Invalid Point");
    }
    point2.validate();
    return point2;
  };
  Point$3.prototype = Object.getPrototypeOf(ec$1.curve.point());
  Point$3.fromX = function fromX(odd, x) {
    try {
      var point2 = ecPointFromX(x, odd);
    } catch (e) {
      throw new Error("Invalid X");
    }
    point2.validate();
    return point2;
  };
  Point$3.getG = function getG() {
    return ec$1.curve.g;
  };
  Point$3.getN = function getN() {
    return new BN$6(ec$1.curve.n.toArray());
  };
  Point$3.prototype._getX = Point$3.prototype.getX;
  Point$3.prototype.getX = function getX() {
    return new BN$6(this._getX().toArray());
  };
  Point$3.prototype._getY = Point$3.prototype.getY;
  Point$3.prototype.getY = function getY() {
    return new BN$6(this._getY().toArray());
  };
  Point$3.prototype.validate = function validate() {
    if (this.isInfinity()) {
      throw new Error("Point cannot be equal to Infinity");
    }
    var p2;
    try {
      p2 = ecPointFromX(this.getX(), this.getY().isOdd());
    } catch (e) {
      throw new Error("Point does not lie on the curve");
    }
    if (p2.y.cmp(this.y) !== 0) {
      throw new Error("Invalid y value for curve.");
    }
    if (!this.mul(Point$3.getN()).isInfinity()) {
      throw new Error("Point times N must be infinity");
    }
    return this;
  };
  Point$3.pointToCompressed = function pointToCompressed(point2) {
    var xbuf = point2.getX().toBuffer({ size: 32 });
    var ybuf = point2.getY().toBuffer({ size: 32 });
    var prefix;
    var odd = ybuf[ybuf.length - 1] % 2;
    if (odd) {
      prefix = buffer$2.Buffer.from([3]);
    } else {
      prefix = buffer$2.Buffer.from([2]);
    }
    return BufferUtil$7.concat([prefix, xbuf]);
  };
  var point$1 = Point$3;
  var BN$5 = bn$2;
  var _$b = lodashExports;
  var $$7 = preconditions;
  var BufferUtil$6 = bufferExports;
  var JSUtil$3 = js$1;
  var Signature$1 = function Signature2(r2, s2) {
    if (!(this instanceof Signature2)) {
      return new Signature2(r2, s2);
    }
    if (r2 instanceof BN$5) {
      this.set({
        r: r2,
        s: s2
      });
    } else if (r2) {
      var obj = r2;
      this.set(obj);
    }
  };
  Signature$1.prototype.set = function(obj) {
    this.r = obj.r || this.r || void 0;
    this.s = obj.s || this.s || void 0;
    this.i = typeof obj.i !== "undefined" ? obj.i : this.i;
    this.compressed = typeof obj.compressed !== "undefined" ? obj.compressed : this.compressed;
    this.nhashtype = obj.nhashtype || this.nhashtype || void 0;
    return this;
  };
  Signature$1.fromCompact = function(buf) {
    $$7.checkArgument(BufferUtil$6.isBuffer(buf), "Argument is expected to be a Buffer");
    var sig = new Signature$1();
    var compressed = true;
    var i2 = buf.slice(0, 1)[0] - 27 - 4;
    if (i2 < 0) {
      compressed = false;
      i2 = i2 + 4;
    }
    var b2 = buf.slice(1, 33);
    var b3 = buf.slice(33, 65);
    $$7.checkArgument(i2 === 0 || i2 === 1 || i2 === 2 || i2 === 3, new Error("i must be 0, 1, 2, or 3"));
    $$7.checkArgument(b2.length === 32, new Error("r must be 32 bytes"));
    $$7.checkArgument(b3.length === 32, new Error("s must be 32 bytes"));
    sig.compressed = compressed;
    sig.i = i2;
    sig.r = BN$5.fromBuffer(b2);
    sig.s = BN$5.fromBuffer(b3);
    return sig;
  };
  Signature$1.fromDER = Signature$1.fromBuffer = function(buf, strict) {
    var obj = Signature$1.parseDER(buf, strict);
    var sig = new Signature$1();
    sig.r = obj.r;
    sig.s = obj.s;
    return sig;
  };
  Signature$1.fromTxFormat = function(buf) {
    var nhashtype = buf.readUInt8(buf.length - 1);
    var derbuf = buf.slice(0, buf.length - 1);
    var sig = new Signature$1.fromDER(derbuf, false);
    sig.nhashtype = nhashtype;
    return sig;
  };
  Signature$1.fromString = function(str) {
    var buf = buffer$2.Buffer.from(str, "hex");
    return Signature$1.fromDER(buf);
  };
  Signature$1.parseDER = function(buf, strict) {
    $$7.checkArgument(BufferUtil$6.isBuffer(buf), new Error("DER formatted signature should be a buffer"));
    if (_$b.isUndefined(strict)) {
      strict = true;
    }
    var header = buf[0];
    $$7.checkArgument(header === 48, new Error("Header byte should be 0x30"));
    var length = buf[1];
    var buflength = buf.slice(2).length;
    $$7.checkArgument(!strict || length === buflength, new Error("Length byte should length of what follows"));
    length = length < buflength ? length : buflength;
    var rheader = buf[2 + 0];
    $$7.checkArgument(rheader === 2, new Error("Integer byte for r should be 0x02"));
    var rlength = buf[2 + 1];
    var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);
    var r2 = BN$5.fromBuffer(rbuf);
    var rneg = buf[2 + 1 + 1] === 0 ? true : false;
    $$7.checkArgument(rlength === rbuf.length, new Error("Length of r incorrect"));
    var sheader = buf[2 + 2 + rlength + 0];
    $$7.checkArgument(sheader === 2, new Error("Integer byte for s should be 0x02"));
    var slength = buf[2 + 2 + rlength + 1];
    var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);
    var s2 = BN$5.fromBuffer(sbuf);
    var sneg = buf[2 + 2 + rlength + 2 + 2] === 0 ? true : false;
    $$7.checkArgument(slength === sbuf.length, new Error("Length of s incorrect"));
    var sumlength = 2 + 2 + rlength + 2 + slength;
    $$7.checkArgument(length === sumlength - 2, new Error("Length of signature incorrect"));
    var obj = {
      header,
      length,
      rheader,
      rlength,
      rneg,
      rbuf,
      r: r2,
      sheader,
      slength,
      sneg,
      sbuf,
      s: s2
    };
    return obj;
  };
  Signature$1.prototype.toCompact = function(i2, compressed) {
    i2 = typeof i2 === "number" ? i2 : this.i;
    compressed = typeof compressed === "boolean" ? compressed : this.compressed;
    if (!(i2 === 0 || i2 === 1 || i2 === 2 || i2 === 3)) {
      throw new Error("i must be equal to 0, 1, 2, or 3");
    }
    var val = i2 + 27 + 4;
    if (compressed === false) {
      val = val - 4;
    }
    var b1 = buffer$2.Buffer.from([val]);
    var b2 = this.r.toBuffer({
      size: 32
    });
    var b3 = this.s.toBuffer({
      size: 32
    });
    return buffer$2.Buffer.concat([b1, b2, b3]);
  };
  Signature$1.prototype.toBuffer = Signature$1.prototype.toDER = function() {
    var rnbuf = this.r.toBuffer();
    var snbuf = this.s.toBuffer();
    var rneg = rnbuf[0] & 128 ? true : false;
    var sneg = snbuf[0] & 128 ? true : false;
    var rbuf = rneg ? buffer$2.Buffer.concat([buffer$2.Buffer.from([0]), rnbuf]) : rnbuf;
    var sbuf = sneg ? buffer$2.Buffer.concat([buffer$2.Buffer.from([0]), snbuf]) : snbuf;
    var rlength = rbuf.length;
    var slength = sbuf.length;
    var length = 2 + rlength + 2 + slength;
    var rheader = 2;
    var sheader = 2;
    var header = 48;
    var der = buffer$2.Buffer.concat([buffer$2.Buffer.from([header, length, rheader, rlength]), rbuf, buffer$2.Buffer.from([sheader, slength]), sbuf]);
    return der;
  };
  Signature$1.prototype.toString = function() {
    var buf = this.toDER();
    return buf.toString("hex");
  };
  Signature$1.isTxDER = function(buf) {
    if (buf.length < 9) {
      return false;
    }
    if (buf.length > 73) {
      return false;
    }
    if (buf[0] !== 48) {
      return false;
    }
    if (buf[1] !== buf.length - 3) {
      return false;
    }
    var nLenR = buf[3];
    if (5 + nLenR >= buf.length) {
      return false;
    }
    var nLenS = buf[5 + nLenR];
    if (nLenR + nLenS + 7 !== buf.length) {
      return false;
    }
    var R = buf.slice(4);
    if (buf[4 - 2] !== 2) {
      return false;
    }
    if (nLenR === 0) {
      return false;
    }
    if (R[0] & 128) {
      return false;
    }
    if (nLenR > 1 && R[0] === 0 && !(R[1] & 128)) {
      return false;
    }
    var S = buf.slice(6 + nLenR);
    if (buf[6 + nLenR - 2] !== 2) {
      return false;
    }
    if (nLenS === 0) {
      return false;
    }
    if (S[0] & 128) {
      return false;
    }
    if (nLenS > 1 && S[0] === 0 && !(S[1] & 128)) {
      return false;
    }
    return true;
  };
  Signature$1.prototype.hasLowS = function() {
    if (this.s.lt(new BN$5(1)) || this.s.gt(new BN$5("7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0", "hex"))) {
      return false;
    }
    return true;
  };
  Signature$1.prototype.hasDefinedHashtype = function() {
    if (!JSUtil$3.isNaturalNumber(this.nhashtype)) {
      return false;
    }
    var temp = this.nhashtype & ~Signature$1.SIGHASH_ANYONECANPAY;
    if (temp < Signature$1.SIGHASH_ALL || temp > Signature$1.SIGHASH_SINGLE) {
      return false;
    }
    return true;
  };
  Signature$1.prototype.toTxFormat = function() {
    var derbuf = this.toDER();
    var buf = buffer$2.Buffer.alloc(1);
    buf.writeUInt8(this.nhashtype, 0);
    return buffer$2.Buffer.concat([derbuf, buf]);
  };
  Signature$1.SIGHASH_ALL = 1;
  Signature$1.SIGHASH_NONE = 2;
  Signature$1.SIGHASH_SINGLE = 3;
  Signature$1.SIGHASH_ANYONECANPAY = 128;
  var signature$2 = Signature$1;
  var hash$3 = { exports: {} };
  (function(module2) {
    var crypto2 = require$$1$1;
    var BufferUtil2 = bufferExports;
    var $2 = preconditions;
    var Hash2 = module2.exports;
    Hash2.sha1 = function(buf) {
      $2.checkArgument(BufferUtil2.isBuffer(buf));
      return crypto2.createHash("sha1").update(buf).digest();
    };
    Hash2.sha1.blocksize = 512;
    Hash2.sha256 = function(buf) {
      $2.checkArgument(BufferUtil2.isBuffer(buf));
      return crypto2.createHash("sha256").update(buf).digest();
    };
    Hash2.sha256.blocksize = 512;
    Hash2.sha256sha256 = function(buf) {
      $2.checkArgument(BufferUtil2.isBuffer(buf));
      return Hash2.sha256(Hash2.sha256(buf));
    };
    Hash2.ripemd160 = function(buf) {
      $2.checkArgument(BufferUtil2.isBuffer(buf));
      return crypto2.createHash("ripemd160").update(buf).digest();
    };
    Hash2.sha256ripemd160 = function(buf) {
      $2.checkArgument(BufferUtil2.isBuffer(buf));
      return Hash2.ripemd160(Hash2.sha256(buf));
    };
    Hash2.sha512 = function(buf) {
      $2.checkArgument(BufferUtil2.isBuffer(buf));
      return crypto2.createHash("sha512").update(buf).digest();
    };
    Hash2.sha512.blocksize = 1024;
    Hash2.hmac = function(hashf, data2, key2) {
      $2.checkArgument(BufferUtil2.isBuffer(data2));
      $2.checkArgument(BufferUtil2.isBuffer(key2));
      $2.checkArgument(hashf.blocksize);
      var blocksize = hashf.blocksize / 8;
      if (key2.length > blocksize) {
        key2 = hashf(key2);
      } else if (key2 < blocksize) {
        var fill = buffer$2.Buffer.alloc(blocksize);
        fill.fill(0);
        key2.copy(fill);
        key2 = fill;
      }
      var o_key = buffer$2.Buffer.alloc(blocksize);
      o_key.fill(92);
      var i_key = buffer$2.Buffer.alloc(blocksize);
      i_key.fill(54);
      var o_key_pad = buffer$2.Buffer.alloc(blocksize);
      var i_key_pad = buffer$2.Buffer.alloc(blocksize);
      for (var i2 = 0; i2 < blocksize; i2++) {
        o_key_pad[i2] = o_key[i2] ^ key2[i2];
        i_key_pad[i2] = i_key[i2] ^ key2[i2];
      }
      return hashf(buffer$2.Buffer.concat([o_key_pad, hashf(buffer$2.Buffer.concat([i_key_pad, data2]))]));
    };
    Hash2.sha256hmac = function(data2, key2) {
      return Hash2.hmac(Hash2.sha256, data2, key2);
    };
    Hash2.sha512hmac = function(data2, key2) {
      return Hash2.hmac(Hash2.sha512, data2, key2);
    };
  })(hash$3);
  var hashExports = hash$3.exports;
  var _$a = lodashExports;
  var BufferUtil$5 = bufferExports;
  var JSUtil$2 = js$1;
  var networks = [];
  var networkMaps = {};
  function Network() {
  }
  Network.prototype.toString = function toString() {
    return this.name;
  };
  function get(arg, keys) {
    if (~networks.indexOf(arg)) {
      return arg;
    }
    if (keys) {
      if (!_$a.isArray(keys)) {
        keys = [keys];
      }
      var containsArg = function(key2) {
        return networks[index][key2] === arg;
      };
      for (var index in networks) {
        if (_$a.some(keys, containsArg)) {
          return networks[index];
        }
      }
      return void 0;
    }
    if (networkMaps[arg] && networkMaps[arg].length >= 1) {
      return networkMaps[arg][0];
    } else {
      return networkMaps[arg];
    }
  }
  function addNetwork(data2) {
    var network = new Network();
    JSUtil$2.defineImmutable(network, {
      name: data2.name,
      alias: data2.alias,
      pubkeyhash: data2.pubkeyhash,
      privatekey: data2.privatekey,
      scripthash: data2.scripthash,
      bech32prefix: data2.bech32prefix,
      xpubkey: data2.xpubkey,
      xprivkey: data2.xprivkey
    });
    if (data2.networkMagic) {
      JSUtil$2.defineImmutable(network, {
        networkMagic: BufferUtil$5.integerAsBuffer(data2.networkMagic)
      });
    }
    if (data2.port) {
      JSUtil$2.defineImmutable(network, {
        port: data2.port
      });
    }
    if (data2.dnsSeeds) {
      JSUtil$2.defineImmutable(network, {
        dnsSeeds: data2.dnsSeeds
      });
    }
    _$a.each(network, function(value) {
      if (!_$a.isUndefined(value) && !_$a.isObject(value)) {
        if (!networkMaps[value]) {
          networkMaps[value] = [];
        }
        networkMaps[value].push(network);
      }
    });
    networks.push(network);
    return network;
  }
  function removeNetwork(network) {
    if (typeof network !== "object") {
      network = get(network);
    }
    for (var i2 = 0; i2 < networks.length; i2++) {
      if (networks[i2] === network) {
        networks.splice(i2, 1);
      }
    }
    for (var key2 in networkMaps) {
      if (networkMaps[key2].length) {
        const index = networkMaps[key2].indexOf(network);
        if (index >= 0) {
          networkMaps[key2].splice(index, 1);
        }
        if (networkMaps[key2].length === 0) {
          delete networkMaps[key2];
        }
      } else if (networkMaps[key2] === network) {
        delete networkMaps[key2];
      }
    }
  }
  addNetwork({
    name: "livenet",
    alias: "mainnet",
    pubkeyhash: 0,
    privatekey: 128,
    scripthash: 5,
    bech32prefix: "bc",
    xpubkey: 76067358,
    xprivkey: 76066276,
    networkMagic: 4190024921,
    port: 8333,
    dnsSeeds: [
      "seed.bitcoin.sipa.be",
      "dnsseed.bluematt.me",
      "dnsseed.bitcoin.dashjr.org",
      "seed.bitcoinstats.com",
      "seed.bitnodes.io",
      "bitseed.xf2.org"
    ]
  });
  var livenet = get("livenet");
  addNetwork({
    name: "testnet",
    alias: "test",
    pubkeyhash: 111,
    privatekey: 239,
    scripthash: 196,
    bech32prefix: "tb",
    xpubkey: 70617039,
    xprivkey: 70615956,
    networkMagic: 185665799,
    port: 18333,
    dnsSeeds: [
      "testnet-seed.bitcoin.petertodd.org",
      "testnet-seed.bluematt.me",
      "testnet-seed.alexykot.me",
      "testnet-seed.bitcoin.schildbach.de"
    ]
  });
  var testnet = get("testnet");
  addNetwork({
    name: "regtest",
    alias: "dev",
    pubkeyhash: 111,
    privatekey: 239,
    scripthash: 196,
    bech32prefix: "bcrt",
    xpubkey: 70617039,
    xprivkey: 70615956,
    networkMagic: 4206867930,
    port: 18444,
    dnsSeeds: []
  });
  var regtest = get("regtest");
  function enableRegtest() {
    testnet.regtestEnabled = true;
  }
  function disableRegtest() {
    testnet.regtestEnabled = false;
  }
  var networks_1 = {
    add: addNetwork,
    remove: removeNetwork,
    defaultNetwork: livenet,
    livenet,
    mainnet: livenet,
    testnet,
    regtest,
    get,
    enableRegtest,
    disableRegtest
  };
  var safeBuffer = { exports: {} };
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  (function(module2, exports2) {
    var buffer2 = buffer$2;
    var Buffer2 = buffer2.Buffer;
    function copyProps(src2, dst) {
      for (var key2 in src2) {
        dst[key2] = src2[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  var safeBufferExports = safeBuffer.exports;
  var _Buffer = safeBufferExports.Buffer;
  function base(ALPHABET2) {
    if (ALPHABET2.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i2 = 0; i2 < ALPHABET2.length; i2++) {
      var x = ALPHABET2.charAt(i2);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i2;
    }
    var BASE = ALPHABET2.length;
    var LEADER = ALPHABET2.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode2(source) {
      if (Array.isArray(source) || source instanceof Uint8Array) {
        source = _Buffer.from(source);
      }
      if (!_Buffer.isBuffer(source)) {
        throw new TypeError("Expected Buffer");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i3 = 0;
        for (var it1 = size - 1; (carry !== 0 || i3 < length) && it1 !== -1; it1--, i3++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i3;
        pbegin++;
      }
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET2.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return _Buffer.alloc(0);
      }
      var psz = 0;
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i3 = 0;
        for (var it3 = size - 1; (carry !== 0 || i3 < length) && it3 !== -1; it3--, i3++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i3;
        psz++;
      }
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
      vch.fill(0, 0, zeroes);
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode2(string) {
      var buffer2 = decodeUnsafe(string);
      if (buffer2) {
        return buffer2;
      }
      throw new Error("Non-base" + BASE + " character");
    }
    return {
      encode: encode2,
      decodeUnsafe,
      decode: decode2
    };
  }
  var src$1 = base;
  var basex = src$1;
  var ALPHABET$2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  var bs58$1 = basex(ALPHABET$2);
  var _$9 = lodashExports;
  var bs58 = bs58$1;
  var buffer = buffer$2;
  var ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".split("");
  var Base58$1 = function Base582(obj) {
    if (!(this instanceof Base582)) {
      return new Base582(obj);
    }
    if (buffer$2.Buffer.isBuffer(obj)) {
      var buf = obj;
      this.fromBuffer(buf);
    } else if (typeof obj === "string") {
      var str = obj;
      this.fromString(str);
    } else if (obj) {
      this.set(obj);
    }
  };
  Base58$1.validCharacters = function validCharacters(chars) {
    if (buffer.Buffer.isBuffer(chars)) {
      chars = chars.toString();
    }
    return _$9.every(_$9.map(chars, function(char) {
      return _$9.includes(ALPHABET$1, char);
    }));
  };
  Base58$1.prototype.set = function(obj) {
    this.buf = obj.buf || this.buf || void 0;
    return this;
  };
  Base58$1.encode = function(buf) {
    if (!buffer.Buffer.isBuffer(buf)) {
      throw new Error("Input should be a buffer");
    }
    return bs58.encode(buf);
  };
  Base58$1.decode = function(str) {
    if (typeof str !== "string") {
      throw new Error("Input should be a string");
    }
    return buffer$2.Buffer.from(bs58.decode(str));
  };
  Base58$1.prototype.fromBuffer = function(buf) {
    this.buf = buf;
    return this;
  };
  Base58$1.prototype.fromString = function(str) {
    var buf = Base58$1.decode(str);
    this.buf = buf;
    return this;
  };
  Base58$1.prototype.toBuffer = function() {
    return this.buf;
  };
  Base58$1.prototype.toString = function() {
    return Base58$1.encode(this.buf);
  };
  var base58 = Base58$1;
  var _$8 = lodashExports;
  var Base58 = base58;
  var sha256sha256$1 = hashExports.sha256sha256;
  var Base58Check = function Base58Check2(obj) {
    if (!(this instanceof Base58Check2))
      return new Base58Check2(obj);
    if (buffer$2.Buffer.isBuffer(obj)) {
      var buf = obj;
      this.fromBuffer(buf);
    } else if (typeof obj === "string") {
      var str = obj;
      this.fromString(str);
    } else if (obj) {
      this.set(obj);
    }
  };
  Base58Check.prototype.set = function(obj) {
    this.buf = obj.buf || this.buf || void 0;
    return this;
  };
  Base58Check.validChecksum = function validChecksum(data2, checksum) {
    if (_$8.isString(data2)) {
      data2 = buffer$2.Buffer.from(Base58.decode(data2));
    }
    if (_$8.isString(checksum)) {
      checksum = buffer$2.Buffer.from(Base58.decode(checksum));
    }
    if (!checksum) {
      checksum = data2.slice(-4);
      data2 = data2.slice(0, -4);
    }
    return Base58Check.checksum(data2).toString("hex") === checksum.toString("hex");
  };
  Base58Check.decode = function(s2) {
    if (typeof s2 !== "string")
      throw new Error("Input must be a string");
    var buf = buffer$2.Buffer.from(Base58.decode(s2));
    if (buf.length < 4)
      throw new Error("Input string too short");
    var data2 = buf.slice(0, -4);
    var csum = buf.slice(-4);
    var hash2 = sha256sha256$1(data2);
    var hash4 = hash2.slice(0, 4);
    if (csum.toString("hex") !== hash4.toString("hex"))
      throw new Error("Checksum mismatch");
    return data2;
  };
  Base58Check.checksum = function(buffer2) {
    return sha256sha256$1(buffer2).slice(0, 4);
  };
  Base58Check.encode = function(buf) {
    if (!buffer$2.Buffer.isBuffer(buf))
      throw new Error("Input must be a buffer");
    var checkedBuf = buffer$2.Buffer.alloc(buf.length + 4);
    var hash2 = Base58Check.checksum(buf);
    buf.copy(checkedBuf);
    hash2.copy(checkedBuf, buf.length);
    return Base58.encode(checkedBuf);
  };
  Base58Check.prototype.fromBuffer = function(buf) {
    this.buf = buf;
    return this;
  };
  Base58Check.prototype.fromString = function(str) {
    var buf = Base58Check.decode(str);
    this.buf = buf;
    return this;
  };
  Base58Check.prototype.toBuffer = function() {
    return this.buf;
  };
  Base58Check.prototype.toString = function() {
    return Base58Check.encode(this.buf);
  };
  var base58check = Base58Check;
  var dist = {};
  Object.defineProperty(dist, "__esModule", { value: true });
  dist.bech32m = dist.bech32 = void 0;
  const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
  const ALPHABET_MAP = {};
  for (let z = 0; z < ALPHABET.length; z++) {
    const x = ALPHABET.charAt(z);
    ALPHABET_MAP[x] = z;
  }
  function polymodStep(pre) {
    const b = pre >> 25;
    return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
  }
  function prefixChk(prefix) {
    let chk = 1;
    for (let i2 = 0; i2 < prefix.length; ++i2) {
      const c = prefix.charCodeAt(i2);
      if (c < 33 || c > 126)
        return "Invalid prefix (" + prefix + ")";
      chk = polymodStep(chk) ^ c >> 5;
    }
    chk = polymodStep(chk);
    for (let i2 = 0; i2 < prefix.length; ++i2) {
      const v = prefix.charCodeAt(i2);
      chk = polymodStep(chk) ^ v & 31;
    }
    return chk;
  }
  function convert$5(data2, inBits, outBits, pad) {
    let value = 0;
    let bits = 0;
    const maxV = (1 << outBits) - 1;
    const result = [];
    for (let i2 = 0; i2 < data2.length; ++i2) {
      value = value << inBits | data2[i2];
      bits += inBits;
      while (bits >= outBits) {
        bits -= outBits;
        result.push(value >> bits & maxV);
      }
    }
    if (pad) {
      if (bits > 0) {
        result.push(value << outBits - bits & maxV);
      }
    } else {
      if (bits >= inBits)
        return "Excess padding";
      if (value << outBits - bits & maxV)
        return "Non-zero padding";
    }
    return result;
  }
  function toWords(bytes2) {
    return convert$5(bytes2, 8, 5, true);
  }
  function fromWordsUnsafe(words) {
    const res = convert$5(words, 5, 8, false);
    if (Array.isArray(res))
      return res;
  }
  function fromWords(words) {
    const res = convert$5(words, 5, 8, false);
    if (Array.isArray(res))
      return res;
    throw new Error(res);
  }
  function getLibraryFromEncoding(encoding) {
    let ENCODING_CONST;
    if (encoding === "bech32") {
      ENCODING_CONST = 1;
    } else {
      ENCODING_CONST = 734539939;
    }
    function encode2(prefix, words, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words.length > LIMIT)
        throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      let chk = prefixChk(prefix);
      if (typeof chk === "string")
        throw new Error(chk);
      let result = prefix + "1";
      for (let i2 = 0; i2 < words.length; ++i2) {
        const x = words[i2];
        if (x >> 5 !== 0)
          throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x;
        result += ALPHABET.charAt(x);
      }
      for (let i2 = 0; i2 < 6; ++i2) {
        chk = polymodStep(chk);
      }
      chk ^= ENCODING_CONST;
      for (let i2 = 0; i2 < 6; ++i2) {
        const v = chk >> (5 - i2) * 5 & 31;
        result += ALPHABET.charAt(v);
      }
      return result;
    }
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8)
        return str + " too short";
      if (str.length > LIMIT)
        return "Exceeds length limit";
      const lowered = str.toLowerCase();
      const uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered)
        return "Mixed-case string " + str;
      str = lowered;
      const split2 = str.lastIndexOf("1");
      if (split2 === -1)
        return "No separator character for " + str;
      if (split2 === 0)
        return "Missing prefix for " + str;
      const prefix = str.slice(0, split2);
      const wordChars = str.slice(split2 + 1);
      if (wordChars.length < 6)
        return "Data too short";
      let chk = prefixChk(prefix);
      if (typeof chk === "string")
        return chk;
      const words = [];
      for (let i2 = 0; i2 < wordChars.length; ++i2) {
        const c = wordChars.charAt(i2);
        const v = ALPHABET_MAP[c];
        if (v === void 0)
          return "Unknown character " + c;
        chk = polymodStep(chk) ^ v;
        if (i2 + 6 >= wordChars.length)
          continue;
        words.push(v);
      }
      if (chk !== ENCODING_CONST)
        return "Invalid checksum for " + str;
      return { prefix, words };
    }
    function decodeUnsafe(str, LIMIT) {
      const res = __decode(str, LIMIT);
      if (typeof res === "object")
        return res;
    }
    function decode2(str, LIMIT) {
      const res = __decode(str, LIMIT);
      if (typeof res === "object")
        return res;
      throw new Error(res);
    }
    return {
      decodeUnsafe,
      decode: decode2,
      encode: encode2,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
  dist.bech32 = getLibraryFromEncoding("bech32");
  dist.bech32m = getLibraryFromEncoding("bech32m");
  var bech32 = dist;
  var decode$1 = function(str) {
    if (typeof str !== "string") {
      throw new Error("Input should be a string");
    }
    var decoded;
    let fromWords2 = bech32.bech32.fromWords;
    let encoding = encodings.BECH32;
    try {
      decoded = bech32.bech32.decode(str);
    } catch (e) {
      if (e.message.indexOf("Invalid checksum") > -1) {
        decoded = bech32.bech32m.decode(str);
        encoding = encodings.BECH32M;
        fromWords2 = bech32.bech32m.fromWords;
      } else {
        throw e;
      }
    }
    const version2 = decoded.words[0];
    if (version2 >= 1 && encoding !== encodings.BECH32M) {
      throw new Error("Version 1+ witness address must use Bech32m checksum");
    }
    return {
      prefix: decoded.prefix,
      data: buffer$2.Buffer.from(fromWords2(decoded.words.slice(1))),
      version: version2
    };
  };
  var encode$1 = function(prefix, version2, data2, encoding) {
    if (typeof prefix !== "string") {
      throw new Error("Prefix should be a string");
    }
    if (typeof version2 !== "number") {
      throw new Error("version should be a number");
    }
    if (encoding && typeof encoding == "string") {
      encoding = encodings[encoding.toUpperCase()] || -1;
    }
    if (encoding && !(encoding == encodings.BECH32 || encoding == encodings.BECH32M)) {
      throw new Error("Invalid encoding specified");
    }
    let b32Variety = encoding == encodings.BECH32M ? bech32.bech32m : bech32.bech32;
    let words = b32Variety.toWords(data2);
    words.unshift(version2);
    return b32Variety.encode(prefix, words);
  };
  const encodings = {
    BECH32: 1,
    BECH32M: 2
  };
  var bech32_1 = { decode: decode$1, encode: encode$1, encodings };
  var script$1 = { exports: {} };
  var _$7 = lodashExports;
  var $$6 = preconditions;
  var BufferUtil$4 = bufferExports;
  var BN$4 = bn$2;
  var BufferReader$4 = function BufferReader2(buf) {
    if (!(this instanceof BufferReader2)) {
      return new BufferReader2(buf);
    }
    if (_$7.isUndefined(buf)) {
      return;
    }
    if (buffer$2.Buffer.isBuffer(buf)) {
      this.set({
        buf
      });
    } else if (_$7.isString(buf)) {
      this.set({
        buf: buffer$2.Buffer.from(buf, "hex")
      });
    } else if (_$7.isObject(buf)) {
      var obj = buf;
      this.set(obj);
    } else {
      throw new TypeError("Unrecognized argument for BufferReader");
    }
  };
  BufferReader$4.prototype.set = function(obj) {
    this.buf = obj.buf || this.buf || void 0;
    this.pos = obj.pos || this.pos || 0;
    return this;
  };
  BufferReader$4.prototype.eof = function() {
    if (this.buf) {
      return this.pos >= this.buf.length;
    } else {
      return true;
    }
  };
  BufferReader$4.prototype.finished = BufferReader$4.prototype.eof;
  BufferReader$4.prototype.read = function(len2) {
    $$6.checkArgument(!_$7.isUndefined(len2), "Must specify a length");
    var buf = this.buf.slice(this.pos, this.pos + len2);
    this.pos = this.pos + len2;
    return buf;
  };
  BufferReader$4.prototype.readAll = function() {
    var buf = this.buf.slice(this.pos, this.buf.length);
    this.pos = this.buf.length;
    return buf;
  };
  BufferReader$4.prototype.readUInt8 = function() {
    var val = this.buf.readUInt8(this.pos);
    this.pos = this.pos + 1;
    return val;
  };
  BufferReader$4.prototype.readUInt16BE = function() {
    var val = this.buf.readUInt16BE(this.pos);
    this.pos = this.pos + 2;
    return val;
  };
  BufferReader$4.prototype.readUInt16LE = function() {
    var val = this.buf.readUInt16LE(this.pos);
    this.pos = this.pos + 2;
    return val;
  };
  BufferReader$4.prototype.readUInt32BE = function() {
    var val = this.buf.readUInt32BE(this.pos);
    this.pos = this.pos + 4;
    return val;
  };
  BufferReader$4.prototype.readUInt32LE = function() {
    var val = this.buf.readUInt32LE(this.pos);
    this.pos = this.pos + 4;
    return val;
  };
  BufferReader$4.prototype.readInt32LE = function() {
    var val = this.buf.readInt32LE(this.pos);
    this.pos = this.pos + 4;
    return val;
  };
  BufferReader$4.prototype.readUInt64BEBN = function() {
    var buf = this.buf.slice(this.pos, this.pos + 8);
    var bn2 = BN$4.fromBuffer(buf);
    this.pos = this.pos + 8;
    return bn2;
  };
  BufferReader$4.prototype.readUInt64LEBN = function() {
    var second = this.buf.readUInt32LE(this.pos);
    var first = this.buf.readUInt32LE(this.pos + 4);
    var combined = first * 4294967296 + second;
    var bn2;
    if (combined <= 9007199254740991) {
      bn2 = new BN$4(combined);
    } else {
      var data2 = Array.prototype.slice.call(this.buf, this.pos, this.pos + 8);
      bn2 = new BN$4(data2, 10, "le");
    }
    this.pos = this.pos + 8;
    return bn2;
  };
  BufferReader$4.prototype.readVarintNum = function() {
    var first = this.readUInt8();
    switch (first) {
      case 253:
        return this.readUInt16LE();
      case 254:
        return this.readUInt32LE();
      case 255:
        var bn2 = this.readUInt64LEBN();
        var n2 = bn2.toNumber();
        if (n2 <= Math.pow(2, 53)) {
          return n2;
        } else {
          throw new Error("number too large to retain precision - use readVarintBN");
        }
      default:
        return first;
    }
  };
  BufferReader$4.prototype.readVarLengthBuffer = function() {
    var len2 = this.readVarintNum();
    var buf = this.read(len2);
    $$6.checkState(buf.length === len2, "Invalid length while reading varlength buffer. Expected to read: " + len2 + " and read " + buf.length);
    return buf;
  };
  BufferReader$4.prototype.readVarintBuf = function() {
    var first = this.buf.readUInt8(this.pos);
    switch (first) {
      case 253:
        return this.read(1 + 2);
      case 254:
        return this.read(1 + 4);
      case 255:
        return this.read(1 + 8);
      default:
        return this.read(1);
    }
  };
  BufferReader$4.prototype.readVarintBN = function() {
    var first = this.readUInt8();
    switch (first) {
      case 253:
        return new BN$4(this.readUInt16LE());
      case 254:
        return new BN$4(this.readUInt32LE());
      case 255:
        return this.readUInt64LEBN();
      default:
        return new BN$4(first);
    }
  };
  BufferReader$4.prototype.reverse = function() {
    var buf = buffer$2.Buffer.alloc(this.buf.length);
    for (var i2 = 0; i2 < buf.length; i2++) {
      buf[i2] = this.buf[this.buf.length - 1 - i2];
    }
    this.buf = buf;
    return this;
  };
  BufferReader$4.prototype.readReverse = function(len2) {
    if (_$7.isUndefined(len2)) {
      len2 = this.buf.length;
    }
    var buf = this.buf.slice(this.pos, this.pos + len2);
    this.pos = this.pos + len2;
    return BufferUtil$4.reverse(buf);
  };
  var bufferreader = BufferReader$4;
  var bufferUtil = bufferExports;
  var assert$4 = requireAssert();
  var BufferWriter$5 = function BufferWriter2(obj) {
    if (!(this instanceof BufferWriter2))
      return new BufferWriter2(obj);
    this.bufLen = 0;
    if (obj)
      this.set(obj);
    else
      this.bufs = [];
  };
  BufferWriter$5.prototype.set = function(obj) {
    this.bufs = obj.bufs || this.bufs || [];
    this.bufLen = this.bufs.reduce(function(prev, buf) {
      return prev + buf.length;
    }, 0);
    return this;
  };
  BufferWriter$5.prototype.toBuffer = function() {
    return this.concat();
  };
  BufferWriter$5.prototype.concat = function() {
    return buffer$2.Buffer.concat(this.bufs, this.bufLen);
  };
  BufferWriter$5.prototype.write = function(buf) {
    assert$4(bufferUtil.isBuffer(buf));
    this.bufs.push(buf);
    this.bufLen += buf.length;
    return this;
  };
  BufferWriter$5.prototype.writeReverse = function(buf) {
    assert$4(bufferUtil.isBuffer(buf));
    this.bufs.push(bufferUtil.reverse(buf));
    this.bufLen += buf.length;
    return this;
  };
  BufferWriter$5.prototype.writeUInt8 = function(n2) {
    var buf = buffer$2.Buffer.alloc(1);
    buf.writeUInt8(n2, 0);
    this.write(buf);
    return this;
  };
  BufferWriter$5.prototype.writeUInt16BE = function(n2) {
    var buf = buffer$2.Buffer.alloc(2);
    buf.writeUInt16BE(n2, 0);
    this.write(buf);
    return this;
  };
  BufferWriter$5.prototype.writeUInt16LE = function(n2) {
    var buf = buffer$2.Buffer.alloc(2);
    buf.writeUInt16LE(n2, 0);
    this.write(buf);
    return this;
  };
  BufferWriter$5.prototype.writeUInt32BE = function(n2) {
    var buf = buffer$2.Buffer.alloc(4);
    buf.writeUInt32BE(n2, 0);
    this.write(buf);
    return this;
  };
  BufferWriter$5.prototype.writeInt32LE = function(n2) {
    var buf = buffer$2.Buffer.alloc(4);
    buf.writeInt32LE(n2, 0);
    this.write(buf);
    return this;
  };
  BufferWriter$5.prototype.writeUInt32LE = function(n2) {
    var buf = buffer$2.Buffer.alloc(4);
    buf.writeUInt32LE(n2, 0);
    this.write(buf);
    return this;
  };
  BufferWriter$5.prototype.writeUInt64BEBN = function(bn2) {
    var buf = bn2.toBuffer({ size: 8 });
    this.write(buf);
    return this;
  };
  BufferWriter$5.prototype.writeUInt64LEBN = function(bn2) {
    var buf = bn2.toBuffer({ size: 8 });
    this.writeReverse(buf);
    return this;
  };
  BufferWriter$5.prototype.writeVarintNum = function(n2) {
    var buf = BufferWriter$5.varintBufNum(n2);
    this.write(buf);
    return this;
  };
  BufferWriter$5.prototype.writeVarintBN = function(bn2) {
    var buf = BufferWriter$5.varintBufBN(bn2);
    this.write(buf);
    return this;
  };
  BufferWriter$5.varintBufNum = function(n2) {
    var buf = void 0;
    if (n2 < 253) {
      buf = buffer$2.Buffer.alloc(1);
      buf.writeUInt8(n2, 0);
    } else if (n2 < 65536) {
      buf = buffer$2.Buffer.alloc(1 + 2);
      buf.writeUInt8(253, 0);
      buf.writeUInt16LE(n2, 1);
    } else if (n2 < 4294967296) {
      buf = buffer$2.Buffer.alloc(1 + 4);
      buf.writeUInt8(254, 0);
      buf.writeUInt32LE(n2, 1);
    } else {
      buf = buffer$2.Buffer.alloc(1 + 8);
      buf.writeUInt8(255, 0);
      buf.writeInt32LE(n2 & -1, 1);
      buf.writeUInt32LE(Math.floor(n2 / 4294967296), 5);
    }
    return buf;
  };
  BufferWriter$5.varintBufBN = function(bn2) {
    var buf = void 0;
    var n2 = bn2.toNumber();
    if (n2 < 253) {
      buf = buffer$2.Buffer.alloc(1);
      buf.writeUInt8(n2, 0);
    } else if (n2 < 65536) {
      buf = buffer$2.Buffer.alloc(1 + 2);
      buf.writeUInt8(253, 0);
      buf.writeUInt16LE(n2, 1);
    } else if (n2 < 4294967296) {
      buf = buffer$2.Buffer.alloc(1 + 4);
      buf.writeUInt8(254, 0);
      buf.writeUInt32LE(n2, 1);
    } else {
      var bw = new BufferWriter$5();
      bw.writeUInt8(255);
      bw.writeUInt64LEBN(bn2);
      var buf = bw.concat();
    }
    return buf;
  };
  var bufferwriter = BufferWriter$5;
  var _$6 = lodashExports;
  var $$5 = preconditions;
  var BufferUtil$3 = bufferExports;
  var JSUtil$1 = js$1;
  function Opcode(num) {
    if (!(this instanceof Opcode)) {
      return new Opcode(num);
    }
    var value;
    if (_$6.isNumber(num)) {
      value = num;
    } else if (_$6.isString(num)) {
      value = Opcode.map[num];
    } else {
      throw new TypeError('Unrecognized num type: "' + typeof num + '" for Opcode');
    }
    JSUtil$1.defineImmutable(this, {
      num: value
    });
    return this;
  }
  Opcode.fromBuffer = function(buf) {
    $$5.checkArgument(BufferUtil$3.isBuffer(buf));
    return new Opcode(Number("0x" + buf.toString("hex")));
  };
  Opcode.fromNumber = function(num) {
    $$5.checkArgument(_$6.isNumber(num));
    return new Opcode(num);
  };
  Opcode.fromString = function(str) {
    $$5.checkArgument(_$6.isString(str));
    var value = Opcode.map[str];
    if (typeof value === "undefined") {
      throw new TypeError("Invalid opcodestr");
    }
    return new Opcode(value);
  };
  Opcode.prototype.toHex = function() {
    return this.num.toString(16);
  };
  Opcode.prototype.toBuffer = function() {
    return buffer$2.Buffer.from(this.toHex(), "hex");
  };
  Opcode.prototype.toNumber = function() {
    return this.num;
  };
  Opcode.prototype.toString = function() {
    var str = Opcode.reverseMap[this.num];
    if (typeof str === "undefined") {
      throw new Error("Opcode does not have a string representation");
    }
    return str;
  };
  Opcode.smallInt = function(n2) {
    $$5.checkArgument(_$6.isNumber(n2), "Invalid Argument: n should be number");
    $$5.checkArgument(n2 >= 0 && n2 <= 16, "Invalid Argument: n must be between 0 and 16");
    if (n2 === 0) {
      return Opcode("OP_0");
    }
    return new Opcode(Opcode.map.OP_1 + n2 - 1);
  };
  Opcode.map = {
    // push value
    OP_FALSE: 0,
    OP_0: 0,
    OP_PUSHDATA1: 76,
    OP_PUSHDATA2: 77,
    OP_PUSHDATA4: 78,
    OP_1NEGATE: 79,
    OP_RESERVED: 80,
    OP_TRUE: 81,
    OP_1: 81,
    OP_2: 82,
    OP_3: 83,
    OP_4: 84,
    OP_5: 85,
    OP_6: 86,
    OP_7: 87,
    OP_8: 88,
    OP_9: 89,
    OP_10: 90,
    OP_11: 91,
    OP_12: 92,
    OP_13: 93,
    OP_14: 94,
    OP_15: 95,
    OP_16: 96,
    // control
    OP_NOP: 97,
    OP_VER: 98,
    OP_IF: 99,
    OP_NOTIF: 100,
    OP_VERIF: 101,
    OP_VERNOTIF: 102,
    OP_ELSE: 103,
    OP_ENDIF: 104,
    OP_VERIFY: 105,
    OP_RETURN: 106,
    // stack ops
    OP_TOALTSTACK: 107,
    OP_FROMALTSTACK: 108,
    OP_2DROP: 109,
    OP_2DUP: 110,
    OP_3DUP: 111,
    OP_2OVER: 112,
    OP_2ROT: 113,
    OP_2SWAP: 114,
    OP_IFDUP: 115,
    OP_DEPTH: 116,
    OP_DROP: 117,
    OP_DUP: 118,
    OP_NIP: 119,
    OP_OVER: 120,
    OP_PICK: 121,
    OP_ROLL: 122,
    OP_ROT: 123,
    OP_SWAP: 124,
    OP_TUCK: 125,
    // splice ops
    OP_CAT: 126,
    OP_SUBSTR: 127,
    OP_LEFT: 128,
    OP_RIGHT: 129,
    OP_SIZE: 130,
    // bit logic
    OP_INVERT: 131,
    OP_AND: 132,
    OP_OR: 133,
    OP_XOR: 134,
    OP_EQUAL: 135,
    OP_EQUALVERIFY: 136,
    OP_RESERVED1: 137,
    OP_RESERVED2: 138,
    // numeric
    OP_1ADD: 139,
    OP_1SUB: 140,
    OP_2MUL: 141,
    OP_2DIV: 142,
    OP_NEGATE: 143,
    OP_ABS: 144,
    OP_NOT: 145,
    OP_0NOTEQUAL: 146,
    OP_ADD: 147,
    OP_SUB: 148,
    OP_MUL: 149,
    OP_DIV: 150,
    OP_MOD: 151,
    OP_LSHIFT: 152,
    OP_RSHIFT: 153,
    OP_BOOLAND: 154,
    OP_BOOLOR: 155,
    OP_NUMEQUAL: 156,
    OP_NUMEQUALVERIFY: 157,
    OP_NUMNOTEQUAL: 158,
    OP_LESSTHAN: 159,
    OP_GREATERTHAN: 160,
    OP_LESSTHANOREQUAL: 161,
    OP_GREATERTHANOREQUAL: 162,
    OP_MIN: 163,
    OP_MAX: 164,
    OP_WITHIN: 165,
    // crypto
    OP_RIPEMD160: 166,
    OP_SHA1: 167,
    OP_SHA256: 168,
    OP_HASH160: 169,
    OP_HASH256: 170,
    OP_CODESEPARATOR: 171,
    OP_CHECKSIG: 172,
    OP_CHECKSIGVERIFY: 173,
    OP_CHECKMULTISIG: 174,
    OP_CHECKMULTISIGVERIFY: 175,
    OP_CHECKLOCKTIMEVERIFY: 177,
    OP_CHECKSEQUENCEVERIFY: 178,
    // expansion
    OP_NOP1: 176,
    OP_NOP2: 177,
    OP_NOP3: 178,
    OP_NOP4: 179,
    OP_NOP5: 180,
    OP_NOP6: 181,
    OP_NOP7: 182,
    OP_NOP8: 183,
    OP_NOP9: 184,
    OP_NOP10: 185,
    // template matching params
    OP_PUBKEYHASH: 253,
    OP_PUBKEY: 254,
    OP_INVALIDOPCODE: 255
  };
  Opcode.reverseMap = [];
  for (var k in Opcode.map) {
    Opcode.reverseMap[Opcode.map[k]] = k;
  }
  _$6.extend(Opcode, Opcode.map);
  Opcode.isSmallIntOp = function(opcode2) {
    if (opcode2 instanceof Opcode) {
      opcode2 = opcode2.toNumber();
    }
    return opcode2 === Opcode.map.OP_0 || opcode2 >= Opcode.map.OP_1 && opcode2 <= Opcode.map.OP_16;
  };
  Opcode.prototype.inspect = function() {
    return "<Opcode: " + this.toString() + ", hex: " + this.toHex() + ", decimal: " + this.num + ">";
  };
  var opcode = Opcode;
  var script;
  var hasRequiredScript$1;
  function requireScript$1() {
    if (hasRequiredScript$1)
      return script;
    hasRequiredScript$1 = 1;
    var Address2 = requireAddress();
    var BufferReader2 = bufferreader;
    var BufferWriter2 = bufferwriter;
    var Hash2 = hashExports;
    var Opcode2 = opcode;
    var PublicKey2 = requirePublickey();
    var Signature2 = signature$2;
    var Networks = networks_1;
    var $2 = preconditions;
    var _2 = lodashExports;
    var errors2 = errorsExports;
    var BufferUtil2 = bufferExports;
    var JSUtil2 = js$1;
    var Script = function Script2(from) {
      if (!(this instanceof Script2)) {
        return new Script2(from);
      }
      this.chunks = [];
      if (BufferUtil2.isBuffer(from)) {
        return Script2.fromBuffer(from);
      } else if (from instanceof Address2) {
        return Script2.fromAddress(from);
      } else if (from instanceof Script2) {
        return Script2.fromBuffer(from.toBuffer());
      } else if (_2.isString(from)) {
        return Script2.fromString(from);
      } else if (_2.isObject(from) && _2.isArray(from.chunks)) {
        this.set(from);
      }
    };
    Script.VERIFY_TAPROOT = 1 << 17;
    Script.prototype.set = function(obj) {
      $2.checkArgument(_2.isObject(obj));
      $2.checkArgument(_2.isArray(obj.chunks));
      this.chunks = obj.chunks;
      return this;
    };
    Script.fromBuffer = function(buffer2) {
      var script2 = new Script();
      script2.chunks = [];
      var br = new BufferReader2(buffer2);
      while (!br.finished()) {
        try {
          var opcodenum = br.readUInt8();
          var len2, buf;
          if (opcodenum > 0 && opcodenum < Opcode2.OP_PUSHDATA1) {
            len2 = opcodenum;
            script2.chunks.push({
              buf: br.read(len2),
              len: len2,
              opcodenum
            });
          } else if (opcodenum === Opcode2.OP_PUSHDATA1) {
            len2 = br.readUInt8();
            buf = br.read(len2);
            script2.chunks.push({
              buf,
              len: len2,
              opcodenum
            });
          } else if (opcodenum === Opcode2.OP_PUSHDATA2) {
            len2 = br.readUInt16LE();
            buf = br.read(len2);
            script2.chunks.push({
              buf,
              len: len2,
              opcodenum
            });
          } else if (opcodenum === Opcode2.OP_PUSHDATA4) {
            len2 = br.readUInt32LE();
            buf = br.read(len2);
            script2.chunks.push({
              buf,
              len: len2,
              opcodenum
            });
          } else {
            script2.chunks.push({
              opcodenum
            });
          }
        } catch (e) {
          if (e instanceof RangeError) {
            throw new errors2.Script.InvalidBuffer(buffer2.toString("hex"));
          }
          throw e;
        }
      }
      return script2;
    };
    Script.prototype.toBuffer = function() {
      var bw = new BufferWriter2();
      for (var i2 = 0; i2 < this.chunks.length; i2++) {
        var chunk = this.chunks[i2];
        var opcodenum = chunk.opcodenum;
        bw.writeUInt8(chunk.opcodenum);
        if (chunk.buf) {
          if (opcodenum < Opcode2.OP_PUSHDATA1) {
            bw.write(chunk.buf);
          } else if (opcodenum === Opcode2.OP_PUSHDATA1) {
            bw.writeUInt8(chunk.len);
            bw.write(chunk.buf);
          } else if (opcodenum === Opcode2.OP_PUSHDATA2) {
            bw.writeUInt16LE(chunk.len);
            bw.write(chunk.buf);
          } else if (opcodenum === Opcode2.OP_PUSHDATA4) {
            bw.writeUInt32LE(chunk.len);
            bw.write(chunk.buf);
          }
        }
      }
      return bw.concat();
    };
    Script.fromASM = function(str) {
      var script2 = new Script();
      script2.chunks = [];
      var tokens = str.split(" ");
      var i2 = 0;
      while (i2 < tokens.length) {
        var token = tokens[i2];
        var opcode2 = Opcode2(token);
        var opcodenum = opcode2.toNumber();
        if (_2.isUndefined(opcodenum)) {
          var buf = buffer$2.Buffer.from(tokens[i2], "hex");
          script2.chunks.push({
            buf,
            len: buf.length,
            opcodenum: buf.length
          });
          i2 = i2 + 1;
        } else if (opcodenum === Opcode2.OP_PUSHDATA1 || opcodenum === Opcode2.OP_PUSHDATA2 || opcodenum === Opcode2.OP_PUSHDATA4) {
          script2.chunks.push({
            buf: buffer$2.Buffer.from(tokens[i2 + 2], "hex"),
            len: parseInt(tokens[i2 + 1]),
            opcodenum
          });
          i2 = i2 + 3;
        } else {
          script2.chunks.push({
            opcodenum
          });
          i2 = i2 + 1;
        }
      }
      return script2;
    };
    Script.fromHex = function(str) {
      return new Script(buffer$2.Buffer.from(str, "hex"));
    };
    Script.fromString = function(str) {
      if (JSUtil2.isHexa(str) || str.length === 0) {
        return new Script(buffer$2.Buffer.from(str, "hex"));
      }
      var script2 = new Script();
      script2.chunks = [];
      var tokens = str.split(" ");
      var i2 = 0;
      while (i2 < tokens.length) {
        var token = tokens[i2];
        var opcode2 = Opcode2(token);
        var opcodenum = opcode2.toNumber();
        if (_2.isUndefined(opcodenum)) {
          opcodenum = parseInt(token);
          if (opcodenum > 0 && opcodenum < Opcode2.OP_PUSHDATA1) {
            script2.chunks.push({
              buf: buffer$2.Buffer.from(tokens[i2 + 1].slice(2), "hex"),
              len: opcodenum,
              opcodenum
            });
            i2 = i2 + 2;
          } else {
            throw new Error("Invalid script: " + JSON.stringify(str));
          }
        } else if (opcodenum === Opcode2.OP_PUSHDATA1 || opcodenum === Opcode2.OP_PUSHDATA2 || opcodenum === Opcode2.OP_PUSHDATA4) {
          if (tokens[i2 + 2].slice(0, 2) !== "0x") {
            throw new Error("Pushdata data must start with 0x");
          }
          script2.chunks.push({
            buf: buffer$2.Buffer.from(tokens[i2 + 2].slice(2), "hex"),
            len: parseInt(tokens[i2 + 1]),
            opcodenum
          });
          i2 = i2 + 3;
        } else {
          script2.chunks.push({
            opcodenum
          });
          i2 = i2 + 1;
        }
      }
      return script2;
    };
    Script.prototype._chunkToString = function(chunk, type2) {
      var opcodenum = chunk.opcodenum;
      var asm = type2 === "asm";
      var str = "";
      if (!chunk.buf) {
        if (typeof Opcode2.reverseMap[opcodenum] !== "undefined") {
          if (asm) {
            if (opcodenum === 0) {
              str = str + " 0";
            } else if (opcodenum === 79) {
              str = str + " -1";
            } else {
              str = str + " " + Opcode2(opcodenum).toString();
            }
          } else {
            str = str + " " + Opcode2(opcodenum).toString();
          }
        } else {
          var numstr = opcodenum.toString(16);
          if (numstr.length % 2 !== 0) {
            numstr = "0" + numstr;
          }
          if (asm) {
            str = str + " " + numstr;
          } else {
            str = str + " 0x" + numstr;
          }
        }
      } else {
        if (!asm && opcodenum === Opcode2.OP_PUSHDATA1 || opcodenum === Opcode2.OP_PUSHDATA2 || opcodenum === Opcode2.OP_PUSHDATA4) {
          str = str + " " + Opcode2(opcodenum).toString();
        }
        if (chunk.len > 0) {
          if (asm) {
            str = str + " " + chunk.buf.toString("hex");
          } else {
            str = str + " " + chunk.len + " 0x" + chunk.buf.toString("hex");
          }
        }
      }
      return str;
    };
    Script.prototype.toASM = function() {
      var str = "";
      for (var i2 = 0; i2 < this.chunks.length; i2++) {
        var chunk = this.chunks[i2];
        str += this._chunkToString(chunk, "asm");
      }
      return str.substr(1);
    };
    Script.prototype.toString = function() {
      var str = "";
      for (var i2 = 0; i2 < this.chunks.length; i2++) {
        var chunk = this.chunks[i2];
        str += this._chunkToString(chunk);
      }
      return str.substr(1);
    };
    Script.prototype.toHex = function() {
      return this.toBuffer().toString("hex");
    };
    Script.prototype.inspect = function() {
      return "<Script: " + this.toString() + ">";
    };
    Script.prototype.isPublicKeyHashOut = function() {
      return !!(this.chunks.length === 5 && this.chunks[0].opcodenum === Opcode2.OP_DUP && this.chunks[1].opcodenum === Opcode2.OP_HASH160 && this.chunks[2].buf && this.chunks[2].buf.length === 20 && this.chunks[3].opcodenum === Opcode2.OP_EQUALVERIFY && this.chunks[4].opcodenum === Opcode2.OP_CHECKSIG);
    };
    Script.prototype.isPublicKeyHashIn = function() {
      if (this.chunks.length === 2) {
        var signatureBuf = this.chunks[0].buf;
        var pubkeyBuf = this.chunks[1].buf;
        if (signatureBuf && signatureBuf.length && signatureBuf[0] === 48 && pubkeyBuf && pubkeyBuf.length) {
          var version2 = pubkeyBuf[0];
          if ((version2 === 4 || version2 === 6 || version2 === 7) && pubkeyBuf.length === 65) {
            return true;
          } else if ((version2 === 3 || version2 === 2) && pubkeyBuf.length === 33) {
            return true;
          }
        }
      }
      return false;
    };
    Script.prototype.getPublicKey = function() {
      $2.checkState(this.isPublicKeyOut(), "Can't retrieve PublicKey from a non-PK output");
      return this.chunks[0].buf;
    };
    Script.prototype.getPublicKeyHash = function() {
      if (this.isPublicKeyHashOut()) {
        return this.chunks[2].buf;
      } else if (this.isWitnessPublicKeyHashOut()) {
        return this.chunks[1].buf;
      } else {
        throw new Error("Can't retrieve PublicKeyHash from a non-PKH output");
      }
    };
    Script.prototype.isPublicKeyOut = function() {
      if (this.chunks.length === 2 && this.chunks[0].buf && this.chunks[0].buf.length && this.chunks[1].opcodenum === Opcode2.OP_CHECKSIG) {
        var pubkeyBuf = this.chunks[0].buf;
        var version2 = pubkeyBuf[0];
        var isVersion = false;
        if ((version2 === 4 || version2 === 6 || version2 === 7) && pubkeyBuf.length === 65) {
          isVersion = true;
        } else if ((version2 === 3 || version2 === 2) && pubkeyBuf.length === 33) {
          isVersion = true;
        }
        if (isVersion) {
          return PublicKey2.isValid(pubkeyBuf);
        }
      }
      return false;
    };
    Script.prototype.isPublicKeyIn = function() {
      if (this.chunks.length === 1) {
        var signatureBuf = this.chunks[0].buf;
        if (signatureBuf && signatureBuf.length && signatureBuf[0] === 48) {
          return true;
        }
      }
      return false;
    };
    Script.prototype.isScriptHashOut = function() {
      var buf = this.toBuffer();
      return buf.length === 23 && buf[0] === Opcode2.OP_HASH160 && buf[1] === 20 && buf[buf.length - 1] === Opcode2.OP_EQUAL;
    };
    Script.prototype.isWitnessScriptHashOut = function() {
      var buf = this.toBuffer();
      return buf.length === 34 && buf[0] === Opcode2.OP_0 && buf[1] === 32;
    };
    Script.prototype.isWitnessPublicKeyHashOut = function() {
      var buf = this.toBuffer();
      return buf.length === 22 && buf[0] === Opcode2.OP_0 && buf[1] === 20;
    };
    Script.prototype.isTaproot = function() {
      var buf = this.toBuffer();
      return buf.length === 34 && buf[0] === Opcode2.OP_1 && buf[1] === 32;
    };
    Script.prototype.isWitnessProgram = function(values) {
      if (!values) {
        values = {};
      }
      var buf = this.toBuffer();
      if (buf.length < 4 || buf.length > 42) {
        return false;
      }
      if (buf[0] !== Opcode2.OP_0 && !(buf[0] >= Opcode2.OP_1 && buf[0] <= Opcode2.OP_16)) {
        return false;
      }
      if (buf.length === buf[1] + 2) {
        values.version = buf[0];
        values.program = buf.slice(2, buf.length);
        return true;
      }
      return false;
    };
    Script.prototype.isScriptHashIn = function() {
      if (this.chunks.length <= 1) {
        return false;
      }
      var redeemChunk = this.chunks[this.chunks.length - 1];
      var redeemBuf = redeemChunk.buf;
      if (!redeemBuf) {
        return false;
      }
      var redeemScript;
      try {
        redeemScript = Script.fromBuffer(redeemBuf);
      } catch (e) {
        if (e instanceof errors2.Script.InvalidBuffer) {
          return false;
        }
        throw e;
      }
      var type2 = redeemScript.classify();
      return type2 !== Script.types.UNKNOWN;
    };
    Script.prototype.isMultisigOut = function() {
      return this.chunks.length > 3 && Opcode2.isSmallIntOp(this.chunks[0].opcodenum) && this.chunks.slice(1, this.chunks.length - 2).every(function(obj) {
        return obj.buf && BufferUtil2.isBuffer(obj.buf);
      }) && Opcode2.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) && this.chunks[this.chunks.length - 1].opcodenum === Opcode2.OP_CHECKMULTISIG;
    };
    Script.prototype.isMultisigIn = function() {
      return this.chunks.length >= 2 && this.chunks[0].opcodenum === 0 && this.chunks.slice(1, this.chunks.length).every(function(obj) {
        return obj.buf && BufferUtil2.isBuffer(obj.buf) && Signature2.isTxDER(obj.buf);
      });
    };
    Script.prototype.isDataOut = function() {
      return this.chunks.length >= 1 && this.chunks[0].opcodenum === Opcode2.OP_RETURN && (this.chunks.length === 1 || this.chunks.length === 2 && this.chunks[1].buf && this.chunks[1].buf.length <= Script.OP_RETURN_STANDARD_SIZE && this.chunks[1].length === this.chunks.len);
    };
    Script.prototype.getData = function() {
      if (this.isDataOut() || this.isScriptHashOut() || this.isWitnessScriptHashOut() || this.isWitnessPublicKeyHashOut() || this.isTaproot()) {
        if (_2.isUndefined(this.chunks[1])) {
          return buffer$2.Buffer.alloc(0);
        } else {
          return buffer$2.Buffer.from(this.chunks[1].buf);
        }
      }
      if (this.isPublicKeyHashOut()) {
        return buffer$2.Buffer.from(this.chunks[2].buf);
      }
      throw new Error("Unrecognized script type to get data from");
    };
    Script.prototype.isPushOnly = function() {
      return _2.every(this.chunks, function(chunk) {
        return chunk.opcodenum <= Opcode2.OP_16;
      });
    };
    Script.types = {};
    Script.types.UNKNOWN = "Unknown";
    Script.types.PUBKEY_OUT = "Pay to public key";
    Script.types.PUBKEY_IN = "Spend from public key";
    Script.types.PUBKEYHASH_OUT = "Pay to public key hash";
    Script.types.PUBKEYHASH_IN = "Spend from public key hash";
    Script.types.SCRIPTHASH_OUT = "Pay to script hash";
    Script.types.SCRIPTHASH_IN = "Spend from script hash";
    Script.types.MULTISIG_OUT = "Pay to multisig";
    Script.types.MULTISIG_IN = "Spend from multisig";
    Script.types.DATA_OUT = "Data push";
    Script.OP_RETURN_STANDARD_SIZE = 80;
    Script.prototype.classify = function() {
      if (this._isInput) {
        return this.classifyInput();
      } else if (this._isOutput) {
        return this.classifyOutput();
      } else {
        var outputType = this.classifyOutput();
        return outputType != Script.types.UNKNOWN ? outputType : this.classifyInput();
      }
    };
    Script.outputIdentifiers = {};
    Script.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;
    Script.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;
    Script.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;
    Script.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;
    Script.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut;
    Script.prototype.classifyOutput = function() {
      for (var type2 in Script.outputIdentifiers) {
        if (Script.outputIdentifiers[type2].bind(this)()) {
          return Script.types[type2];
        }
      }
      return Script.types.UNKNOWN;
    };
    Script.inputIdentifiers = {};
    Script.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;
    Script.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;
    Script.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn;
    Script.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;
    Script.prototype.classifyInput = function() {
      for (var type2 in Script.inputIdentifiers) {
        if (Script.inputIdentifiers[type2].bind(this)()) {
          return Script.types[type2];
        }
      }
      return Script.types.UNKNOWN;
    };
    Script.prototype.isStandard = function() {
      return this.classify() !== Script.types.UNKNOWN;
    };
    Script.prototype.prepend = function(obj) {
      this._addByType(obj, true);
      return this;
    };
    Script.prototype.equals = function(script2) {
      $2.checkState(script2 instanceof Script, "Must provide another script");
      if (this.chunks.length !== script2.chunks.length) {
        return false;
      }
      var i2;
      for (i2 = 0; i2 < this.chunks.length; i2++) {
        if (BufferUtil2.isBuffer(this.chunks[i2].buf) && !BufferUtil2.isBuffer(script2.chunks[i2].buf)) {
          return false;
        }
        if (BufferUtil2.isBuffer(this.chunks[i2].buf) && !BufferUtil2.equals(this.chunks[i2].buf, script2.chunks[i2].buf)) {
          return false;
        } else if (this.chunks[i2].opcodenum !== script2.chunks[i2].opcodenum) {
          return false;
        }
      }
      return true;
    };
    Script.prototype.add = function(obj) {
      this._addByType(obj, false);
      return this;
    };
    Script.prototype._addByType = function(obj, prepend) {
      if (typeof obj === "string") {
        this._addOpcode(obj, prepend);
      } else if (typeof obj === "number") {
        this._addOpcode(obj, prepend);
      } else if (obj instanceof Opcode2) {
        this._addOpcode(obj, prepend);
      } else if (BufferUtil2.isBuffer(obj)) {
        this._addBuffer(obj, prepend);
      } else if (obj instanceof Script) {
        this.chunks = this.chunks.concat(obj.chunks);
      } else if (typeof obj === "object") {
        this._insertAtPosition(obj, prepend);
      } else {
        throw new Error("Invalid script chunk");
      }
    };
    Script.prototype._insertAtPosition = function(op, prepend) {
      if (prepend) {
        this.chunks.unshift(op);
      } else {
        this.chunks.push(op);
      }
    };
    Script.prototype._addOpcode = function(opcode2, prepend) {
      var op;
      if (typeof opcode2 === "number") {
        op = opcode2;
      } else if (opcode2 instanceof Opcode2) {
        op = opcode2.toNumber();
      } else {
        op = Opcode2(opcode2).toNumber();
      }
      this._insertAtPosition({
        opcodenum: op
      }, prepend);
      return this;
    };
    Script.prototype._addBuffer = function(buf, prepend) {
      var opcodenum;
      var len2 = buf.length;
      if (len2 >= 0 && len2 < Opcode2.OP_PUSHDATA1) {
        opcodenum = len2;
      } else if (len2 < Math.pow(2, 8)) {
        opcodenum = Opcode2.OP_PUSHDATA1;
      } else if (len2 < Math.pow(2, 16)) {
        opcodenum = Opcode2.OP_PUSHDATA2;
      } else if (len2 < Math.pow(2, 32)) {
        opcodenum = Opcode2.OP_PUSHDATA4;
      } else {
        throw new Error("You can't push that much data");
      }
      this._insertAtPosition({
        buf,
        len: len2,
        opcodenum
      }, prepend);
      return this;
    };
    Script.prototype.hasCodeseparators = function() {
      for (var i2 = 0; i2 < this.chunks.length; i2++) {
        if (this.chunks[i2].opcodenum === Opcode2.OP_CODESEPARATOR) {
          return true;
        }
      }
      return false;
    };
    Script.prototype.removeCodeseparators = function() {
      var chunks = [];
      for (var i2 = 0; i2 < this.chunks.length; i2++) {
        if (this.chunks[i2].opcodenum !== Opcode2.OP_CODESEPARATOR) {
          chunks.push(this.chunks[i2]);
        }
      }
      this.chunks = chunks;
      return this;
    };
    Script.buildMultisigOut = function(publicKeys, threshold, opts) {
      $2.checkArgument(
        threshold <= publicKeys.length,
        "Number of required signatures must be less than or equal to the number of public keys"
      );
      opts = opts || {};
      var script2 = new Script();
      script2.add(Opcode2.smallInt(threshold));
      publicKeys = _2.map(publicKeys, PublicKey2);
      var sorted = publicKeys;
      if (!opts.noSorting) {
        sorted = _2.sortBy(publicKeys, function(publicKey2) {
          return publicKey2.toString("hex");
        });
      }
      for (var i2 = 0; i2 < sorted.length; i2++) {
        var publicKey = sorted[i2];
        script2.add(publicKey.toBuffer());
      }
      script2.add(Opcode2.smallInt(publicKeys.length));
      script2.add(Opcode2.OP_CHECKMULTISIG);
      return script2;
    };
    Script.buildWitnessMultisigOutFromScript = function(script2) {
      if (script2 instanceof Script) {
        var s2 = new Script();
        s2.add(Opcode2.OP_0);
        s2.add(Hash2.sha256(script2.toBuffer()));
        return s2;
      } else {
        throw new TypeError("First argument is expected to be a p2sh script");
      }
    };
    Script.buildMultisigIn = function(pubkeys, threshold, signatures, opts) {
      $2.checkArgument(_2.isArray(pubkeys));
      $2.checkArgument(_2.isNumber(threshold));
      $2.checkArgument(_2.isArray(signatures));
      var s2 = new Script();
      s2.add(Opcode2.OP_0);
      _2.each(signatures, function(signature2) {
        $2.checkArgument(BufferUtil2.isBuffer(signature2), "Signatures must be an array of Buffers");
        s2.add(signature2);
      });
      return s2;
    };
    Script.buildP2SHMultisigIn = function(pubkeys, threshold, signatures, opts) {
      $2.checkArgument(_2.isArray(pubkeys));
      $2.checkArgument(_2.isNumber(threshold));
      $2.checkArgument(_2.isArray(signatures));
      opts = opts || {};
      var s2 = new Script();
      s2.add(Opcode2.OP_0);
      _2.each(signatures, function(signature2) {
        $2.checkArgument(BufferUtil2.isBuffer(signature2), "Signatures must be an array of Buffers");
        s2.add(signature2);
      });
      s2.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());
      return s2;
    };
    Script.buildPublicKeyHashOut = function(to) {
      $2.checkArgument(!_2.isUndefined(to));
      $2.checkArgument(to instanceof PublicKey2 || to instanceof Address2 || _2.isString(to));
      if (to instanceof PublicKey2) {
        to = to.toAddress();
      } else if (_2.isString(to)) {
        to = new Address2(to);
      }
      var s2 = new Script();
      s2.add(Opcode2.OP_DUP).add(Opcode2.OP_HASH160).add(to.hashBuffer).add(Opcode2.OP_EQUALVERIFY).add(Opcode2.OP_CHECKSIG);
      s2._network = to.network;
      return s2;
    };
    Script.buildWitnessV0Out = function(to) {
      $2.checkArgument(!_2.isUndefined(to));
      $2.checkArgument(to instanceof PublicKey2 || to instanceof Address2 || _2.isString(to));
      if (to instanceof PublicKey2) {
        to = to.toAddress(null, Address2.PayToWitnessPublicKeyHash);
      } else if (_2.isString(to)) {
        to = new Address2(to);
      }
      var s2 = new Script();
      s2.add(Opcode2.OP_0).add(to.hashBuffer);
      s2._network = to.network;
      return s2;
    };
    Script.buildPublicKeyOut = function(pubkey) {
      $2.checkArgument(pubkey instanceof PublicKey2);
      var s2 = new Script();
      s2.add(pubkey.toBuffer()).add(Opcode2.OP_CHECKSIG);
      return s2;
    };
    Script.buildDataOut = function(data2, encoding) {
      $2.checkArgument(_2.isUndefined(data2) || _2.isString(data2) || BufferUtil2.isBuffer(data2));
      if (_2.isString(data2)) {
        data2 = buffer$2.Buffer.from(data2, encoding);
      }
      var s2 = new Script();
      s2.add(Opcode2.OP_RETURN);
      if (!_2.isUndefined(data2)) {
        s2.add(data2);
      }
      return s2;
    };
    Script.buildScriptHashOut = function(script2) {
      $2.checkArgument(script2 instanceof Script || script2 instanceof Address2 && script2.isPayToScriptHash());
      var s2 = new Script();
      s2.add(Opcode2.OP_HASH160).add(script2 instanceof Address2 ? script2.hashBuffer : Hash2.sha256ripemd160(script2.toBuffer())).add(Opcode2.OP_EQUAL);
      s2._network = script2._network || script2.network;
      return s2;
    };
    Script.buildPublicKeyIn = function(signature2, sigtype) {
      $2.checkArgument(signature2 instanceof Signature2 || BufferUtil2.isBuffer(signature2));
      $2.checkArgument(_2.isUndefined(sigtype) || _2.isNumber(sigtype));
      if (signature2 instanceof Signature2) {
        signature2 = signature2.toBuffer();
      }
      var script2 = new Script();
      script2.add(BufferUtil2.concat([
        signature2,
        BufferUtil2.integerAsSingleByteBuffer(sigtype || Signature2.SIGHASH_ALL)
      ]));
      return script2;
    };
    Script.buildPublicKeyHashIn = function(publicKey, signature2, sigtype) {
      $2.checkArgument(signature2 instanceof Signature2 || BufferUtil2.isBuffer(signature2));
      $2.checkArgument(_2.isUndefined(sigtype) || _2.isNumber(sigtype));
      if (signature2 instanceof Signature2) {
        signature2 = signature2.toBuffer();
      }
      var script2 = new Script().add(BufferUtil2.concat([
        signature2,
        BufferUtil2.integerAsSingleByteBuffer(sigtype || Signature2.SIGHASH_ALL)
      ])).add(new PublicKey2(publicKey).toBuffer());
      return script2;
    };
    Script.empty = function() {
      return new Script();
    };
    Script.prototype.toScriptHashOut = function() {
      return Script.buildScriptHashOut(this);
    };
    Script.fromAddress = function(address2) {
      address2 = Address2(address2);
      if (address2.isPayToScriptHash()) {
        return Script.buildScriptHashOut(address2);
      } else if (address2.isPayToPublicKeyHash()) {
        return Script.buildPublicKeyHashOut(address2);
      } else if (address2.isPayToWitnessPublicKeyHash()) {
        return Script.buildWitnessV0Out(address2);
      } else if (address2.isPayToWitnessScriptHash()) {
        return Script.buildWitnessV0Out(address2);
      }
      throw new errors2.Script.UnrecognizedAddress(address2);
    };
    Script.prototype.getAddressInfo = function(opts) {
      if (this._isInput) {
        return this._getInputAddressInfo();
      } else if (this._isOutput) {
        return this._getOutputAddressInfo();
      } else {
        var info = this._getOutputAddressInfo();
        if (!info) {
          return this._getInputAddressInfo();
        }
        return info;
      }
    };
    Script.prototype._getOutputAddressInfo = function() {
      var info = {};
      if (this.isScriptHashOut()) {
        info.hashBuffer = this.getData();
        info.type = Address2.PayToScriptHash;
      } else if (this.isPublicKeyHashOut()) {
        info.hashBuffer = this.getData();
        info.type = Address2.PayToPublicKeyHash;
      } else if (this.isWitnessScriptHashOut()) {
        info.hashBuffer = this.getData();
        info.type = Address2.PayToWitnessScriptHash;
      } else if (this.isWitnessPublicKeyHashOut()) {
        info.hashBuffer = this.getData();
        info.type = Address2.PayToWitnessPublicKeyHash;
      } else if (this.isTaproot()) {
        info.hashBuffer = this.getData();
        info.type = Address2.PayToTaproot;
      } else {
        return false;
      }
      return info;
    };
    Script.prototype._getInputAddressInfo = function() {
      var info = {};
      if (this.isPublicKeyHashIn()) {
        info.hashBuffer = Hash2.sha256ripemd160(this.chunks[1].buf);
        info.type = Address2.PayToPublicKeyHash;
      } else if (this.isScriptHashIn()) {
        info.hashBuffer = Hash2.sha256ripemd160(this.chunks[this.chunks.length - 1].buf);
        info.type = Address2.PayToScriptHash;
      } else {
        return false;
      }
      return info;
    };
    Script.prototype.toAddress = function(network) {
      var info = this.getAddressInfo();
      if (!info) {
        return false;
      }
      info.network = Networks.get(network) || this._network || Networks.defaultNetwork;
      return new Address2(info);
    };
    Script.prototype.findAndDelete = function(script2) {
      var buf = script2.toBuffer();
      var hex = buf.toString("hex");
      for (var i2 = 0; i2 < this.chunks.length; i2++) {
        var script22 = Script({
          chunks: [this.chunks[i2]]
        });
        var buf2 = script22.toBuffer();
        var hex2 = buf2.toString("hex");
        if (hex === hex2) {
          this.chunks.splice(i2, 1);
        }
      }
      return this;
    };
    Script.prototype.checkMinimalPush = function(i2) {
      var chunk = this.chunks[i2];
      var buf = chunk.buf;
      var opcodenum = chunk.opcodenum;
      if (!buf) {
        return true;
      }
      if (buf.length === 0) {
        return opcodenum === Opcode2.OP_0;
      } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {
        return opcodenum === Opcode2.OP_1 + (buf[0] - 1);
      } else if (buf.length === 1 && buf[0] === 129) {
        return opcodenum === Opcode2.OP_1NEGATE;
      } else if (buf.length <= 75) {
        return opcodenum === buf.length;
      } else if (buf.length <= 255) {
        return opcodenum === Opcode2.OP_PUSHDATA1;
      } else if (buf.length <= 65535) {
        return opcodenum === Opcode2.OP_PUSHDATA2;
      }
      return true;
    };
    Script.prototype._decodeOP_N = function(opcode2) {
      if (opcode2 === Opcode2.OP_0) {
        return 0;
      } else if (opcode2 >= Opcode2.OP_1 && opcode2 <= Opcode2.OP_16) {
        return opcode2 - (Opcode2.OP_1 - 1);
      } else {
        throw new Error("Invalid opcode: " + JSON.stringify(opcode2));
      }
    };
    Script.prototype.getSignatureOperationsCount = function(accurate) {
      accurate = _2.isUndefined(accurate) ? true : accurate;
      var self2 = this;
      var n2 = 0;
      var lastOpcode = Opcode2.OP_INVALIDOPCODE;
      _2.each(self2.chunks, function getChunk(chunk) {
        var opcode2 = chunk.opcodenum;
        if (opcode2 == Opcode2.OP_CHECKSIG || opcode2 == Opcode2.OP_CHECKSIGVERIFY) {
          n2++;
        } else if (opcode2 == Opcode2.OP_CHECKMULTISIG || opcode2 == Opcode2.OP_CHECKMULTISIGVERIFY) {
          if (accurate && lastOpcode >= Opcode2.OP_1 && lastOpcode <= Opcode2.OP_16) {
            n2 += self2._decodeOP_N(lastOpcode);
          } else {
            n2 += 20;
          }
        }
        lastOpcode = opcode2;
      });
      return n2;
    };
    script = Script;
    return script;
  }
  var transaction$1 = { exports: {} };
  var bufferCompare;
  var hasRequiredBufferCompare;
  function requireBufferCompare() {
    if (hasRequiredBufferCompare)
      return bufferCompare;
    hasRequiredBufferCompare = 1;
    bufferCompare = function(a, b) {
      if (typeof a.compare === "function")
        return a.compare(b);
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      var i2 = 0;
      var len2 = Math.min(x, y);
      while (i2 < len2) {
        if (a[i2] !== b[i2])
          break;
        ++i2;
      }
      if (i2 !== len2) {
        x = a[i2];
        y = b[i2];
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    return bufferCompare;
  }
  var output;
  var hasRequiredOutput;
  function requireOutput() {
    if (hasRequiredOutput)
      return output;
    hasRequiredOutput = 1;
    var _2 = lodashExports;
    var BN2 = bn$2;
    var bufferUtil2 = bufferExports;
    var JSUtil2 = js$1;
    var BufferWriter2 = bufferwriter;
    var Script = requireScript();
    var $2 = preconditions;
    var errors2 = errorsExports;
    var MAX_SAFE_INTEGER = 9007199254740991;
    function Output(args) {
      if (!(this instanceof Output)) {
        return new Output(args);
      }
      if (_2.isObject(args)) {
        this.satoshis = args.satoshis;
        if (bufferUtil2.isBuffer(args.script)) {
          this._scriptBuffer = args.script;
        } else {
          var script2;
          if (_2.isString(args.script) && JSUtil2.isHexa(args.script)) {
            script2 = buffer$2.Buffer.from(args.script, "hex");
          } else {
            script2 = args.script;
          }
          this.setScript(script2);
        }
      } else {
        throw new TypeError("Unrecognized argument for Output");
      }
    }
    Object.defineProperty(Output.prototype, "script", {
      configurable: false,
      enumerable: true,
      get: function() {
        if (this._script) {
          return this._script;
        } else {
          this.setScriptFromBuffer(this._scriptBuffer);
          return this._script;
        }
      }
    });
    Object.defineProperty(Output.prototype, "satoshis", {
      configurable: false,
      enumerable: true,
      get: function() {
        return this._satoshis;
      },
      set: function(num) {
        if (num instanceof BN2) {
          this._satoshisBN = num;
          this._satoshis = num.toNumber();
        } else if (_2.isString(num)) {
          this._satoshis = parseInt(num);
          this._satoshisBN = BN2.fromNumber(this._satoshis);
        } else {
          $2.checkArgument(
            JSUtil2.isNaturalNumber(num),
            "Output satoshis is not a natural number"
          );
          this._satoshisBN = BN2.fromNumber(num);
          this._satoshis = num;
        }
        $2.checkState(
          JSUtil2.isNaturalNumber(this._satoshis),
          "Output satoshis is not a natural number"
        );
      }
    });
    Output.prototype.invalidSatoshis = function() {
      if (this._satoshis > MAX_SAFE_INTEGER) {
        return "transaction txout satoshis greater than max safe integer";
      }
      if (this._satoshis !== this._satoshisBN.toNumber()) {
        return "transaction txout satoshis has corrupted value";
      }
      if (this._satoshis < 0) {
        return "transaction txout negative";
      }
      return false;
    };
    Output.prototype.toObject = Output.prototype.toJSON = function toObject2() {
      var obj = {
        satoshis: this.satoshis
      };
      obj.script = this._scriptBuffer.toString("hex");
      return obj;
    };
    Output.fromObject = function(data2) {
      return new Output(data2);
    };
    Output.prototype.setScriptFromBuffer = function(buffer2) {
      this._scriptBuffer = buffer2;
      try {
        this._script = Script.fromBuffer(this._scriptBuffer);
        this._script._isOutput = true;
      } catch (e) {
        if (e instanceof errors2.Script.InvalidBuffer) {
          this._script = null;
        } else {
          throw e;
        }
      }
    };
    Output.prototype.setScript = function(script2) {
      if (script2 instanceof Script) {
        this._scriptBuffer = script2.toBuffer();
        this._script = script2;
        this._script._isOutput = true;
      } else if (_2.isString(script2)) {
        this._script = Script.fromString(script2);
        this._scriptBuffer = this._script.toBuffer();
        this._script._isOutput = true;
      } else if (bufferUtil2.isBuffer(script2)) {
        this.setScriptFromBuffer(script2);
      } else {
        throw new TypeError("Invalid argument type: script");
      }
      return this;
    };
    Output.prototype.inspect = function() {
      var scriptStr;
      if (this.script) {
        scriptStr = this.script.inspect();
      } else {
        scriptStr = this._scriptBuffer.toString("hex");
      }
      return "<Output (" + this.satoshis + " sats) " + scriptStr + ">";
    };
    Output.fromBufferReader = function(br) {
      var obj = {};
      obj.satoshis = br.readUInt64LEBN();
      var size = br.readVarintNum();
      if (size !== 0) {
        obj.script = br.read(size);
      } else {
        obj.script = buffer$2.Buffer.from([]);
      }
      return new Output(obj);
    };
    Output.prototype.toBufferWriter = function(writer) {
      if (!writer) {
        writer = new BufferWriter2();
      }
      writer.writeUInt64LEBN(this._satoshisBN);
      var script2 = this._scriptBuffer;
      writer.writeVarintNum(script2.length);
      writer.write(script2);
      return writer;
    };
    output = Output;
    return output;
  }
  const name = "bigi";
  const version = "1.4.2";
  const description = "Big integers.";
  const keywords = [
    "cryptography",
    "math",
    "bitcoin",
    "arbitrary",
    "precision",
    "arithmetic",
    "big",
    "integer",
    "int",
    "number",
    "biginteger",
    "bigint",
    "bignumber",
    "decimal",
    "float"
  ];
  const devDependencies = {
    coveralls: "^2.11.2",
    istanbul: "^0.3.5",
    jshint: "^2.5.1",
    mocha: "^2.1.0",
    mochify: "^2.1.0"
  };
  const repository = {
    url: "https://github.com/cryptocoinjs/bigi",
    type: "git"
  };
  const main = "./lib/index.js";
  const scripts = {
    "browser-test": "./node_modules/.bin/mochify --wd -R spec",
    test: "./node_modules/.bin/_mocha -- test/*.js",
    jshint: "./node_modules/.bin/jshint --config jshint.json lib/*.js ; true",
    unit: "./node_modules/.bin/mocha",
    coverage: "./node_modules/.bin/istanbul cover ./node_modules/.bin/_mocha -- --reporter list test/*.js",
    coveralls: "npm run-script coverage && node ./node_modules/.bin/coveralls < coverage/lcov.info"
  };
  const dependencies = {};
  const testling = {
    files: "test/*.js",
    harness: "mocha",
    browsers: [
      "ie/9..latest",
      "firefox/latest",
      "chrome/latest",
      "safari/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  };
  const require$$0 = {
    name,
    version,
    description,
    keywords,
    devDependencies,
    repository,
    main,
    scripts,
    dependencies,
    testling
  };
  function BigInteger$9(a, b, c) {
    if (!(this instanceof BigInteger$9))
      return new BigInteger$9(a, b, c);
    if (a != null) {
      if ("number" == typeof a)
        this.fromNumber(a, b, c);
      else if (b == null && "string" != typeof a)
        this.fromString(a, 256);
      else
        this.fromString(a, b);
    }
  }
  var proto = BigInteger$9.prototype;
  proto.__bigi = require$$0.version;
  BigInteger$9.isBigInteger = function(obj, check_ver) {
    return obj && obj.__bigi && (!check_ver || obj.__bigi === proto.__bigi);
  };
  var dbits;
  function am1(i2, x, w, j, c, n2) {
    while (--n2 >= 0) {
      var v = x * this[i2++] + w[j] + c;
      c = Math.floor(v / 67108864);
      w[j++] = v & 67108863;
    }
    return c;
  }
  BigInteger$9.prototype.am = am1;
  dbits = 26;
  BigInteger$9.prototype.DB = dbits;
  BigInteger$9.prototype.DM = (1 << dbits) - 1;
  var DV = BigInteger$9.prototype.DV = 1 << dbits;
  var BI_FP = 52;
  BigInteger$9.prototype.FV = Math.pow(2, BI_FP);
  BigInteger$9.prototype.F1 = BI_FP - dbits;
  BigInteger$9.prototype.F2 = 2 * dbits - BI_FP;
  var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
  var BI_RC = new Array();
  var rr, vv;
  rr = "0".charCodeAt(0);
  for (vv = 0; vv <= 9; ++vv)
    BI_RC[rr++] = vv;
  rr = "a".charCodeAt(0);
  for (vv = 10; vv < 36; ++vv)
    BI_RC[rr++] = vv;
  rr = "A".charCodeAt(0);
  for (vv = 10; vv < 36; ++vv)
    BI_RC[rr++] = vv;
  function int2char(n2) {
    return BI_RM.charAt(n2);
  }
  function intAt(s2, i2) {
    var c = BI_RC[s2.charCodeAt(i2)];
    return c == null ? -1 : c;
  }
  function bnpCopyTo(r2) {
    for (var i2 = this.t - 1; i2 >= 0; --i2)
      r2[i2] = this[i2];
    r2.t = this.t;
    r2.s = this.s;
  }
  function bnpFromInt(x) {
    this.t = 1;
    this.s = x < 0 ? -1 : 0;
    if (x > 0)
      this[0] = x;
    else if (x < -1)
      this[0] = x + DV;
    else
      this.t = 0;
  }
  function nbv(i2) {
    var r2 = new BigInteger$9();
    r2.fromInt(i2);
    return r2;
  }
  function bnpFromString(s2, b) {
    var self2 = this;
    var k2;
    if (b == 16)
      k2 = 4;
    else if (b == 8)
      k2 = 3;
    else if (b == 256)
      k2 = 8;
    else if (b == 2)
      k2 = 1;
    else if (b == 32)
      k2 = 5;
    else if (b == 4)
      k2 = 2;
    else {
      self2.fromRadix(s2, b);
      return;
    }
    self2.t = 0;
    self2.s = 0;
    var i2 = s2.length, mi = false, sh2 = 0;
    while (--i2 >= 0) {
      var x = k2 == 8 ? s2[i2] & 255 : intAt(s2, i2);
      if (x < 0) {
        if (s2.charAt(i2) == "-")
          mi = true;
        continue;
      }
      mi = false;
      if (sh2 == 0)
        self2[self2.t++] = x;
      else if (sh2 + k2 > self2.DB) {
        self2[self2.t - 1] |= (x & (1 << self2.DB - sh2) - 1) << sh2;
        self2[self2.t++] = x >> self2.DB - sh2;
      } else
        self2[self2.t - 1] |= x << sh2;
      sh2 += k2;
      if (sh2 >= self2.DB)
        sh2 -= self2.DB;
    }
    if (k2 == 8 && (s2[0] & 128) != 0) {
      self2.s = -1;
      if (sh2 > 0)
        self2[self2.t - 1] |= (1 << self2.DB - sh2) - 1 << sh2;
    }
    self2.clamp();
    if (mi)
      BigInteger$9.ZERO.subTo(self2, self2);
  }
  function bnpClamp() {
    var c = this.s & this.DM;
    while (this.t > 0 && this[this.t - 1] == c)
      --this.t;
  }
  function bnToString(b) {
    var self2 = this;
    if (self2.s < 0)
      return "-" + self2.negate().toString(b);
    var k2;
    if (b == 16)
      k2 = 4;
    else if (b == 8)
      k2 = 3;
    else if (b == 2)
      k2 = 1;
    else if (b == 32)
      k2 = 5;
    else if (b == 4)
      k2 = 2;
    else
      return self2.toRadix(b);
    var km = (1 << k2) - 1, d, m = false, r2 = "", i2 = self2.t;
    var p2 = self2.DB - i2 * self2.DB % k2;
    if (i2-- > 0) {
      if (p2 < self2.DB && (d = self2[i2] >> p2) > 0) {
        m = true;
        r2 = int2char(d);
      }
      while (i2 >= 0) {
        if (p2 < k2) {
          d = (self2[i2] & (1 << p2) - 1) << k2 - p2;
          d |= self2[--i2] >> (p2 += self2.DB - k2);
        } else {
          d = self2[i2] >> (p2 -= k2) & km;
          if (p2 <= 0) {
            p2 += self2.DB;
            --i2;
          }
        }
        if (d > 0)
          m = true;
        if (m)
          r2 += int2char(d);
      }
    }
    return m ? r2 : "0";
  }
  function bnNegate() {
    var r2 = new BigInteger$9();
    BigInteger$9.ZERO.subTo(this, r2);
    return r2;
  }
  function bnAbs() {
    return this.s < 0 ? this.negate() : this;
  }
  function bnCompareTo(a) {
    var r2 = this.s - a.s;
    if (r2 != 0)
      return r2;
    var i2 = this.t;
    r2 = i2 - a.t;
    if (r2 != 0)
      return this.s < 0 ? -r2 : r2;
    while (--i2 >= 0)
      if ((r2 = this[i2] - a[i2]) != 0)
        return r2;
    return 0;
  }
  function nbits(x) {
    var r2 = 1, t;
    if ((t = x >>> 16) != 0) {
      x = t;
      r2 += 16;
    }
    if ((t = x >> 8) != 0) {
      x = t;
      r2 += 8;
    }
    if ((t = x >> 4) != 0) {
      x = t;
      r2 += 4;
    }
    if ((t = x >> 2) != 0) {
      x = t;
      r2 += 2;
    }
    if ((t = x >> 1) != 0) {
      x = t;
      r2 += 1;
    }
    return r2;
  }
  function bnBitLength() {
    if (this.t <= 0)
      return 0;
    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
  }
  function bnByteLength() {
    return this.bitLength() >> 3;
  }
  function bnpDLShiftTo(n2, r2) {
    var i2;
    for (i2 = this.t - 1; i2 >= 0; --i2)
      r2[i2 + n2] = this[i2];
    for (i2 = n2 - 1; i2 >= 0; --i2)
      r2[i2] = 0;
    r2.t = this.t + n2;
    r2.s = this.s;
  }
  function bnpDRShiftTo(n2, r2) {
    for (var i2 = n2; i2 < this.t; ++i2)
      r2[i2 - n2] = this[i2];
    r2.t = Math.max(this.t - n2, 0);
    r2.s = this.s;
  }
  function bnpLShiftTo(n2, r2) {
    var self2 = this;
    var bs = n2 % self2.DB;
    var cbs = self2.DB - bs;
    var bm = (1 << cbs) - 1;
    var ds = Math.floor(n2 / self2.DB), c = self2.s << bs & self2.DM, i2;
    for (i2 = self2.t - 1; i2 >= 0; --i2) {
      r2[i2 + ds + 1] = self2[i2] >> cbs | c;
      c = (self2[i2] & bm) << bs;
    }
    for (i2 = ds - 1; i2 >= 0; --i2)
      r2[i2] = 0;
    r2[ds] = c;
    r2.t = self2.t + ds + 1;
    r2.s = self2.s;
    r2.clamp();
  }
  function bnpRShiftTo(n2, r2) {
    var self2 = this;
    r2.s = self2.s;
    var ds = Math.floor(n2 / self2.DB);
    if (ds >= self2.t) {
      r2.t = 0;
      return;
    }
    var bs = n2 % self2.DB;
    var cbs = self2.DB - bs;
    var bm = (1 << bs) - 1;
    r2[0] = self2[ds] >> bs;
    for (var i2 = ds + 1; i2 < self2.t; ++i2) {
      r2[i2 - ds - 1] |= (self2[i2] & bm) << cbs;
      r2[i2 - ds] = self2[i2] >> bs;
    }
    if (bs > 0)
      r2[self2.t - ds - 1] |= (self2.s & bm) << cbs;
    r2.t = self2.t - ds;
    r2.clamp();
  }
  function bnpSubTo(a, r2) {
    var self2 = this;
    var i2 = 0, c = 0, m = Math.min(a.t, self2.t);
    while (i2 < m) {
      c += self2[i2] - a[i2];
      r2[i2++] = c & self2.DM;
      c >>= self2.DB;
    }
    if (a.t < self2.t) {
      c -= a.s;
      while (i2 < self2.t) {
        c += self2[i2];
        r2[i2++] = c & self2.DM;
        c >>= self2.DB;
      }
      c += self2.s;
    } else {
      c += self2.s;
      while (i2 < a.t) {
        c -= a[i2];
        r2[i2++] = c & self2.DM;
        c >>= self2.DB;
      }
      c -= a.s;
    }
    r2.s = c < 0 ? -1 : 0;
    if (c < -1)
      r2[i2++] = self2.DV + c;
    else if (c > 0)
      r2[i2++] = c;
    r2.t = i2;
    r2.clamp();
  }
  function bnpMultiplyTo(a, r2) {
    var x = this.abs(), y = a.abs();
    var i2 = x.t;
    r2.t = i2 + y.t;
    while (--i2 >= 0)
      r2[i2] = 0;
    for (i2 = 0; i2 < y.t; ++i2)
      r2[i2 + x.t] = x.am(0, y[i2], r2, i2, 0, x.t);
    r2.s = 0;
    r2.clamp();
    if (this.s != a.s)
      BigInteger$9.ZERO.subTo(r2, r2);
  }
  function bnpSquareTo(r2) {
    var x = this.abs();
    var i2 = r2.t = 2 * x.t;
    while (--i2 >= 0)
      r2[i2] = 0;
    for (i2 = 0; i2 < x.t - 1; ++i2) {
      var c = x.am(i2, x[i2], r2, 2 * i2, 0, 1);
      if ((r2[i2 + x.t] += x.am(i2 + 1, 2 * x[i2], r2, 2 * i2 + 1, c, x.t - i2 - 1)) >= x.DV) {
        r2[i2 + x.t] -= x.DV;
        r2[i2 + x.t + 1] = 1;
      }
    }
    if (r2.t > 0)
      r2[r2.t - 1] += x.am(i2, x[i2], r2, 2 * i2, 0, 1);
    r2.s = 0;
    r2.clamp();
  }
  function bnpDivRemTo(m, q, r2) {
    var self2 = this;
    var pm = m.abs();
    if (pm.t <= 0)
      return;
    var pt = self2.abs();
    if (pt.t < pm.t) {
      if (q != null)
        q.fromInt(0);
      if (r2 != null)
        self2.copyTo(r2);
      return;
    }
    if (r2 == null)
      r2 = new BigInteger$9();
    var y = new BigInteger$9(), ts = self2.s, ms = m.s;
    var nsh = self2.DB - nbits(pm[pm.t - 1]);
    if (nsh > 0) {
      pm.lShiftTo(nsh, y);
      pt.lShiftTo(nsh, r2);
    } else {
      pm.copyTo(y);
      pt.copyTo(r2);
    }
    var ys = y.t;
    var y0 = y[ys - 1];
    if (y0 == 0)
      return;
    var yt = y0 * (1 << self2.F1) + (ys > 1 ? y[ys - 2] >> self2.F2 : 0);
    var d1 = self2.FV / yt, d2 = (1 << self2.F1) / yt, e = 1 << self2.F2;
    var i2 = r2.t, j = i2 - ys, t = q == null ? new BigInteger$9() : q;
    y.dlShiftTo(j, t);
    if (r2.compareTo(t) >= 0) {
      r2[r2.t++] = 1;
      r2.subTo(t, r2);
    }
    BigInteger$9.ONE.dlShiftTo(ys, t);
    t.subTo(y, y);
    while (y.t < ys)
      y[y.t++] = 0;
    while (--j >= 0) {
      var qd = r2[--i2] == y0 ? self2.DM : Math.floor(r2[i2] * d1 + (r2[i2 - 1] + e) * d2);
      if ((r2[i2] += y.am(0, qd, r2, j, 0, ys)) < qd) {
        y.dlShiftTo(j, t);
        r2.subTo(t, r2);
        while (r2[i2] < --qd)
          r2.subTo(t, r2);
      }
    }
    if (q != null) {
      r2.drShiftTo(ys, q);
      if (ts != ms)
        BigInteger$9.ZERO.subTo(q, q);
    }
    r2.t = ys;
    r2.clamp();
    if (nsh > 0)
      r2.rShiftTo(nsh, r2);
    if (ts < 0)
      BigInteger$9.ZERO.subTo(r2, r2);
  }
  function bnMod(a) {
    var r2 = new BigInteger$9();
    this.abs().divRemTo(a, null, r2);
    if (this.s < 0 && r2.compareTo(BigInteger$9.ZERO) > 0)
      a.subTo(r2, r2);
    return r2;
  }
  function Classic(m) {
    this.m = m;
  }
  function cConvert(x) {
    if (x.s < 0 || x.compareTo(this.m) >= 0)
      return x.mod(this.m);
    else
      return x;
  }
  function cRevert(x) {
    return x;
  }
  function cReduce(x) {
    x.divRemTo(this.m, null, x);
  }
  function cMulTo(x, y, r2) {
    x.multiplyTo(y, r2);
    this.reduce(r2);
  }
  function cSqrTo(x, r2) {
    x.squareTo(r2);
    this.reduce(r2);
  }
  Classic.prototype.convert = cConvert;
  Classic.prototype.revert = cRevert;
  Classic.prototype.reduce = cReduce;
  Classic.prototype.mulTo = cMulTo;
  Classic.prototype.sqrTo = cSqrTo;
  function bnpInvDigit() {
    if (this.t < 1)
      return 0;
    var x = this[0];
    if ((x & 1) == 0)
      return 0;
    var y = x & 3;
    y = y * (2 - (x & 15) * y) & 15;
    y = y * (2 - (x & 255) * y) & 255;
    y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
    y = y * (2 - x * y % this.DV) % this.DV;
    return y > 0 ? this.DV - y : -y;
  }
  function Montgomery(m) {
    this.m = m;
    this.mp = m.invDigit();
    this.mpl = this.mp & 32767;
    this.mph = this.mp >> 15;
    this.um = (1 << m.DB - 15) - 1;
    this.mt2 = 2 * m.t;
  }
  function montConvert(x) {
    var r2 = new BigInteger$9();
    x.abs().dlShiftTo(this.m.t, r2);
    r2.divRemTo(this.m, null, r2);
    if (x.s < 0 && r2.compareTo(BigInteger$9.ZERO) > 0)
      this.m.subTo(r2, r2);
    return r2;
  }
  function montRevert(x) {
    var r2 = new BigInteger$9();
    x.copyTo(r2);
    this.reduce(r2);
    return r2;
  }
  function montReduce(x) {
    while (x.t <= this.mt2)
      x[x.t++] = 0;
    for (var i2 = 0; i2 < this.m.t; ++i2) {
      var j = x[i2] & 32767;
      var u0 = j * this.mpl + ((j * this.mph + (x[i2] >> 15) * this.mpl & this.um) << 15) & x.DM;
      j = i2 + this.m.t;
      x[j] += this.m.am(0, u0, x, i2, 0, this.m.t);
      while (x[j] >= x.DV) {
        x[j] -= x.DV;
        x[++j]++;
      }
    }
    x.clamp();
    x.drShiftTo(this.m.t, x);
    if (x.compareTo(this.m) >= 0)
      x.subTo(this.m, x);
  }
  function montSqrTo(x, r2) {
    x.squareTo(r2);
    this.reduce(r2);
  }
  function montMulTo(x, y, r2) {
    x.multiplyTo(y, r2);
    this.reduce(r2);
  }
  Montgomery.prototype.convert = montConvert;
  Montgomery.prototype.revert = montRevert;
  Montgomery.prototype.reduce = montReduce;
  Montgomery.prototype.mulTo = montMulTo;
  Montgomery.prototype.sqrTo = montSqrTo;
  function bnpIsEven() {
    return (this.t > 0 ? this[0] & 1 : this.s) == 0;
  }
  function bnpExp(e, z) {
    if (e > 4294967295 || e < 1)
      return BigInteger$9.ONE;
    var r2 = new BigInteger$9(), r22 = new BigInteger$9(), g2 = z.convert(this), i2 = nbits(e) - 1;
    g2.copyTo(r2);
    while (--i2 >= 0) {
      z.sqrTo(r2, r22);
      if ((e & 1 << i2) > 0)
        z.mulTo(r22, g2, r2);
      else {
        var t = r2;
        r2 = r22;
        r22 = t;
      }
    }
    return z.revert(r2);
  }
  function bnModPowInt(e, m) {
    var z;
    if (e < 256 || m.isEven())
      z = new Classic(m);
    else
      z = new Montgomery(m);
    return this.exp(e, z);
  }
  proto.copyTo = bnpCopyTo;
  proto.fromInt = bnpFromInt;
  proto.fromString = bnpFromString;
  proto.clamp = bnpClamp;
  proto.dlShiftTo = bnpDLShiftTo;
  proto.drShiftTo = bnpDRShiftTo;
  proto.lShiftTo = bnpLShiftTo;
  proto.rShiftTo = bnpRShiftTo;
  proto.subTo = bnpSubTo;
  proto.multiplyTo = bnpMultiplyTo;
  proto.squareTo = bnpSquareTo;
  proto.divRemTo = bnpDivRemTo;
  proto.invDigit = bnpInvDigit;
  proto.isEven = bnpIsEven;
  proto.exp = bnpExp;
  proto.toString = bnToString;
  proto.negate = bnNegate;
  proto.abs = bnAbs;
  proto.compareTo = bnCompareTo;
  proto.bitLength = bnBitLength;
  proto.byteLength = bnByteLength;
  proto.mod = bnMod;
  proto.modPowInt = bnModPowInt;
  function bnClone() {
    var r2 = new BigInteger$9();
    this.copyTo(r2);
    return r2;
  }
  function bnIntValue() {
    if (this.s < 0) {
      if (this.t == 1)
        return this[0] - this.DV;
      else if (this.t == 0)
        return -1;
    } else if (this.t == 1)
      return this[0];
    else if (this.t == 0)
      return 0;
    return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
  }
  function bnByteValue() {
    return this.t == 0 ? this.s : this[0] << 24 >> 24;
  }
  function bnShortValue() {
    return this.t == 0 ? this.s : this[0] << 16 >> 16;
  }
  function bnpChunkSize(r2) {
    return Math.floor(Math.LN2 * this.DB / Math.log(r2));
  }
  function bnSigNum() {
    if (this.s < 0)
      return -1;
    else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
      return 0;
    else
      return 1;
  }
  function bnpToRadix(b) {
    if (b == null)
      b = 10;
    if (this.signum() == 0 || b < 2 || b > 36)
      return "0";
    var cs = this.chunkSize(b);
    var a = Math.pow(b, cs);
    var d = nbv(a), y = new BigInteger$9(), z = new BigInteger$9(), r2 = "";
    this.divRemTo(d, y, z);
    while (y.signum() > 0) {
      r2 = (a + z.intValue()).toString(b).substr(1) + r2;
      y.divRemTo(d, y, z);
    }
    return z.intValue().toString(b) + r2;
  }
  function bnpFromRadix(s2, b) {
    var self2 = this;
    self2.fromInt(0);
    if (b == null)
      b = 10;
    var cs = self2.chunkSize(b);
    var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
    for (var i2 = 0; i2 < s2.length; ++i2) {
      var x = intAt(s2, i2);
      if (x < 0) {
        if (s2.charAt(i2) == "-" && self2.signum() == 0)
          mi = true;
        continue;
      }
      w = b * w + x;
      if (++j >= cs) {
        self2.dMultiply(d);
        self2.dAddOffset(w, 0);
        j = 0;
        w = 0;
      }
    }
    if (j > 0) {
      self2.dMultiply(Math.pow(b, j));
      self2.dAddOffset(w, 0);
    }
    if (mi)
      BigInteger$9.ZERO.subTo(self2, self2);
  }
  function bnpFromNumber(a, b, c) {
    var self2 = this;
    if ("number" == typeof b) {
      if (a < 2)
        self2.fromInt(1);
      else {
        self2.fromNumber(a, c);
        if (!self2.testBit(a - 1))
          self2.bitwiseTo(BigInteger$9.ONE.shiftLeft(a - 1), op_or, self2);
        if (self2.isEven())
          self2.dAddOffset(1, 0);
        while (!self2.isProbablePrime(b)) {
          self2.dAddOffset(2, 0);
          if (self2.bitLength() > a)
            self2.subTo(BigInteger$9.ONE.shiftLeft(a - 1), self2);
        }
      }
    } else {
      var x = new Array(), t = a & 7;
      x.length = (a >> 3) + 1;
      b.nextBytes(x);
      if (t > 0)
        x[0] &= (1 << t) - 1;
      else
        x[0] = 0;
      self2.fromString(x, 256);
    }
  }
  function bnToByteArray() {
    var self2 = this;
    var i2 = self2.t, r2 = new Array();
    r2[0] = self2.s;
    var p2 = self2.DB - i2 * self2.DB % 8, d, k2 = 0;
    if (i2-- > 0) {
      if (p2 < self2.DB && (d = self2[i2] >> p2) != (self2.s & self2.DM) >> p2)
        r2[k2++] = d | self2.s << self2.DB - p2;
      while (i2 >= 0) {
        if (p2 < 8) {
          d = (self2[i2] & (1 << p2) - 1) << 8 - p2;
          d |= self2[--i2] >> (p2 += self2.DB - 8);
        } else {
          d = self2[i2] >> (p2 -= 8) & 255;
          if (p2 <= 0) {
            p2 += self2.DB;
            --i2;
          }
        }
        if ((d & 128) != 0)
          d |= -256;
        if (k2 === 0 && (self2.s & 128) != (d & 128))
          ++k2;
        if (k2 > 0 || d != self2.s)
          r2[k2++] = d;
      }
    }
    return r2;
  }
  function bnEquals(a) {
    return this.compareTo(a) == 0;
  }
  function bnMin(a) {
    return this.compareTo(a) < 0 ? this : a;
  }
  function bnMax(a) {
    return this.compareTo(a) > 0 ? this : a;
  }
  function bnpBitwiseTo(a, op, r2) {
    var self2 = this;
    var i2, f2, m = Math.min(a.t, self2.t);
    for (i2 = 0; i2 < m; ++i2)
      r2[i2] = op(self2[i2], a[i2]);
    if (a.t < self2.t) {
      f2 = a.s & self2.DM;
      for (i2 = m; i2 < self2.t; ++i2)
        r2[i2] = op(self2[i2], f2);
      r2.t = self2.t;
    } else {
      f2 = self2.s & self2.DM;
      for (i2 = m; i2 < a.t; ++i2)
        r2[i2] = op(f2, a[i2]);
      r2.t = a.t;
    }
    r2.s = op(self2.s, a.s);
    r2.clamp();
  }
  function op_and(x, y) {
    return x & y;
  }
  function bnAnd(a) {
    var r2 = new BigInteger$9();
    this.bitwiseTo(a, op_and, r2);
    return r2;
  }
  function op_or(x, y) {
    return x | y;
  }
  function bnOr(a) {
    var r2 = new BigInteger$9();
    this.bitwiseTo(a, op_or, r2);
    return r2;
  }
  function op_xor(x, y) {
    return x ^ y;
  }
  function bnXor(a) {
    var r2 = new BigInteger$9();
    this.bitwiseTo(a, op_xor, r2);
    return r2;
  }
  function op_andnot(x, y) {
    return x & ~y;
  }
  function bnAndNot(a) {
    var r2 = new BigInteger$9();
    this.bitwiseTo(a, op_andnot, r2);
    return r2;
  }
  function bnNot() {
    var r2 = new BigInteger$9();
    for (var i2 = 0; i2 < this.t; ++i2)
      r2[i2] = this.DM & ~this[i2];
    r2.t = this.t;
    r2.s = ~this.s;
    return r2;
  }
  function bnShiftLeft(n2) {
    var r2 = new BigInteger$9();
    if (n2 < 0)
      this.rShiftTo(-n2, r2);
    else
      this.lShiftTo(n2, r2);
    return r2;
  }
  function bnShiftRight(n2) {
    var r2 = new BigInteger$9();
    if (n2 < 0)
      this.lShiftTo(-n2, r2);
    else
      this.rShiftTo(n2, r2);
    return r2;
  }
  function lbit(x) {
    if (x == 0)
      return -1;
    var r2 = 0;
    if ((x & 65535) == 0) {
      x >>= 16;
      r2 += 16;
    }
    if ((x & 255) == 0) {
      x >>= 8;
      r2 += 8;
    }
    if ((x & 15) == 0) {
      x >>= 4;
      r2 += 4;
    }
    if ((x & 3) == 0) {
      x >>= 2;
      r2 += 2;
    }
    if ((x & 1) == 0)
      ++r2;
    return r2;
  }
  function bnGetLowestSetBit() {
    for (var i2 = 0; i2 < this.t; ++i2)
      if (this[i2] != 0)
        return i2 * this.DB + lbit(this[i2]);
    if (this.s < 0)
      return this.t * this.DB;
    return -1;
  }
  function cbit(x) {
    var r2 = 0;
    while (x != 0) {
      x &= x - 1;
      ++r2;
    }
    return r2;
  }
  function bnBitCount() {
    var r2 = 0, x = this.s & this.DM;
    for (var i2 = 0; i2 < this.t; ++i2)
      r2 += cbit(this[i2] ^ x);
    return r2;
  }
  function bnTestBit(n2) {
    var j = Math.floor(n2 / this.DB);
    if (j >= this.t)
      return this.s != 0;
    return (this[j] & 1 << n2 % this.DB) != 0;
  }
  function bnpChangeBit(n2, op) {
    var r2 = BigInteger$9.ONE.shiftLeft(n2);
    this.bitwiseTo(r2, op, r2);
    return r2;
  }
  function bnSetBit(n2) {
    return this.changeBit(n2, op_or);
  }
  function bnClearBit(n2) {
    return this.changeBit(n2, op_andnot);
  }
  function bnFlipBit(n2) {
    return this.changeBit(n2, op_xor);
  }
  function bnpAddTo(a, r2) {
    var self2 = this;
    var i2 = 0, c = 0, m = Math.min(a.t, self2.t);
    while (i2 < m) {
      c += self2[i2] + a[i2];
      r2[i2++] = c & self2.DM;
      c >>= self2.DB;
    }
    if (a.t < self2.t) {
      c += a.s;
      while (i2 < self2.t) {
        c += self2[i2];
        r2[i2++] = c & self2.DM;
        c >>= self2.DB;
      }
      c += self2.s;
    } else {
      c += self2.s;
      while (i2 < a.t) {
        c += a[i2];
        r2[i2++] = c & self2.DM;
        c >>= self2.DB;
      }
      c += a.s;
    }
    r2.s = c < 0 ? -1 : 0;
    if (c > 0)
      r2[i2++] = c;
    else if (c < -1)
      r2[i2++] = self2.DV + c;
    r2.t = i2;
    r2.clamp();
  }
  function bnAdd(a) {
    var r2 = new BigInteger$9();
    this.addTo(a, r2);
    return r2;
  }
  function bnSubtract(a) {
    var r2 = new BigInteger$9();
    this.subTo(a, r2);
    return r2;
  }
  function bnMultiply(a) {
    var r2 = new BigInteger$9();
    this.multiplyTo(a, r2);
    return r2;
  }
  function bnSquare() {
    var r2 = new BigInteger$9();
    this.squareTo(r2);
    return r2;
  }
  function bnDivide(a) {
    var r2 = new BigInteger$9();
    this.divRemTo(a, r2, null);
    return r2;
  }
  function bnRemainder(a) {
    var r2 = new BigInteger$9();
    this.divRemTo(a, null, r2);
    return r2;
  }
  function bnDivideAndRemainder(a) {
    var q = new BigInteger$9(), r2 = new BigInteger$9();
    this.divRemTo(a, q, r2);
    return new Array(q, r2);
  }
  function bnpDMultiply(n2) {
    this[this.t] = this.am(0, n2 - 1, this, 0, 0, this.t);
    ++this.t;
    this.clamp();
  }
  function bnpDAddOffset(n2, w) {
    if (n2 == 0)
      return;
    while (this.t <= w)
      this[this.t++] = 0;
    this[w] += n2;
    while (this[w] >= this.DV) {
      this[w] -= this.DV;
      if (++w >= this.t)
        this[this.t++] = 0;
      ++this[w];
    }
  }
  function NullExp() {
  }
  function nNop(x) {
    return x;
  }
  function nMulTo(x, y, r2) {
    x.multiplyTo(y, r2);
  }
  function nSqrTo(x, r2) {
    x.squareTo(r2);
  }
  NullExp.prototype.convert = nNop;
  NullExp.prototype.revert = nNop;
  NullExp.prototype.mulTo = nMulTo;
  NullExp.prototype.sqrTo = nSqrTo;
  function bnPow(e) {
    return this.exp(e, new NullExp());
  }
  function bnpMultiplyLowerTo(a, n2, r2) {
    var i2 = Math.min(this.t + a.t, n2);
    r2.s = 0;
    r2.t = i2;
    while (i2 > 0)
      r2[--i2] = 0;
    var j;
    for (j = r2.t - this.t; i2 < j; ++i2)
      r2[i2 + this.t] = this.am(0, a[i2], r2, i2, 0, this.t);
    for (j = Math.min(a.t, n2); i2 < j; ++i2)
      this.am(0, a[i2], r2, i2, 0, n2 - i2);
    r2.clamp();
  }
  function bnpMultiplyUpperTo(a, n2, r2) {
    --n2;
    var i2 = r2.t = this.t + a.t - n2;
    r2.s = 0;
    while (--i2 >= 0)
      r2[i2] = 0;
    for (i2 = Math.max(n2 - this.t, 0); i2 < a.t; ++i2)
      r2[this.t + i2 - n2] = this.am(n2 - i2, a[i2], r2, 0, 0, this.t + i2 - n2);
    r2.clamp();
    r2.drShiftTo(1, r2);
  }
  function Barrett(m) {
    this.r2 = new BigInteger$9();
    this.q3 = new BigInteger$9();
    BigInteger$9.ONE.dlShiftTo(2 * m.t, this.r2);
    this.mu = this.r2.divide(m);
    this.m = m;
  }
  function barrettConvert(x) {
    if (x.s < 0 || x.t > 2 * this.m.t)
      return x.mod(this.m);
    else if (x.compareTo(this.m) < 0)
      return x;
    else {
      var r2 = new BigInteger$9();
      x.copyTo(r2);
      this.reduce(r2);
      return r2;
    }
  }
  function barrettRevert(x) {
    return x;
  }
  function barrettReduce(x) {
    var self2 = this;
    x.drShiftTo(self2.m.t - 1, self2.r2);
    if (x.t > self2.m.t + 1) {
      x.t = self2.m.t + 1;
      x.clamp();
    }
    self2.mu.multiplyUpperTo(self2.r2, self2.m.t + 1, self2.q3);
    self2.m.multiplyLowerTo(self2.q3, self2.m.t + 1, self2.r2);
    while (x.compareTo(self2.r2) < 0)
      x.dAddOffset(1, self2.m.t + 1);
    x.subTo(self2.r2, x);
    while (x.compareTo(self2.m) >= 0)
      x.subTo(self2.m, x);
  }
  function barrettSqrTo(x, r2) {
    x.squareTo(r2);
    this.reduce(r2);
  }
  function barrettMulTo(x, y, r2) {
    x.multiplyTo(y, r2);
    this.reduce(r2);
  }
  Barrett.prototype.convert = barrettConvert;
  Barrett.prototype.revert = barrettRevert;
  Barrett.prototype.reduce = barrettReduce;
  Barrett.prototype.mulTo = barrettMulTo;
  Barrett.prototype.sqrTo = barrettSqrTo;
  function bnModPow(e, m) {
    var i2 = e.bitLength(), k2, r2 = nbv(1), z;
    if (i2 <= 0)
      return r2;
    else if (i2 < 18)
      k2 = 1;
    else if (i2 < 48)
      k2 = 3;
    else if (i2 < 144)
      k2 = 4;
    else if (i2 < 768)
      k2 = 5;
    else
      k2 = 6;
    if (i2 < 8)
      z = new Classic(m);
    else if (m.isEven())
      z = new Barrett(m);
    else
      z = new Montgomery(m);
    var g2 = new Array(), n2 = 3, k1 = k2 - 1, km = (1 << k2) - 1;
    g2[1] = z.convert(this);
    if (k2 > 1) {
      var g22 = new BigInteger$9();
      z.sqrTo(g2[1], g22);
      while (n2 <= km) {
        g2[n2] = new BigInteger$9();
        z.mulTo(g22, g2[n2 - 2], g2[n2]);
        n2 += 2;
      }
    }
    var j = e.t - 1, w, is1 = true, r22 = new BigInteger$9(), t;
    i2 = nbits(e[j]) - 1;
    while (j >= 0) {
      if (i2 >= k1)
        w = e[j] >> i2 - k1 & km;
      else {
        w = (e[j] & (1 << i2 + 1) - 1) << k1 - i2;
        if (j > 0)
          w |= e[j - 1] >> this.DB + i2 - k1;
      }
      n2 = k2;
      while ((w & 1) == 0) {
        w >>= 1;
        --n2;
      }
      if ((i2 -= n2) < 0) {
        i2 += this.DB;
        --j;
      }
      if (is1) {
        g2[w].copyTo(r2);
        is1 = false;
      } else {
        while (n2 > 1) {
          z.sqrTo(r2, r22);
          z.sqrTo(r22, r2);
          n2 -= 2;
        }
        if (n2 > 0)
          z.sqrTo(r2, r22);
        else {
          t = r2;
          r2 = r22;
          r22 = t;
        }
        z.mulTo(r22, g2[w], r2);
      }
      while (j >= 0 && (e[j] & 1 << i2) == 0) {
        z.sqrTo(r2, r22);
        t = r2;
        r2 = r22;
        r22 = t;
        if (--i2 < 0) {
          i2 = this.DB - 1;
          --j;
        }
      }
    }
    return z.revert(r2);
  }
  function bnGCD(a) {
    var x = this.s < 0 ? this.negate() : this.clone();
    var y = a.s < 0 ? a.negate() : a.clone();
    if (x.compareTo(y) < 0) {
      var t = x;
      x = y;
      y = t;
    }
    var i2 = x.getLowestSetBit(), g2 = y.getLowestSetBit();
    if (g2 < 0)
      return x;
    if (i2 < g2)
      g2 = i2;
    if (g2 > 0) {
      x.rShiftTo(g2, x);
      y.rShiftTo(g2, y);
    }
    while (x.signum() > 0) {
      if ((i2 = x.getLowestSetBit()) > 0)
        x.rShiftTo(i2, x);
      if ((i2 = y.getLowestSetBit()) > 0)
        y.rShiftTo(i2, y);
      if (x.compareTo(y) >= 0) {
        x.subTo(y, x);
        x.rShiftTo(1, x);
      } else {
        y.subTo(x, y);
        y.rShiftTo(1, y);
      }
    }
    if (g2 > 0)
      y.lShiftTo(g2, y);
    return y;
  }
  function bnpModInt(n2) {
    if (n2 <= 0)
      return 0;
    var d = this.DV % n2, r2 = this.s < 0 ? n2 - 1 : 0;
    if (this.t > 0)
      if (d == 0)
        r2 = this[0] % n2;
      else
        for (var i2 = this.t - 1; i2 >= 0; --i2)
          r2 = (d * r2 + this[i2]) % n2;
    return r2;
  }
  function bnModInverse(m) {
    var ac = m.isEven();
    if (this.signum() === 0)
      throw new Error("division by zero");
    if (this.isEven() && ac || m.signum() == 0)
      return BigInteger$9.ZERO;
    var u = m.clone(), v = this.clone();
    var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
    while (u.signum() != 0) {
      while (u.isEven()) {
        u.rShiftTo(1, u);
        if (ac) {
          if (!a.isEven() || !b.isEven()) {
            a.addTo(this, a);
            b.subTo(m, b);
          }
          a.rShiftTo(1, a);
        } else if (!b.isEven())
          b.subTo(m, b);
        b.rShiftTo(1, b);
      }
      while (v.isEven()) {
        v.rShiftTo(1, v);
        if (ac) {
          if (!c.isEven() || !d.isEven()) {
            c.addTo(this, c);
            d.subTo(m, d);
          }
          c.rShiftTo(1, c);
        } else if (!d.isEven())
          d.subTo(m, d);
        d.rShiftTo(1, d);
      }
      if (u.compareTo(v) >= 0) {
        u.subTo(v, u);
        if (ac)
          a.subTo(c, a);
        b.subTo(d, b);
      } else {
        v.subTo(u, v);
        if (ac)
          c.subTo(a, c);
        d.subTo(b, d);
      }
    }
    if (v.compareTo(BigInteger$9.ONE) != 0)
      return BigInteger$9.ZERO;
    while (d.compareTo(m) >= 0)
      d.subTo(m, d);
    while (d.signum() < 0)
      d.addTo(m, d);
    return d;
  }
  var lowprimes = [
    2,
    3,
    5,
    7,
    11,
    13,
    17,
    19,
    23,
    29,
    31,
    37,
    41,
    43,
    47,
    53,
    59,
    61,
    67,
    71,
    73,
    79,
    83,
    89,
    97,
    101,
    103,
    107,
    109,
    113,
    127,
    131,
    137,
    139,
    149,
    151,
    157,
    163,
    167,
    173,
    179,
    181,
    191,
    193,
    197,
    199,
    211,
    223,
    227,
    229,
    233,
    239,
    241,
    251,
    257,
    263,
    269,
    271,
    277,
    281,
    283,
    293,
    307,
    311,
    313,
    317,
    331,
    337,
    347,
    349,
    353,
    359,
    367,
    373,
    379,
    383,
    389,
    397,
    401,
    409,
    419,
    421,
    431,
    433,
    439,
    443,
    449,
    457,
    461,
    463,
    467,
    479,
    487,
    491,
    499,
    503,
    509,
    521,
    523,
    541,
    547,
    557,
    563,
    569,
    571,
    577,
    587,
    593,
    599,
    601,
    607,
    613,
    617,
    619,
    631,
    641,
    643,
    647,
    653,
    659,
    661,
    673,
    677,
    683,
    691,
    701,
    709,
    719,
    727,
    733,
    739,
    743,
    751,
    757,
    761,
    769,
    773,
    787,
    797,
    809,
    811,
    821,
    823,
    827,
    829,
    839,
    853,
    857,
    859,
    863,
    877,
    881,
    883,
    887,
    907,
    911,
    919,
    929,
    937,
    941,
    947,
    953,
    967,
    971,
    977,
    983,
    991,
    997
  ];
  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
  function bnIsProbablePrime(t) {
    var i2, x = this.abs();
    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
      for (i2 = 0; i2 < lowprimes.length; ++i2)
        if (x[0] == lowprimes[i2])
          return true;
      return false;
    }
    if (x.isEven())
      return false;
    i2 = 1;
    while (i2 < lowprimes.length) {
      var m = lowprimes[i2], j = i2 + 1;
      while (j < lowprimes.length && m < lplim)
        m *= lowprimes[j++];
      m = x.modInt(m);
      while (i2 < j)
        if (m % lowprimes[i2++] == 0)
          return false;
    }
    return x.millerRabin(t);
  }
  function bnpMillerRabin(t) {
    var n1 = this.subtract(BigInteger$9.ONE);
    var k2 = n1.getLowestSetBit();
    if (k2 <= 0)
      return false;
    var r2 = n1.shiftRight(k2);
    t = t + 1 >> 1;
    if (t > lowprimes.length)
      t = lowprimes.length;
    var a = new BigInteger$9(null);
    var j, bases = [];
    for (var i2 = 0; i2 < t; ++i2) {
      for (; ; ) {
        j = lowprimes[Math.floor(Math.random() * lowprimes.length)];
        if (bases.indexOf(j) == -1)
          break;
      }
      bases.push(j);
      a.fromInt(j);
      var y = a.modPow(r2, this);
      if (y.compareTo(BigInteger$9.ONE) != 0 && y.compareTo(n1) != 0) {
        var j = 1;
        while (j++ < k2 && y.compareTo(n1) != 0) {
          y = y.modPowInt(2, this);
          if (y.compareTo(BigInteger$9.ONE) == 0)
            return false;
        }
        if (y.compareTo(n1) != 0)
          return false;
      }
    }
    return true;
  }
  proto.chunkSize = bnpChunkSize;
  proto.toRadix = bnpToRadix;
  proto.fromRadix = bnpFromRadix;
  proto.fromNumber = bnpFromNumber;
  proto.bitwiseTo = bnpBitwiseTo;
  proto.changeBit = bnpChangeBit;
  proto.addTo = bnpAddTo;
  proto.dMultiply = bnpDMultiply;
  proto.dAddOffset = bnpDAddOffset;
  proto.multiplyLowerTo = bnpMultiplyLowerTo;
  proto.multiplyUpperTo = bnpMultiplyUpperTo;
  proto.modInt = bnpModInt;
  proto.millerRabin = bnpMillerRabin;
  proto.clone = bnClone;
  proto.intValue = bnIntValue;
  proto.byteValue = bnByteValue;
  proto.shortValue = bnShortValue;
  proto.signum = bnSigNum;
  proto.toByteArray = bnToByteArray;
  proto.equals = bnEquals;
  proto.min = bnMin;
  proto.max = bnMax;
  proto.and = bnAnd;
  proto.or = bnOr;
  proto.xor = bnXor;
  proto.andNot = bnAndNot;
  proto.not = bnNot;
  proto.shiftLeft = bnShiftLeft;
  proto.shiftRight = bnShiftRight;
  proto.getLowestSetBit = bnGetLowestSetBit;
  proto.bitCount = bnBitCount;
  proto.testBit = bnTestBit;
  proto.setBit = bnSetBit;
  proto.clearBit = bnClearBit;
  proto.flipBit = bnFlipBit;
  proto.add = bnAdd;
  proto.subtract = bnSubtract;
  proto.multiply = bnMultiply;
  proto.divide = bnDivide;
  proto.remainder = bnRemainder;
  proto.divideAndRemainder = bnDivideAndRemainder;
  proto.modPow = bnModPow;
  proto.modInverse = bnModInverse;
  proto.pow = bnPow;
  proto.gcd = bnGCD;
  proto.isProbablePrime = bnIsProbablePrime;
  proto.square = bnSquare;
  BigInteger$9.ZERO = nbv(0);
  BigInteger$9.ONE = nbv(1);
  BigInteger$9.valueOf = nbv;
  var bigi = BigInteger$9;
  var assert$3 = requireAssert();
  var BigInteger$8 = bigi;
  BigInteger$8.fromByteArrayUnsigned = function(byteArray) {
    if (byteArray[0] & 128) {
      return new BigInteger$8([0].concat(byteArray));
    }
    return new BigInteger$8(byteArray);
  };
  BigInteger$8.prototype.toByteArrayUnsigned = function() {
    var byteArray = this.toByteArray();
    return byteArray[0] === 0 ? byteArray.slice(1) : byteArray;
  };
  BigInteger$8.fromDERInteger = function(byteArray) {
    return new BigInteger$8(byteArray);
  };
  BigInteger$8.prototype.toDERInteger = BigInteger$8.prototype.toByteArray;
  BigInteger$8.fromBuffer = function(buffer2) {
    if (buffer2[0] & 128) {
      var byteArray = Array.prototype.slice.call(buffer2);
      return new BigInteger$8([0].concat(byteArray));
    }
    return new BigInteger$8(buffer2);
  };
  BigInteger$8.fromHex = function(hex) {
    if (hex === "")
      return BigInteger$8.ZERO;
    assert$3.equal(hex, hex.match(/^[A-Fa-f0-9]+/), "Invalid hex string");
    assert$3.equal(hex.length % 2, 0, "Incomplete hex");
    return new BigInteger$8(hex, 16);
  };
  BigInteger$8.prototype.toBuffer = function(size) {
    var byteArray = this.toByteArrayUnsigned();
    var zeros = [];
    var padding = size - byteArray.length;
    while (zeros.length < padding)
      zeros.push(0);
    return new buffer$2.Buffer(zeros.concat(byteArray));
  };
  BigInteger$8.prototype.toHex = function(size) {
    return this.toBuffer(size).toString("hex");
  };
  var BigInteger$7 = bigi;
  var lib$2 = BigInteger$7;
  var assert$2 = requireAssert();
  var Buffer$j = safeBufferExports.Buffer;
  var BigInteger$6 = lib$2;
  var THREE = BigInteger$6.valueOf(3);
  function Point$2(curve2, x, y, z) {
    assert$2.notStrictEqual(z, void 0, "Missing Z coordinate");
    this.curve = curve2;
    this.x = x;
    this.y = y;
    this.z = z;
    this._zInv = null;
    this.compressed = true;
  }
  Object.defineProperty(Point$2.prototype, "zInv", {
    get: function() {
      if (this._zInv === null) {
        this._zInv = this.z.modInverse(this.curve.p);
      }
      return this._zInv;
    }
  });
  Object.defineProperty(Point$2.prototype, "affineX", {
    get: function() {
      return this.x.multiply(this.zInv).mod(this.curve.p);
    }
  });
  Object.defineProperty(Point$2.prototype, "affineY", {
    get: function() {
      return this.y.multiply(this.zInv).mod(this.curve.p);
    }
  });
  Point$2.fromAffine = function(curve2, x, y) {
    return new Point$2(curve2, x, y, BigInteger$6.ONE);
  };
  Point$2.prototype.equals = function(other) {
    if (other === this)
      return true;
    if (this.curve.isInfinity(this))
      return this.curve.isInfinity(other);
    if (this.curve.isInfinity(other))
      return this.curve.isInfinity(this);
    var u = other.y.multiply(this.z).subtract(this.y.multiply(other.z)).mod(this.curve.p);
    if (u.signum() !== 0)
      return false;
    var v = other.x.multiply(this.z).subtract(this.x.multiply(other.z)).mod(this.curve.p);
    return v.signum() === 0;
  };
  Point$2.prototype.negate = function() {
    var y = this.curve.p.subtract(this.y);
    return new Point$2(this.curve, this.x, y, this.z);
  };
  Point$2.prototype.add = function(b) {
    if (this.curve.isInfinity(this))
      return b;
    if (this.curve.isInfinity(b))
      return this;
    var x1 = this.x;
    var y1 = this.y;
    var x2 = b.x;
    var y2 = b.y;
    var u = y2.multiply(this.z).subtract(y1.multiply(b.z)).mod(this.curve.p);
    var v = x2.multiply(this.z).subtract(x1.multiply(b.z)).mod(this.curve.p);
    if (v.signum() === 0) {
      if (u.signum() === 0) {
        return this.twice();
      }
      return this.curve.infinity;
    }
    var v2 = v.square();
    var v3 = v2.multiply(v);
    var x1v2 = x1.multiply(v2);
    var zu2 = u.square().multiply(this.z);
    var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.p);
    var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.p);
    var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.p);
    return new Point$2(this.curve, x3, y3, z3);
  };
  Point$2.prototype.twice = function() {
    if (this.curve.isInfinity(this))
      return this;
    if (this.y.signum() === 0)
      return this.curve.infinity;
    var x1 = this.x;
    var y1 = this.y;
    var y1z1 = y1.multiply(this.z).mod(this.curve.p);
    var y1sqz1 = y1z1.multiply(y1).mod(this.curve.p);
    var a = this.curve.a;
    var w = x1.square().multiply(THREE);
    if (a.signum() !== 0) {
      w = w.add(this.z.square().multiply(a));
    }
    w = w.mod(this.curve.p);
    var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.p);
    var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.pow(3)).mod(this.curve.p);
    var z3 = y1z1.pow(3).shiftLeft(3).mod(this.curve.p);
    return new Point$2(this.curve, x3, y3, z3);
  };
  Point$2.prototype.multiply = function(k2) {
    if (this.curve.isInfinity(this))
      return this;
    if (k2.signum() === 0)
      return this.curve.infinity;
    var e = k2;
    var h = e.multiply(THREE);
    var neg = this.negate();
    var R = this;
    for (var i2 = h.bitLength() - 2; i2 > 0; --i2) {
      var hBit = h.testBit(i2);
      var eBit = e.testBit(i2);
      R = R.twice();
      if (hBit !== eBit) {
        R = R.add(hBit ? this : neg);
      }
    }
    return R;
  };
  Point$2.prototype.multiplyTwo = function(j, x, k2) {
    var i2 = Math.max(j.bitLength(), k2.bitLength()) - 1;
    var R = this.curve.infinity;
    var both = this.add(x);
    while (i2 >= 0) {
      var jBit = j.testBit(i2);
      var kBit = k2.testBit(i2);
      R = R.twice();
      if (jBit) {
        if (kBit) {
          R = R.add(both);
        } else {
          R = R.add(this);
        }
      } else if (kBit) {
        R = R.add(x);
      }
      --i2;
    }
    return R;
  };
  Point$2.prototype.getEncoded = function(compressed) {
    if (compressed == null)
      compressed = this.compressed;
    if (this.curve.isInfinity(this))
      return Buffer$j.alloc(1, 0);
    var x = this.affineX;
    var y = this.affineY;
    var byteLength2 = this.curve.pLength;
    var buffer2;
    if (compressed) {
      buffer2 = Buffer$j.allocUnsafe(1 + byteLength2);
      buffer2.writeUInt8(y.isEven() ? 2 : 3, 0);
    } else {
      buffer2 = Buffer$j.allocUnsafe(1 + byteLength2 + byteLength2);
      buffer2.writeUInt8(4, 0);
      y.toBuffer(byteLength2).copy(buffer2, 1 + byteLength2);
    }
    x.toBuffer(byteLength2).copy(buffer2, 1);
    return buffer2;
  };
  Point$2.decodeFrom = function(curve2, buffer2) {
    var type2 = buffer2.readUInt8(0);
    var compressed = type2 !== 4;
    var byteLength2 = Math.floor((curve2.p.bitLength() + 7) / 8);
    var x = BigInteger$6.fromBuffer(buffer2.slice(1, 1 + byteLength2));
    var Q;
    if (compressed) {
      assert$2.equal(buffer2.length, byteLength2 + 1, "Invalid sequence length");
      assert$2(type2 === 2 || type2 === 3, "Invalid sequence tag");
      var isOdd = type2 === 3;
      Q = curve2.pointFromX(isOdd, x);
    } else {
      assert$2.equal(buffer2.length, 1 + byteLength2 + byteLength2, "Invalid sequence length");
      var y = BigInteger$6.fromBuffer(buffer2.slice(1 + byteLength2));
      Q = Point$2.fromAffine(curve2, x, y);
    }
    Q.compressed = compressed;
    return Q;
  };
  Point$2.prototype.toString = function() {
    if (this.curve.isInfinity(this))
      return "(INFINITY)";
    return "(" + this.affineX.toString() + "," + this.affineY.toString() + ")";
  };
  var point = Point$2;
  var assert$1 = requireAssert();
  var BigInteger$5 = lib$2;
  var Point$1 = point;
  function Curve$2(p2, a, b, Gx, Gy, n2, h) {
    this.p = p2;
    this.a = a;
    this.b = b;
    this.G = Point$1.fromAffine(this, Gx, Gy);
    this.n = n2;
    this.h = h;
    this.infinity = new Point$1(this, null, null, BigInteger$5.ZERO);
    this.pOverFour = p2.add(BigInteger$5.ONE).shiftRight(2);
    this.pLength = Math.floor((this.p.bitLength() + 7) / 8);
  }
  Curve$2.prototype.pointFromX = function(isOdd, x) {
    var alpha = x.pow(3).add(this.a.multiply(x)).add(this.b).mod(this.p);
    var beta = alpha.modPow(this.pOverFour, this.p);
    var y = beta;
    if (beta.isEven() ^ !isOdd) {
      y = this.p.subtract(y);
    }
    return Point$1.fromAffine(this, x, y);
  };
  Curve$2.prototype.isInfinity = function(Q) {
    if (Q === this.infinity)
      return true;
    return Q.z.signum() === 0 && Q.y.signum() !== 0;
  };
  Curve$2.prototype.isOnCurve = function(Q) {
    if (this.isInfinity(Q))
      return true;
    var x = Q.affineX;
    var y = Q.affineY;
    var a = this.a;
    var b = this.b;
    var p2 = this.p;
    if (x.signum() < 0 || x.compareTo(p2) >= 0)
      return false;
    if (y.signum() < 0 || y.compareTo(p2) >= 0)
      return false;
    var lhs = y.square().mod(p2);
    var rhs = x.pow(3).add(a.multiply(x)).add(b).mod(p2);
    return lhs.equals(rhs);
  };
  Curve$2.prototype.validate = function(Q) {
    assert$1(!this.isInfinity(Q), "Point is at infinity");
    assert$1(this.isOnCurve(Q), "Point is not on the curve");
    var nQ = Q.multiply(this.n);
    assert$1(this.isInfinity(nQ), "Point is not a scalar multiple of G");
    return true;
  };
  var curve$5 = Curve$2;
  const secp128r1 = {
    p: "fffffffdffffffffffffffffffffffff",
    a: "fffffffdfffffffffffffffffffffffc",
    b: "e87579c11079f43dd824993c2cee5ed3",
    n: "fffffffe0000000075a30d1b9038a115",
    h: "01",
    Gx: "161ff7528b899b2d0c28607ca52c5b86",
    Gy: "cf5ac8395bafeb13c02da292dded7a83"
  };
  const secp160k1 = {
    p: "fffffffffffffffffffffffffffffffeffffac73",
    a: "00",
    b: "07",
    n: "0100000000000000000001b8fa16dfab9aca16b6b3",
    h: "01",
    Gx: "3b4c382ce37aa192a4019e763036f4f5dd4d7ebb",
    Gy: "938cf935318fdced6bc28286531733c3f03c4fee"
  };
  const secp160r1 = {
    p: "ffffffffffffffffffffffffffffffff7fffffff",
    a: "ffffffffffffffffffffffffffffffff7ffffffc",
    b: "1c97befc54bd7a8b65acf89f81d4d4adc565fa45",
    n: "0100000000000000000001f4c8f927aed3ca752257",
    h: "01",
    Gx: "4a96b5688ef573284664698968c38bb913cbfc82",
    Gy: "23a628553168947d59dcc912042351377ac5fb32"
  };
  const secp192k1 = {
    p: "fffffffffffffffffffffffffffffffffffffffeffffee37",
    a: "00",
    b: "03",
    n: "fffffffffffffffffffffffe26f2fc170f69466a74defd8d",
    h: "01",
    Gx: "db4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d",
    Gy: "9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d"
  };
  const secp192r1 = {
    p: "fffffffffffffffffffffffffffffffeffffffffffffffff",
    a: "fffffffffffffffffffffffffffffffefffffffffffffffc",
    b: "64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1",
    n: "ffffffffffffffffffffffff99def836146bc9b1b4d22831",
    h: "01",
    Gx: "188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012",
    Gy: "07192b95ffc8da78631011ed6b24cdd573f977a11e794811"
  };
  const secp256k1$1 = {
    p: "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    a: "00",
    b: "07",
    n: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
    h: "01",
    Gx: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    Gy: "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
  };
  const secp256r1 = {
    p: "ffffffff00000001000000000000000000000000ffffffffffffffffffffffff",
    a: "ffffffff00000001000000000000000000000000fffffffffffffffffffffffc",
    b: "5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b",
    n: "ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551",
    h: "01",
    Gx: "6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296",
    Gy: "4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
  };
  const require$$1 = {
    secp128r1,
    secp160k1,
    secp160r1,
    secp192k1,
    secp192r1,
    secp256k1: secp256k1$1,
    secp256r1
  };
  var BigInteger$4 = lib$2;
  var curves = require$$1;
  var Curve$1 = curve$5;
  function getCurveByName$1(name2) {
    var curve2 = curves[name2];
    if (!curve2)
      return null;
    var p2 = new BigInteger$4(curve2.p, 16);
    var a = new BigInteger$4(curve2.a, 16);
    var b = new BigInteger$4(curve2.b, 16);
    var n2 = new BigInteger$4(curve2.n, 16);
    var h = new BigInteger$4(curve2.h, 16);
    var Gx = new BigInteger$4(curve2.Gx, 16);
    var Gy = new BigInteger$4(curve2.Gy, 16);
    return new Curve$1(p2, a, b, Gx, Gy, n2, h);
  }
  var names = getCurveByName$1;
  var Point = point;
  var Curve = curve$5;
  var getCurveByName = names;
  var lib$1 = {
    Curve,
    Point,
    getCurveByName
  };
  var browser$2 = { exports: {} };
  var MAX_BYTES = 65536;
  var MAX_UINT32 = 4294967295;
  function oldBrowser() {
    throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
  }
  var Buffer$i = safeBufferExports.Buffer;
  var crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  if (crypto && crypto.getRandomValues) {
    browser$2.exports = randomBytes$1;
  } else {
    browser$2.exports = oldBrowser;
  }
  function randomBytes$1(size, cb) {
    if (size > MAX_UINT32)
      throw new RangeError("requested too many random bytes");
    var bytes2 = Buffer$i.allocUnsafe(size);
    if (size > 0) {
      if (size > MAX_BYTES) {
        for (var generated = 0; generated < size; generated += MAX_BYTES) {
          crypto.getRandomValues(bytes2.slice(generated, generated + MAX_BYTES));
        }
      } else {
        crypto.getRandomValues(bytes2);
      }
    }
    if (typeof cb === "function") {
      return process.nextTick(function() {
        cb(null, bytes2);
      });
    }
    return bytes2;
  }
  var browserExports = browser$2.exports;
  const BigInteger$3 = lib$2;
  const Buffer$h = safeBufferExports.Buffer;
  const ecurve$4 = lib$1;
  const curve$4 = ecurve$4.getCurveByName("secp256k1");
  const one$1 = BigInteger$3.ONE;
  const n$3 = curve$4.n;
  const p$1 = curve$4.p;
  function checkBuffer(name2, buf, len2, idx) {
    const idxStr = idx !== void 0 ? "[" + idx + "]" : "";
    if (!Buffer$h.isBuffer(buf)) {
      throw new Error(name2 + idxStr + " must be a Buffer");
    }
    if (buf.length !== len2) {
      throw new Error(name2 + idxStr + " must be " + len2 + " bytes long");
    }
  }
  function checkArray(name2, arr) {
    if (!arr || !arr.length) {
      throw new Error(name2 + " must be an array with one or more elements");
    }
  }
  function checkPubKeyArr(pubKeys) {
    checkArray("pubKeys", pubKeys);
    for (let i2 = 0; i2 < pubKeys.length; i2++) {
      checkBuffer("pubKey", pubKeys[i2], 32, i2);
    }
  }
  function checkMessageArr(messages) {
    checkArray("messages", messages);
    for (let i2 = 0; i2 < messages.length; i2++) {
      checkBuffer("message", messages[i2], 32, i2);
    }
  }
  function checkSignatureArr(signatures) {
    checkArray("signatures", signatures);
    for (let i2 = 0; i2 < signatures.length; i2++) {
      checkBuffer("signature", signatures[i2], 64, i2);
    }
  }
  function checkNonceArr(nonces) {
    checkArray("nonces", nonces);
    for (let i2 = 0; i2 < nonces.length; i2++) {
      checkBuffer("nonce", nonces[i2], 32, i2);
    }
  }
  function checkPrivateKey(privateKey, idx) {
    const idxStr = idx !== void 0 ? "[" + idx + "]" : "";
    if (!BigInteger$3.isBigInteger(privateKey) && !(typeof privateKey == "string")) {
      throw new Error("privateKey" + idxStr + " must be a BigInteger or valid hex string");
    }
    if (typeof privateKey == "string") {
      if (privateKey.match(/[^a-f^A-F^0-9]+/)) {
        throw new Error("privateKey must be a BigInteger or valid hex string");
      }
      checkRange("privateKey", BigInteger$3.fromHex(privateKey));
      return;
    }
    checkRange("privateKey", privateKey);
  }
  function checkSignParams(privateKey, message2) {
    checkPrivateKey(privateKey);
    checkBuffer("message", message2, 32);
  }
  function checkVerifyParams(pubKey, message2, signature2) {
    checkBuffer("pubKey", pubKey, 32);
    checkBuffer("message", message2, 32);
    checkBuffer("signature", signature2, 64);
  }
  function checkBatchVerifyParams(pubKeys, messages, signatures) {
    checkPubKeyArr(pubKeys);
    checkMessageArr(messages);
    checkSignatureArr(signatures);
    if (pubKeys.length !== messages.length || messages.length !== signatures.length) {
      throw new Error("all parameters must be an array with the same length");
    }
  }
  function checkSessionParams(sessionId, privateKey, message2, pubKeyCombined, ell) {
    checkSignParams(privateKey, message2);
    checkBuffer("sessionId", sessionId, 32);
    checkBuffer("pubKeyCombined", pubKeyCombined, 32);
    checkBuffer("ell", ell, 32);
  }
  function checkRange(name2, scalar) {
    if (scalar.compareTo(one$1) < 0 || scalar.compareTo(n$3.subtract(one$1)) > 0) {
      throw new Error(name2 + " must be an integer in the range 1..n-1");
    }
  }
  function checkSignatureInput(r2, s2) {
    if (r2.compareTo(p$1) >= 0) {
      throw new Error("r is larger than or equal to field size");
    }
    if (s2.compareTo(n$3) >= 0) {
      throw new Error("s is larger than or equal to curve order");
    }
  }
  function checkPointExists(pubKeyEven, P) {
    if (P.curve.isInfinity(P)) {
      throw new Error("point is at infinity");
    }
    const pEven = P.affineY.isEven();
    if (pubKeyEven !== pEven) {
      throw new Error("point does not exist");
    }
  }
  function checkAux(aux) {
    if (aux.length !== 32) {
      throw new Error("aux must be 32 bytes");
    }
  }
  var check$3 = {
    checkSessionParams,
    checkSignParams,
    checkVerifyParams,
    checkBatchVerifyParams,
    checkRange,
    checkSignatureInput,
    checkPointExists,
    checkPubKeyArr,
    checkArray,
    checkNonceArr,
    checkAux
  };
  var sha256$2 = { exports: {} };
  /**
   * [js-sha256]{@link https://github.com/emn178/js-sha256}
   *
   * @version 0.9.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2017
   * @license MIT
   */
  (function(module) {
    (function() {
      var ERROR = "input is invalid type";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA256_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = commonjsGlobal;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && true && module.exports;
      var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(outputType, is2242) {
        return function(message2) {
          return new Sha256(is2242, true).update(message2)[outputType]();
        };
      };
      var createMethod = function(is2242) {
        var method2 = createOutputMethod("hex", is2242);
        if (NODE_JS) {
          method2 = nodeWrap(method2, is2242);
        }
        method2.create = function() {
          return new Sha256(is2242);
        };
        method2.update = function(message2) {
          return method2.create().update(message2);
        };
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type2 = OUTPUT_TYPES[i2];
          method2[type2] = createOutputMethod(type2, is2242);
        }
        return method2;
      };
      var nodeWrap = function(method, is224) {
        var crypto = eval("require('crypto')");
        var Buffer = eval("require('buffer').Buffer");
        var algorithm = is224 ? "sha224" : "sha256";
        var nodeMethod = function(message2) {
          if (typeof message2 === "string") {
            return crypto.createHash(algorithm).update(message2, "utf8").digest("hex");
          } else {
            if (message2 === null || message2 === void 0) {
              throw new Error(ERROR);
            } else if (message2.constructor === ArrayBuffer) {
              message2 = new Uint8Array(message2);
            }
          }
          if (Array.isArray(message2) || ArrayBuffer.isView(message2) || message2.constructor === Buffer) {
            return crypto.createHash(algorithm).update(new Buffer(message2)).digest("hex");
          } else {
            return method(message2);
          }
        };
        return nodeMethod;
      };
      var createHmacOutputMethod = function(outputType, is2242) {
        return function(key2, message2) {
          return new HmacSha256(key2, is2242, true).update(message2)[outputType]();
        };
      };
      var createHmacMethod = function(is2242) {
        var method2 = createHmacOutputMethod("hex", is2242);
        method2.create = function(key2) {
          return new HmacSha256(key2, is2242);
        };
        method2.update = function(key2, message2) {
          return method2.create(key2).update(message2);
        };
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type2 = OUTPUT_TYPES[i2];
          method2[type2] = createHmacOutputMethod(type2, is2242);
        }
        return method2;
      };
      function Sha256(is2242, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (is2242) {
          this.h0 = 3238371032;
          this.h1 = 914150663;
          this.h2 = 812702999;
          this.h3 = 4144912697;
          this.h4 = 4290775857;
          this.h5 = 1750603025;
          this.h6 = 1694076839;
          this.h7 = 3204075428;
        } else {
          this.h0 = 1779033703;
          this.h1 = 3144134277;
          this.h2 = 1013904242;
          this.h3 = 2773480762;
          this.h4 = 1359893119;
          this.h5 = 2600822924;
          this.h6 = 528734635;
          this.h7 = 1541459225;
        }
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
        this.is224 = is2242;
      }
      Sha256.prototype.update = function(message2) {
        if (this.finalized) {
          return;
        }
        var notString, type2 = typeof message2;
        if (type2 !== "string") {
          if (type2 === "object") {
            if (message2 === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && message2.constructor === ArrayBuffer) {
              message2 = new Uint8Array(message2);
            } else if (!Array.isArray(message2)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message2)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
          notString = true;
        }
        var code2, index = 0, i2, length = message2.length, blocks2 = this.blocks;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            for (i2 = this.start; index < length && i2 < 64; ++index) {
              blocks2[i2 >> 2] |= message2[index] << SHIFT[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index < length && i2 < 64; ++index) {
              code2 = message2.charCodeAt(index);
              if (code2 < 128) {
                blocks2[i2 >> 2] |= code2 << SHIFT[i2++ & 3];
              } else if (code2 < 2048) {
                blocks2[i2 >> 2] |= (192 | code2 >> 6) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
              } else if (code2 < 55296 || code2 >= 57344) {
                blocks2[i2 >> 2] |= (224 | code2 >> 12) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
              } else {
                code2 = 65536 + ((code2 & 1023) << 10 | message2.charCodeAt(++index) & 1023);
                blocks2[i2 >> 2] |= (240 | code2 >> 18) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          this.bytes += i2 - this.start;
          if (i2 >= 64) {
            this.block = blocks2[16];
            this.start = i2 - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i2;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha256.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i2 = this.lastByteIndex;
        blocks2[16] = this.block;
        blocks2[i2 >> 2] |= EXTRA[i2 & 3];
        this.block = blocks2[16];
        if (i2 >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[15] = this.bytes << 3;
        this.hash();
      };
      Sha256.prototype.hash = function() {
        var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f2 = this.h5, g2 = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj2, t1, t2, ch2, ab, da, cd, bc;
        for (j = 16; j < 64; ++j) {
          t1 = blocks2[j - 15];
          s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
          t1 = blocks2[j - 2];
          s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
        }
        bc = b & c;
        for (j = 0; j < 64; j += 4) {
          if (this.first) {
            if (this.is224) {
              ab = 300032;
              t1 = blocks2[0] - 1413257819;
              h = t1 - 150054599 << 0;
              d = t1 + 24177077 << 0;
            } else {
              ab = 704751109;
              t1 = blocks2[0] - 210244248;
              h = t1 - 1521486534 << 0;
              d = t1 + 143694565 << 0;
            }
            this.first = false;
          } else {
            s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
            s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
            ab = a & b;
            maj2 = ab ^ a & c ^ bc;
            ch2 = e & f2 ^ ~e & g2;
            t1 = h + s1 + ch2 + K[j] + blocks2[j];
            t2 = s0 + maj2;
            h = d + t1 << 0;
            d = t1 + t2 << 0;
          }
          s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
          s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
          da = d & a;
          maj2 = da ^ d & b ^ ab;
          ch2 = h & e ^ ~h & f2;
          t1 = g2 + s1 + ch2 + K[j + 1] + blocks2[j + 1];
          t2 = s0 + maj2;
          g2 = c + t1 << 0;
          c = t1 + t2 << 0;
          s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
          s1 = (g2 >>> 6 | g2 << 26) ^ (g2 >>> 11 | g2 << 21) ^ (g2 >>> 25 | g2 << 7);
          cd = c & d;
          maj2 = cd ^ c & a ^ da;
          ch2 = g2 & h ^ ~g2 & e;
          t1 = f2 + s1 + ch2 + K[j + 2] + blocks2[j + 2];
          t2 = s0 + maj2;
          f2 = b + t1 << 0;
          b = t1 + t2 << 0;
          s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
          s1 = (f2 >>> 6 | f2 << 26) ^ (f2 >>> 11 | f2 << 21) ^ (f2 >>> 25 | f2 << 7);
          bc = b & c;
          maj2 = bc ^ b & d ^ cd;
          ch2 = f2 & g2 ^ ~f2 & h;
          t1 = e + s1 + ch2 + K[j + 3] + blocks2[j + 3];
          t2 = s0 + maj2;
          e = a + t1 << 0;
          a = t1 + t2 << 0;
        }
        this.h0 = this.h0 + a << 0;
        this.h1 = this.h1 + b << 0;
        this.h2 = this.h2 + c << 0;
        this.h3 = this.h3 + d << 0;
        this.h4 = this.h4 + e << 0;
        this.h5 = this.h5 + f2 << 0;
        this.h6 = this.h6 + g2 << 0;
        this.h7 = this.h7 + h << 0;
      };
      Sha256.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
        if (!this.is224) {
          hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
        }
        return hex;
      };
      Sha256.prototype.toString = Sha256.prototype.hex;
      Sha256.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var arr = [
          h0 >> 24 & 255,
          h0 >> 16 & 255,
          h0 >> 8 & 255,
          h0 & 255,
          h1 >> 24 & 255,
          h1 >> 16 & 255,
          h1 >> 8 & 255,
          h1 & 255,
          h2 >> 24 & 255,
          h2 >> 16 & 255,
          h2 >> 8 & 255,
          h2 & 255,
          h3 >> 24 & 255,
          h3 >> 16 & 255,
          h3 >> 8 & 255,
          h3 & 255,
          h4 >> 24 & 255,
          h4 >> 16 & 255,
          h4 >> 8 & 255,
          h4 & 255,
          h5 >> 24 & 255,
          h5 >> 16 & 255,
          h5 >> 8 & 255,
          h5 & 255,
          h6 >> 24 & 255,
          h6 >> 16 & 255,
          h6 >> 8 & 255,
          h6 & 255
        ];
        if (!this.is224) {
          arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
        }
        return arr;
      };
      Sha256.prototype.array = Sha256.prototype.digest;
      Sha256.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer2 = new ArrayBuffer(this.is224 ? 28 : 32);
        var dataView = new DataView(buffer2);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        dataView.setUint32(20, this.h5);
        dataView.setUint32(24, this.h6);
        if (!this.is224) {
          dataView.setUint32(28, this.h7);
        }
        return buffer2;
      };
      function HmacSha256(key2, is2242, sharedMemory) {
        var i2, type2 = typeof key2;
        if (type2 === "string") {
          var bytes2 = [], length = key2.length, index = 0, code2;
          for (i2 = 0; i2 < length; ++i2) {
            code2 = key2.charCodeAt(i2);
            if (code2 < 128) {
              bytes2[index++] = code2;
            } else if (code2 < 2048) {
              bytes2[index++] = 192 | code2 >> 6;
              bytes2[index++] = 128 | code2 & 63;
            } else if (code2 < 55296 || code2 >= 57344) {
              bytes2[index++] = 224 | code2 >> 12;
              bytes2[index++] = 128 | code2 >> 6 & 63;
              bytes2[index++] = 128 | code2 & 63;
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | key2.charCodeAt(++i2) & 1023);
              bytes2[index++] = 240 | code2 >> 18;
              bytes2[index++] = 128 | code2 >> 12 & 63;
              bytes2[index++] = 128 | code2 >> 6 & 63;
              bytes2[index++] = 128 | code2 & 63;
            }
          }
          key2 = bytes2;
        } else {
          if (type2 === "object") {
            if (key2 === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && key2.constructor === ArrayBuffer) {
              key2 = new Uint8Array(key2);
            } else if (!Array.isArray(key2)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key2)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
        }
        if (key2.length > 64) {
          key2 = new Sha256(is2242, true).update(key2).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (i2 = 0; i2 < 64; ++i2) {
          var b = key2[i2] || 0;
          oKeyPad[i2] = 92 ^ b;
          iKeyPad[i2] = 54 ^ b;
        }
        Sha256.call(this, is2242, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha256.prototype = new Sha256();
      HmacSha256.prototype.finalize = function() {
        Sha256.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha256.call(this, this.is224, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha256.prototype.finalize.call(this);
        }
      };
      var exports = createMethod();
      exports.sha256 = exports;
      exports.sha224 = createMethod(true);
      exports.sha256.hmac = createHmacMethod();
      exports.sha224.hmac = createHmacMethod(true);
      if (COMMON_JS) {
        module.exports = exports;
      } else {
        root.sha256 = exports.sha256;
        root.sha224 = exports.sha224;
      }
    })();
  })(sha256$2);
  var sha256Exports = sha256$2.exports;
  const BigInteger$2 = lib$2;
  const Buffer$g = safeBufferExports.Buffer;
  const sha256$1 = sha256Exports;
  function bufferToInt(buffer2) {
    return BigInteger$2.fromBuffer(buffer2);
  }
  function intToBuffer$1(bigInteger) {
    return bigInteger.toBuffer(32);
  }
  function hash$2(buffer2) {
    return Buffer$g.from(sha256$1.create().update(buffer2).array());
  }
  var convert$4 = {
    bufferToInt,
    intToBuffer: intToBuffer$1,
    hash: hash$2
  };
  const BigInteger$1 = lib$2;
  const Buffer$f = safeBufferExports.Buffer;
  const ecurve$3 = lib$1;
  const randomBytes = browserExports;
  const curve$3 = ecurve$3.getCurveByName("secp256k1");
  const check$2 = check$3;
  const convert$3 = convert$4;
  const concat$3 = Buffer$f.concat;
  const G$3 = curve$3.G;
  const p = curve$3.p;
  const n$2 = curve$3.n;
  const zero$1 = BigInteger$1.ZERO;
  const one = BigInteger$1.ONE;
  const two = BigInteger$1.valueOf(2);
  const three = BigInteger$1.valueOf(3);
  const four = BigInteger$1.valueOf(4);
  const seven = BigInteger$1.valueOf(7);
  function deterministicGetK0(privateKey, publicKey, message2) {
    check$2.checkSignParams(privateKey, message2);
    const h = taggedHash("BIP0340/nonce", concat$3([convert$3.intToBuffer(privateKey), publicKey, message2]));
    const i2 = convert$3.bufferToInt(h);
    return i2.mod(n$2);
  }
  function isEven(pubKey) {
    return pubKey.affineY.mod(two).equals(zero$1);
  }
  function getEvenKey(pubKey, privateKey) {
    if (isEven(pubKey)) {
      return privateKey.clone();
    }
    return n$2.subtract(privateKey);
  }
  function getE(Rx, Px, m) {
    const hash2 = taggedHash("BIP0340/challenge", concat$3([Rx, Px, m]));
    return convert$3.bufferToInt(hash2).mod(n$2);
  }
  function getR(s2, e, P) {
    const sG = G$3.multiply(s2);
    const eP = P.multiply(e);
    return sG.add(eP.negate());
  }
  function taggedHash(tag, msg) {
    const tagHash = convert$3.hash(tag);
    return convert$3.hash(concat$3([tagHash, tagHash, Buffer$f.from(msg)]));
  }
  function liftX(Px) {
    const x = convert$3.bufferToInt(Px);
    const c = x.pow(three).add(seven).mod(p);
    const y = c.modPow(p.add(one).divide(four), p);
    if (c.compareTo(y.modPow(two, p)) !== 0) {
      throw new Error("c is not equal to y^2");
    }
    let P = ecurve$3.Point.fromAffine(curve$3, x, y);
    if (!isEven(P)) {
      P = ecurve$3.Point.fromAffine(curve$3, x, p.subtract(y));
    }
    check$2.checkPointExists(true, P);
    return P;
  }
  function randomA() {
    let a = null;
    for (; ; ) {
      a = convert$3.bufferToInt(Buffer$f.from(randomBytes(32)));
      try {
        check$2.checkRange("a", a);
        return a;
      } catch (e) {
      }
    }
  }
  var math$3 = {
    deterministicGetK0,
    isEven,
    getEvenKey,
    getE,
    getR,
    taggedHash,
    liftX,
    randomA
  };
  const BigInteger = lib$2;
  const Buffer$e = safeBufferExports.Buffer;
  const ecurve$2 = lib$1;
  const curve$2 = ecurve$2.getCurveByName("secp256k1");
  const math$2 = math$3;
  const check$1 = check$3;
  const convert$2 = convert$4;
  const concat$2 = Buffer$e.concat;
  const G$2 = curve$2.G;
  curve$2.p;
  const n$1 = curve$2.n;
  const zero = BigInteger.ZERO;
  function sign(privateKey, message2, aux) {
    check$1.checkSignParams(privateKey, message2);
    privateKey = typeof privateKey == "string" ? BigInteger.fromHex(privateKey) : privateKey;
    const P = G$2.multiply(privateKey);
    const Px = convert$2.intToBuffer(P.affineX);
    const d = math$2.getEvenKey(P, privateKey);
    let kPrime;
    if (aux) {
      check$1.checkAux(aux);
      const t = convert$2.intToBuffer(d.xor(convert$2.bufferToInt(math$2.taggedHash("BIP0340/aux", aux))));
      const rand2 = math$2.taggedHash("BIP0340/nonce", concat$2([t, Px, message2]));
      kPrime = convert$2.bufferToInt(rand2).mod(n$1);
    } else {
      kPrime = math$2.deterministicGetK0(d, Px, message2);
    }
    if (kPrime.signum() === 0) {
      throw new Error("kPrime is zero");
    }
    const R = G$2.multiply(kPrime);
    const k2 = math$2.getEvenKey(R, kPrime);
    const Rx = convert$2.intToBuffer(R.affineX);
    const e = math$2.getE(Rx, Px, message2);
    return concat$2([Rx, convert$2.intToBuffer(k2.add(e.multiply(d)).mod(n$1))]);
  }
  function verify(pubKey, message2, signature2) {
    check$1.checkVerifyParams(pubKey, message2, signature2);
    const P = math$2.liftX(pubKey);
    const Px = convert$2.intToBuffer(P.affineX);
    const r2 = convert$2.bufferToInt(signature2.slice(0, 32));
    const s2 = convert$2.bufferToInt(signature2.slice(32, 64));
    check$1.checkSignatureInput(r2, s2);
    const e = math$2.getE(convert$2.intToBuffer(r2), Px, message2);
    const R = math$2.getR(s2, e, P);
    if (R.curve.isInfinity(R) || !math$2.isEven(R) || !R.affineX.equals(r2)) {
      throw new Error("signature verification failed");
    }
  }
  function batchVerify(pubKeys, messages, signatures) {
    check$1.checkBatchVerifyParams(pubKeys, messages, signatures);
    let leftSide = zero;
    let rightSide = null;
    for (let i2 = 0; i2 < pubKeys.length; i2++) {
      const P = math$2.liftX(pubKeys[i2]);
      const Px = convert$2.intToBuffer(P.affineX);
      const r2 = convert$2.bufferToInt(signatures[i2].slice(0, 32));
      const s2 = convert$2.bufferToInt(signatures[i2].slice(32, 64));
      check$1.checkSignatureInput(r2, s2);
      const e = math$2.getE(convert$2.intToBuffer(r2), Px, messages[i2]);
      const R = math$2.liftX(signatures[i2].slice(0, 32));
      if (i2 === 0) {
        leftSide = leftSide.add(s2);
        rightSide = R;
        rightSide = rightSide.add(P.multiply(e));
      } else {
        const a = math$2.randomA();
        leftSide = leftSide.add(a.multiply(s2));
        rightSide = rightSide.add(R.multiply(a));
        rightSide = rightSide.add(P.multiply(a.multiply(e)));
      }
    }
    if (!G$2.multiply(leftSide).equals(rightSide)) {
      throw new Error("signature verification failed");
    }
  }
  var schnorr$1 = {
    sign,
    verify,
    batchVerify
  };
  const Buffer$d = safeBufferExports.Buffer;
  const ecurve$1 = lib$1;
  const curve$1 = ecurve$1.getCurveByName("secp256k1");
  const math$1 = math$3;
  const check = check$3;
  const convert$1 = convert$4;
  const concat$1 = Buffer$d.concat;
  const G$1 = curve$1.G;
  const n = curve$1.n;
  const MUSIG_TAG = convert$1.hash(Buffer$d.from("MuSig coefficient"));
  function computeEll(pubKeys) {
    check.checkPubKeyArr(pubKeys);
    return convert$1.hash(concat$1(pubKeys));
  }
  function computeCoefficient(ell, idx) {
    const idxBuf = Buffer$d.alloc(4);
    idxBuf.writeUInt32LE(idx);
    const data2 = concat$1([MUSIG_TAG, MUSIG_TAG, ell, idxBuf]);
    return convert$1.bufferToInt(convert$1.hash(data2)).mod(n);
  }
  function pubKeyCombine(pubKeys, pubKeyHash) {
    const ell = pubKeyHash || computeEll(pubKeys);
    let X = null;
    for (let i2 = 0; i2 < pubKeys.length; i2++) {
      const Xi = math$1.liftX(pubKeys[i2]);
      const coefficient = computeCoefficient(ell, i2);
      const summand = Xi.multiply(coefficient);
      if (X === null) {
        X = summand;
      } else {
        X = X.add(summand);
      }
    }
    return X;
  }
  function sessionInitialize(sessionId, privateKey, message2, pubKeyCombined, pkParity, ell, idx) {
    check.checkSessionParams(sessionId, privateKey, message2, pubKeyCombined, ell);
    const session = {
      sessionId,
      message: message2,
      pubKeyCombined,
      pkParity,
      ell,
      idx
    };
    const coefficient = computeCoefficient(ell, idx);
    session.secretKey = privateKey.multiply(coefficient).mod(n);
    session.ownKeyParity = math$1.isEven(G$1.multiply(privateKey));
    if (session.pkParity !== session.ownKeyParity) {
      session.secretKey = n.subtract(session.secretKey);
    }
    const nonceData = concat$1([sessionId, message2, session.pubKeyCombined, convert$1.intToBuffer(privateKey)]);
    session.secretNonce = convert$1.bufferToInt(convert$1.hash(nonceData));
    check.checkRange("secretNonce", session.secretNonce);
    const R = G$1.multiply(session.secretNonce);
    session.nonce = convert$1.intToBuffer(R.affineX);
    session.nonceParity = math$1.isEven(R);
    session.commitment = convert$1.hash(session.nonce);
    return session;
  }
  function sessionNonceCombine(session, nonces) {
    check.checkNonceArr(nonces);
    let R = math$1.liftX(nonces[0]);
    for (let i2 = 1; i2 < nonces.length; i2++) {
      R = R.add(math$1.liftX(nonces[i2]));
    }
    session.combinedNonceParity = math$1.isEven(R);
    return convert$1.intToBuffer(R.affineX);
  }
  function partialSign(session, message2, nonceCombined, pubKeyCombined) {
    const e = math$1.getE(nonceCombined, pubKeyCombined, message2);
    const sk = session.secretKey;
    let k2 = session.secretNonce;
    if (session.nonceParity !== session.combinedNonceParity) {
      k2 = n.subtract(k2);
    }
    return sk.multiply(e).add(k2).mod(n);
  }
  function partialSigVerify(session, partialSig, nonceCombined, idx, pubKey, nonce) {
    let e = math$1.getE(nonceCombined, session.pubKeyCombined, session.message);
    const coefficient = computeCoefficient(session.ell, idx);
    const Pj = math$1.liftX(pubKey);
    const Ri = math$1.liftX(nonce);
    if (!session.pkParity) {
      e = n.subtract(e);
    }
    let RP = math$1.getR(partialSig, e.multiply(coefficient).mod(n), Pj);
    if (session.combinedNonceParity) {
      RP = RP.negate();
    }
    const sum = RP.add(Ri);
    if (!sum.curve.isInfinity(sum)) {
      throw new Error("partial signature verification failed");
    }
  }
  function partialSigCombine(nonceCombined, partialSigs) {
    const R = math$1.liftX(nonceCombined);
    check.checkArray("partialSigs", partialSigs);
    const Rx = convert$1.intToBuffer(R.affineX);
    let s2 = partialSigs[0];
    for (let i2 = 1; i2 < partialSigs.length; i2++) {
      s2 = s2.add(partialSigs[i2]).mod(n);
    }
    return concat$1([Rx, convert$1.intToBuffer(s2)]);
  }
  var muSig = {
    computeEll,
    computeCoefficient,
    pubKeyCombine,
    sessionInitialize,
    sessionNonceCombine,
    partialSign,
    partialSigVerify,
    partialSigCombine
  };
  const Buffer$c = safeBufferExports.Buffer;
  const ecurve = lib$1;
  const curve = ecurve.getCurveByName("secp256k1");
  const math = math$3;
  const convert = convert$4;
  const concat = Buffer$c.concat;
  const G = curve.G;
  function taprootConstruct(pubKey, scripts2) {
    if (!scripts2) {
      scripts2 = [];
    }
    const h = taprootTree(scripts2);
    const Px = convert.intToBuffer(pubKey.affineX);
    const P = math.liftX(Px);
    const tweak = convert.bufferToInt(math.taggedHash("TapTweak", concat([Px, h])));
    const Q = P.add(G.multiply(tweak));
    return convert.intToBuffer(Q.affineX);
  }
  function taprootTree(scripts2) {
    let h = Buffer$c.alloc(32, 0);
    if (!scripts2 || scripts2.length === 0) {
      return new Buffer$c(0);
    }
    return h;
  }
  var taproot = {
    taprootConstruct
  };
  const schnorr = schnorr$1;
  schnorr.check = check$3;
  schnorr.convert = convert$4;
  schnorr.math = math$3;
  schnorr.muSig = muSig;
  schnorr.taproot = taproot;
  var src = schnorr;
  var input$1 = { exports: {} };
  var input;
  var hasRequiredInput$1;
  function requireInput$1() {
    if (hasRequiredInput$1)
      return input;
    hasRequiredInput$1 = 1;
    var _2 = lodashExports;
    var $2 = preconditions;
    const errors2 = errorsExports;
    var BufferWriter2 = bufferwriter;
    var BufferUtil2 = bufferExports;
    var JSUtil2 = js$1;
    var Script = requireScript();
    var Sighash = requireSighash();
    var Output = requireOutput();
    var MAXINT = 4294967295;
    var DEFAULT_SEQNUMBER = MAXINT;
    var DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;
    var DEFAULT_RBF_SEQNUMBER = MAXINT - 2;
    const SEQUENCE_LOCKTIME_DISABLE_FLAG2 = Math.pow(2, 31);
    const SEQUENCE_LOCKTIME_TYPE_FLAG = Math.pow(2, 22);
    const SEQUENCE_LOCKTIME_MASK = 65535;
    const SEQUENCE_LOCKTIME_GRANULARITY = 512;
    const SEQUENCE_BLOCKDIFF_LIMIT = Math.pow(2, 16) - 1;
    function Input(params) {
      if (!(this instanceof Input)) {
        return new Input(params);
      }
      if (params) {
        return this._fromObject(params);
      }
    }
    Input.MAXINT = MAXINT;
    Input.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;
    Input.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;
    Input.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;
    Input.SEQUENCE_LOCKTIME_TYPE_FLAG = SEQUENCE_LOCKTIME_TYPE_FLAG;
    Object.defineProperty(Input.prototype, "script", {
      configurable: false,
      enumerable: true,
      get: function() {
        if (this.isNull()) {
          return null;
        }
        if (!this._script) {
          this._script = new Script(this._scriptBuffer);
          this._script._isInput = true;
        }
        return this._script;
      }
    });
    Input.fromObject = function(obj) {
      $2.checkArgument(_2.isObject(obj));
      var input2 = new Input();
      return input2._fromObject(obj);
    };
    Input.prototype._fromObject = function(params) {
      var prevTxId;
      if (_2.isString(params.prevTxId) && JSUtil2.isHexa(params.prevTxId)) {
        prevTxId = buffer$2.Buffer.from(params.prevTxId, "hex");
      } else {
        prevTxId = params.prevTxId;
      }
      this.witnesses = [];
      this.output = params.output ? params.output instanceof Output ? params.output : new Output(params.output) : void 0;
      this.prevTxId = prevTxId || params.txidbuf;
      this.outputIndex = _2.isUndefined(params.outputIndex) ? params.txoutnum : params.outputIndex;
      this.sequenceNumber = _2.isUndefined(params.sequenceNumber) ? _2.isUndefined(params.seqnum) ? DEFAULT_SEQNUMBER : params.seqnum : params.sequenceNumber;
      if (_2.isUndefined(params.script) && _2.isUndefined(params.scriptBuffer)) {
        throw new errors2.Transaction.Input.MissingScript();
      }
      this.setScript(params.scriptBuffer || params.script);
      return this;
    };
    Input.prototype.toObject = Input.prototype.toJSON = function toObject2() {
      var obj = {
        prevTxId: this.prevTxId.toString("hex"),
        outputIndex: this.outputIndex,
        sequenceNumber: this.sequenceNumber,
        script: this._scriptBuffer.toString("hex")
      };
      if (this.script) {
        obj.scriptString = this.script.toString();
      }
      if (this.output) {
        obj.output = this.output.toObject();
      }
      return obj;
    };
    Input.fromBufferReader = function(br) {
      var input2 = new Input();
      input2.prevTxId = br.readReverse(32);
      input2.outputIndex = br.readUInt32LE();
      input2._scriptBuffer = br.readVarLengthBuffer();
      input2.sequenceNumber = br.readUInt32LE();
      return input2;
    };
    Input.prototype.toBufferWriter = function(writer) {
      if (!writer) {
        writer = new BufferWriter2();
      }
      writer.writeReverse(this.prevTxId);
      writer.writeUInt32LE(this.outputIndex);
      var script2 = this._scriptBuffer;
      writer.writeVarintNum(script2.length);
      writer.write(script2);
      writer.writeUInt32LE(this.sequenceNumber);
      return writer;
    };
    Input.prototype.setScript = function(script2) {
      this._script = null;
      if (script2 instanceof Script) {
        this._script = script2;
        this._script._isInput = true;
        this._scriptBuffer = script2.toBuffer();
      } else if (JSUtil2.isHexa(script2)) {
        this._scriptBuffer = buffer$2.Buffer.from(script2, "hex");
      } else if (_2.isString(script2)) {
        this._script = new Script(script2);
        this._script._isInput = true;
        this._scriptBuffer = this._script.toBuffer();
      } else if (BufferUtil2.isBuffer(script2)) {
        this._scriptBuffer = buffer$2.Buffer.from(script2);
      } else {
        throw new TypeError("Invalid argument type: script");
      }
      return this;
    };
    Input.prototype.getSignatures = function() {
      throw new errors2.AbstractMethodInvoked(
        "Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported) for input: " + JSON.stringify(this)
      );
    };
    Input.prototype.getSatoshisBuffer = function() {
      $2.checkState(this.output instanceof Output);
      $2.checkState(this.output._satoshisBN);
      return new BufferWriter2().writeUInt64LEBN(this.output._satoshisBN).toBuffer();
    };
    Input.prototype.isFullySigned = function() {
      throw new errors2.AbstractMethodInvoked("Input#isFullySigned");
    };
    Input.prototype.isFinal = function() {
      return this.sequenceNumber !== Input.MAXINT;
    };
    Input.prototype.addSignature = function() {
      throw new errors2.AbstractMethodInvoked("Input#addSignature");
    };
    Input.prototype.clearSignatures = function() {
      throw new errors2.AbstractMethodInvoked("Input#clearSignatures");
    };
    Input.prototype.hasWitnesses = function() {
      if (this.witnesses && this.witnesses.length > 0) {
        return true;
      }
      return false;
    };
    Input.prototype.getWitnesses = function() {
      return this.witnesses;
    };
    Input.prototype.setWitnesses = function(witnesses) {
      this.witnesses = witnesses;
    };
    Input.prototype.isValidSignature = function(transaction2, signature2, signingMethod) {
      signingMethod = signingMethod || "ecdsa";
      signature2.signature.nhashtype = signature2.sigtype;
      return Sighash.verify(
        transaction2,
        signature2.signature,
        signature2.publicKey,
        signature2.inputIndex,
        this.output.script,
        signingMethod
      );
    };
    Input.prototype.isNull = function() {
      return this.prevTxId.toString("hex") === "0000000000000000000000000000000000000000000000000000000000000000" && this.outputIndex === 4294967295;
    };
    Input.prototype._estimateSize = function() {
      return this.toBufferWriter().toBuffer().length;
    };
    Input.prototype.lockForSeconds = function(seconds) {
      $2.checkArgument(_2.isNumber(seconds));
      if (seconds < 0 || seconds >= SEQUENCE_LOCKTIME_GRANULARITY * SEQUENCE_LOCKTIME_MASK) {
        throw new errors2.Transaction.Input.LockTimeRange();
      }
      seconds = parseInt(Math.floor(seconds / SEQUENCE_LOCKTIME_GRANULARITY));
      this.sequenceNumber = seconds | SEQUENCE_LOCKTIME_TYPE_FLAG;
      return this;
    };
    Input.prototype.lockUntilBlockHeight = function(heightDiff) {
      $2.checkArgument(_2.isNumber(heightDiff));
      if (heightDiff < 0 || heightDiff >= SEQUENCE_BLOCKDIFF_LIMIT) {
        throw new errors2.Transaction.Input.BlockHeightOutOfRange();
      }
      this.sequenceNumber = heightDiff;
      return this;
    };
    Input.prototype.getLockTime = function() {
      if (this.sequenceNumber & SEQUENCE_LOCKTIME_DISABLE_FLAG2) {
        return null;
      }
      if (this.sequenceNumber & SEQUENCE_LOCKTIME_TYPE_FLAG) {
        var seconds = SEQUENCE_LOCKTIME_GRANULARITY * (this.sequenceNumber & SEQUENCE_LOCKTIME_MASK);
        return seconds;
      } else {
        var blockHeight = this.sequenceNumber & SEQUENCE_LOCKTIME_MASK;
        return blockHeight;
      }
    };
    input = Input;
    return input;
  }
  var inherits_browser = { exports: {} };
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  var inherits_browserExports = inherits_browser.exports;
  var signature$1;
  var hasRequiredSignature;
  function requireSignature() {
    if (hasRequiredSignature)
      return signature$1;
    hasRequiredSignature = 1;
    var _2 = lodashExports;
    var $2 = preconditions;
    var inherits2 = inherits_browserExports;
    var BufferUtil2 = bufferExports;
    var JSUtil2 = js$1;
    var PublicKey2 = requirePublickey();
    var errors2 = errorsExports;
    var Signature2 = signature$2;
    function TransactionSignature(arg) {
      if (!(this instanceof TransactionSignature)) {
        return new TransactionSignature(arg);
      }
      if (arg instanceof TransactionSignature) {
        return arg;
      }
      if (_2.isObject(arg)) {
        return this._fromObject(arg);
      }
      throw new errors2.InvalidArgument("TransactionSignatures must be instantiated from an object");
    }
    inherits2(TransactionSignature, Signature2);
    TransactionSignature.prototype._fromObject = function(arg) {
      this._checkObjectArgs(arg);
      this.publicKey = new PublicKey2(arg.publicKey);
      this.prevTxId = BufferUtil2.isBuffer(arg.prevTxId) ? arg.prevTxId : buffer$2.Buffer.from(arg.prevTxId, "hex");
      this.outputIndex = arg.outputIndex;
      this.inputIndex = arg.inputIndex;
      this.signature = arg.signature instanceof Signature2 ? arg.signature : BufferUtil2.isBuffer(arg.signature) ? Signature2.fromBuffer(arg.signature) : Signature2.fromString(arg.signature);
      this.sigtype = arg.sigtype;
      return this;
    };
    TransactionSignature.prototype._checkObjectArgs = function(arg) {
      $2.checkArgument(PublicKey2(arg.publicKey), "publicKey");
      $2.checkArgument(!_2.isUndefined(arg.inputIndex), "inputIndex");
      $2.checkArgument(!_2.isUndefined(arg.outputIndex), "outputIndex");
      $2.checkState(_2.isNumber(arg.inputIndex), "inputIndex must be a number");
      $2.checkState(_2.isNumber(arg.outputIndex), "outputIndex must be a number");
      $2.checkArgument(arg.signature, "signature");
      $2.checkArgument(arg.prevTxId, "prevTxId");
      $2.checkState(arg.signature instanceof Signature2 || BufferUtil2.isBuffer(arg.signature) || JSUtil2.isHexa(arg.signature), "signature must be a buffer or hexa value");
      $2.checkState(BufferUtil2.isBuffer(arg.prevTxId) || JSUtil2.isHexa(arg.prevTxId), "prevTxId must be a buffer or hexa value");
      $2.checkArgument(arg.sigtype, "sigtype");
      $2.checkState(_2.isNumber(arg.sigtype), "sigtype must be a number");
    };
    TransactionSignature.prototype.toObject = TransactionSignature.prototype.toJSON = function toObject2() {
      return {
        publicKey: this.publicKey.toString(),
        prevTxId: this.prevTxId.toString("hex"),
        outputIndex: this.outputIndex,
        inputIndex: this.inputIndex,
        signature: this.signature.toString(),
        sigtype: this.sigtype
      };
    };
    TransactionSignature.fromObject = function(object2) {
      $2.checkArgument(object2);
      return new TransactionSignature(object2);
    };
    signature$1 = TransactionSignature;
    return signature$1;
  }
  var publickey$1;
  var hasRequiredPublickey$1;
  function requirePublickey$1() {
    if (hasRequiredPublickey$1)
      return publickey$1;
    hasRequiredPublickey$1 = 1;
    var inherits2 = inherits_browserExports;
    var $2 = preconditions;
    var Input = requireInput$1();
    var Output = requireOutput();
    var Sighash = requireSighash();
    var Script = requireScript();
    var Signature2 = signature$2;
    var TransactionSignature = requireSignature();
    function PublicKeyInput() {
      Input.apply(this, arguments);
    }
    inherits2(PublicKeyInput, Input);
    PublicKeyInput.prototype.getSignatures = function(transaction2, privateKey, index, sigtype, hashData, signingMethod) {
      $2.checkState(this.output instanceof Output);
      sigtype = sigtype || Signature2.SIGHASH_ALL;
      var publicKey = privateKey.toPublicKey();
      if (publicKey.toString() === this.output.script.getPublicKey().toString("hex")) {
        return [new TransactionSignature({
          publicKey,
          prevTxId: this.prevTxId,
          outputIndex: this.outputIndex,
          inputIndex: index,
          signature: Sighash.sign(transaction2, privateKey, sigtype, index, this.output.script, signingMethod),
          sigtype
        })];
      }
      return [];
    };
    PublicKeyInput.prototype.addSignature = function(transaction2, signature2, signingMethod) {
      $2.checkState(this.isValidSignature(transaction2, signature2, signingMethod), "Signature is invalid");
      this.setScript(Script.buildPublicKeyIn(
        signature2.signature.toDER(),
        signature2.sigtype
      ));
      return this;
    };
    PublicKeyInput.prototype.clearSignatures = function() {
      this.setScript(Script.empty());
      return this;
    };
    PublicKeyInput.prototype.isFullySigned = function() {
      return this.script.isPublicKeyIn();
    };
    PublicKeyInput.SCRIPT_MAX_SIZE = 73;
    PublicKeyInput.prototype._estimateSize = function() {
      return PublicKeyInput.SCRIPT_MAX_SIZE;
    };
    publickey$1 = PublicKeyInput;
    return publickey$1;
  }
  var sighashwitness;
  var hasRequiredSighashwitness;
  function requireSighashwitness() {
    if (hasRequiredSighashwitness)
      return sighashwitness;
    hasRequiredSighashwitness = 1;
    var Signature2 = signature$2;
    requireScript();
    requireOutput();
    var BufferReader2 = bufferreader;
    var BufferWriter2 = bufferwriter;
    var Hash2 = hashExports;
    var ECDSA2 = requireEcdsa();
    var $2 = preconditions;
    var _2 = lodashExports;
    var sighash = function sighash2(transaction2, sighashType, inputNumber, scriptCode, satoshisBuffer) {
      var hashPrevouts;
      var hashSequence;
      var hashOutputs;
      if (!(sighashType & Signature2.SIGHASH_ANYONECANPAY)) {
        var buffers = [];
        for (var n2 = 0; n2 < transaction2.inputs.length; n2++) {
          var input2 = transaction2.inputs[n2];
          var prevTxIdBuffer = new BufferReader2(input2.prevTxId).readReverse();
          buffers.push(prevTxIdBuffer);
          var outputIndexBuffer = buffer$2.Buffer.alloc(4);
          outputIndexBuffer.writeUInt32LE(input2.outputIndex, 0);
          buffers.push(outputIndexBuffer);
        }
        hashPrevouts = Hash2.sha256sha256(buffer$2.Buffer.concat(buffers));
      }
      if (!(sighashType & Signature2.SIGHASH_ANYONECANPAY) && (sighashType & 31) !== Signature2.SIGHASH_SINGLE && (sighashType & 31) !== Signature2.SIGHASH_NONE) {
        var sequenceBuffers = [];
        for (var m = 0; m < transaction2.inputs.length; m++) {
          var sequenceBuffer = buffer$2.Buffer.alloc(4);
          sequenceBuffer.writeUInt32LE(transaction2.inputs[m].sequenceNumber, 0);
          sequenceBuffers.push(sequenceBuffer);
        }
        hashSequence = Hash2.sha256sha256(buffer$2.Buffer.concat(sequenceBuffers));
      }
      var outputWriter = new BufferWriter2();
      if ((sighashType & 31) !== Signature2.SIGHASH_SINGLE && (sighashType & 31) !== Signature2.SIGHASH_NONE) {
        for (var p2 = 0; p2 < transaction2.outputs.length; p2++) {
          transaction2.outputs[p2].toBufferWriter(outputWriter);
        }
        hashOutputs = Hash2.sha256sha256(outputWriter.toBuffer());
      } else if ((sighashType & 31) === Signature2.SIGHASH_SINGLE && inputNumber < transaction2.outputs.length) {
        transaction2.outputs[inputNumber].toBufferWriter(outputWriter);
        hashOutputs = Hash2.sha256sha256(outputWriter.toBuffer());
      }
      var writer = new BufferWriter2();
      writer.writeUInt32LE(transaction2.version);
      writer.write(hashPrevouts);
      writer.write(hashSequence);
      var outpointId = new BufferReader2(transaction2.inputs[inputNumber].prevTxId).readReverse();
      writer.write(outpointId);
      writer.writeUInt32LE(transaction2.inputs[inputNumber].outputIndex);
      writer.write(scriptCode);
      writer.write(satoshisBuffer);
      writer.writeUInt32LE(transaction2.inputs[inputNumber].sequenceNumber);
      writer.write(hashOutputs);
      writer.writeUInt32LE(transaction2.nLockTime);
      writer.writeInt32LE(sighashType);
      return Hash2.sha256sha256(writer.toBuffer());
    };
    function sign2(transaction2, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer, signingMethod) {
      signingMethod = signingMethod || "ecdsa";
      var sig;
      if (signingMethod === "ecdsa") {
        let hashbuf = sighash(transaction2, sighashType, inputIndex, scriptCode, satoshisBuffer);
        sig = ECDSA2.sign(hashbuf, privateKey).set({
          nhashtype: sighashType
        });
        return sig;
      }
      throw new Error("signingMethod not supported ", signingMethod);
    }
    function verify2(transaction2, signature2, publicKey, inputIndex, scriptCode, satoshisBuffer, signingMethod) {
      $2.checkArgument(!_2.isUndefined(transaction2));
      $2.checkArgument(!_2.isUndefined(signature2) && !_2.isUndefined(signature2.nhashtype));
      signingMethod = signingMethod || "ecdsa";
      if (signingMethod === "ecdsa") {
        let hashbuf = sighash(transaction2, signature2.nhashtype, inputIndex, scriptCode, satoshisBuffer);
        return ECDSA2.verify(hashbuf, signature2, publicKey);
      }
      throw new Error("signingMethod not supported ", signingMethod);
    }
    sighashwitness = {
      sighash,
      sign: sign2,
      verify: verify2
    };
    return sighashwitness;
  }
  var publickeyhash;
  var hasRequiredPublickeyhash;
  function requirePublickeyhash() {
    if (hasRequiredPublickeyhash)
      return publickeyhash;
    hasRequiredPublickeyhash = 1;
    var inherits2 = inherits_browserExports;
    var $2 = preconditions;
    var BufferUtil2 = bufferExports;
    requireAddress();
    var Hash2 = hashExports;
    var Input = requireInput$1();
    var Output = requireOutput();
    var Sighash = requireSighash();
    var SighashWitness = requireSighashwitness();
    var BufferWriter2 = bufferwriter;
    var BufferUtil2 = bufferExports;
    var Script = requireScript();
    var Signature2 = signature$2;
    var TransactionSignature = requireSignature();
    function PublicKeyHashInput() {
      Input.apply(this, arguments);
    }
    inherits2(PublicKeyHashInput, Input);
    PublicKeyHashInput.prototype.getRedeemScript = function(publicKey) {
      if (!this.redeemScript) {
        var redeemScript = Script.buildWitnessV0Out(publicKey);
        if (Script.buildScriptHashOut(redeemScript).equals(this.output.script)) {
          var scriptSig = new Script();
          scriptSig.add(redeemScript.toBuffer());
          this.setScript(scriptSig);
          this.redeemScript = redeemScript;
        }
      }
      return this.redeemScript;
    };
    PublicKeyHashInput.prototype.getScriptCode = function(publicKey) {
      var writer = new BufferWriter2();
      var script2;
      if (this.output.script.isScriptHashOut()) {
        script2 = this.getRedeemScript(publicKey);
      } else {
        script2 = this.output.script;
      }
      var scriptBuffer = Script.buildPublicKeyHashOut(script2.toAddress()).toBuffer();
      writer.writeVarintNum(scriptBuffer.length);
      writer.write(scriptBuffer);
      return writer.toBuffer();
    };
    PublicKeyHashInput.prototype.getSighash = function(transaction2, privateKey, index, sigtype) {
      var scriptCode = this.getScriptCode(privateKey);
      var satoshisBuffer = this.getSatoshisBuffer();
      return SighashWitness.sighash(transaction2, sigtype, index, scriptCode, satoshisBuffer);
    };
    PublicKeyHashInput.prototype.getSignatures = function(transaction2, privateKey, index, sigtype, hashData, signingMethod) {
      $2.checkState(this.output instanceof Output);
      hashData = hashData || Hash2.sha256ripemd160(privateKey.publicKey.toBuffer());
      sigtype = sigtype || Signature2.SIGHASH_ALL;
      signingMethod = signingMethod || "ecdsa";
      var script2;
      if (this.output.script.isScriptHashOut()) {
        script2 = this.getRedeemScript(privateKey.publicKey);
      } else {
        script2 = this.output.script;
      }
      if (script2 && BufferUtil2.equals(hashData, script2.getPublicKeyHash())) {
        var signature2;
        if (script2.isWitnessPublicKeyHashOut()) {
          var satoshisBuffer = this.getSatoshisBuffer();
          var scriptCode = this.getScriptCode(privateKey.publicKey);
          signature2 = SighashWitness.sign(transaction2, privateKey, sigtype, index, scriptCode, satoshisBuffer, signingMethod);
        } else {
          signature2 = Sighash.sign(transaction2, privateKey, sigtype, index, this.output.script, signingMethod);
        }
        return [new TransactionSignature({
          publicKey: privateKey.publicKey,
          prevTxId: this.prevTxId,
          outputIndex: this.outputIndex,
          inputIndex: index,
          signature: signature2,
          sigtype
        })];
      }
      return [];
    };
    PublicKeyHashInput.prototype.addSignature = function(transaction2, signature2, signingMethod) {
      $2.checkState(this.isValidSignature(transaction2, signature2, signingMethod), "Signature is invalid");
      if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {
        this.setWitnesses([
          BufferUtil2.concat([
            signature2.signature.toDER(),
            BufferUtil2.integerAsSingleByteBuffer(signature2.sigtype)
          ]),
          signature2.publicKey.toBuffer()
        ]);
      } else {
        this.setScript(Script.buildPublicKeyHashIn(
          signature2.publicKey,
          signature2.signature.toDER(),
          signature2.sigtype
        ));
      }
      return this;
    };
    PublicKeyHashInput.prototype.clearSignatures = function() {
      this.setScript(Script.empty());
      this.setWitnesses([]);
      return this;
    };
    PublicKeyHashInput.prototype.isFullySigned = function() {
      return this.script.isPublicKeyHashIn() || this.hasWitnesses();
    };
    PublicKeyHashInput.prototype.isValidSignature = function(transaction2, signature2, signingMethod) {
      signature2.signature.nhashtype = signature2.sigtype;
      if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {
        var scriptCode = this.getScriptCode();
        var satoshisBuffer = this.getSatoshisBuffer();
        return SighashWitness.verify(
          transaction2,
          signature2.signature,
          signature2.publicKey,
          signature2.inputIndex,
          scriptCode,
          satoshisBuffer,
          signingMethod
        );
      } else {
        return Sighash.verify(
          transaction2,
          signature2.signature,
          signature2.publicKey,
          signature2.inputIndex,
          this.output.script,
          signingMethod
        );
      }
    };
    PublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34;
    PublicKeyHashInput.REDEEM_SCRIPT_SIZE = 22;
    PublicKeyHashInput.prototype._estimateSize = function() {
      var WITNESS_DISCOUNT = 4;
      const witnessSize = PublicKeyHashInput.SCRIPT_MAX_SIZE / WITNESS_DISCOUNT;
      if (this.output.script.isWitnessPublicKeyHashOut()) {
        return witnessSize;
      } else if (this.output.script.isScriptHashOut()) {
        return witnessSize + PublicKeyHashInput.REDEEM_SCRIPT_SIZE;
      } else {
        return PublicKeyHashInput.SCRIPT_MAX_SIZE;
      }
    };
    publickeyhash = PublicKeyHashInput;
    return publickeyhash;
  }
  var multisig;
  var hasRequiredMultisig;
  function requireMultisig() {
    if (hasRequiredMultisig)
      return multisig;
    hasRequiredMultisig = 1;
    var _2 = lodashExports;
    var inherits2 = inherits_browserExports;
    requireTransaction$1();
    var Input = requireInput$1();
    var Output = requireOutput();
    var $2 = preconditions;
    var Script = requireScript();
    var Signature2 = signature$2;
    var Sighash = requireSighash();
    requirePublickey();
    var BufferUtil2 = bufferExports;
    var TransactionSignature = requireSignature();
    function MultiSigInput(input2, pubkeys, threshold, signatures, opts) {
      opts = opts || {};
      Input.apply(this, arguments);
      var self2 = this;
      pubkeys = pubkeys || input2.publicKeys;
      threshold = threshold || input2.threshold;
      signatures = signatures || input2.signatures;
      if (opts.noSorting) {
        this.publicKeys = pubkeys;
      } else {
        this.publicKeys = _2.sortBy(pubkeys, function(publicKey) {
          return publicKey.toString("hex");
        });
      }
      $2.checkState(
        Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script),
        "Provided public keys don't match to the provided output script"
      );
      this.publicKeyIndex = {};
      _2.each(this.publicKeys, function(publicKey, index) {
        self2.publicKeyIndex[publicKey.toString()] = index;
      });
      this.threshold = threshold;
      this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);
    }
    inherits2(MultiSigInput, Input);
    MultiSigInput.prototype.toObject = function() {
      var obj = Input.prototype.toObject.apply(this, arguments);
      obj.threshold = this.threshold;
      obj.publicKeys = _2.map(this.publicKeys, function(publicKey) {
        return publicKey.toString();
      });
      obj.signatures = this._serializeSignatures();
      return obj;
    };
    MultiSigInput.prototype._deserializeSignatures = function(signatures) {
      return _2.map(signatures, function(signature2) {
        if (!signature2) {
          return void 0;
        }
        return new TransactionSignature(signature2);
      });
    };
    MultiSigInput.prototype._serializeSignatures = function() {
      return _2.map(this.signatures, function(signature2) {
        if (!signature2) {
          return void 0;
        }
        return signature2.toObject();
      });
    };
    MultiSigInput.prototype.getSignatures = function(transaction2, privateKey, index, sigtype, hashData, signingMethod) {
      $2.checkState(this.output instanceof Output);
      sigtype = sigtype || Signature2.SIGHASH_ALL;
      signingMethod = signingMethod || "ecdsa";
      var self2 = this;
      var results = [];
      _2.each(this.publicKeys, function(publicKey) {
        if (publicKey.toString() === privateKey.publicKey.toString()) {
          results.push(new TransactionSignature({
            publicKey: privateKey.publicKey,
            prevTxId: self2.prevTxId,
            outputIndex: self2.outputIndex,
            inputIndex: index,
            signature: Sighash.sign(transaction2, privateKey, sigtype, index, self2.output.script, signingMethod),
            sigtype
          }));
        }
      });
      return results;
    };
    MultiSigInput.prototype.addSignature = function(transaction2, signature2, signingMethod) {
      $2.checkState(!this.isFullySigned(), "All needed signatures have already been added");
      $2.checkArgument(
        !_2.isUndefined(this.publicKeyIndex[signature2.publicKey.toString()], "Signature Undefined"),
        "Signature has no matching public key"
      );
      $2.checkState(this.isValidSignature(transaction2, signature2, signingMethod), "Invalid Signature");
      this.signatures[this.publicKeyIndex[signature2.publicKey.toString()]] = signature2;
      this._updateScript();
      return this;
    };
    MultiSigInput.prototype._updateScript = function() {
      this.setScript(Script.buildMultisigIn(
        this.publicKeys,
        this.threshold,
        this._createSignatures()
      ));
      return this;
    };
    MultiSigInput.prototype._createSignatures = function() {
      return _2.map(
        _2.filter(this.signatures, function(signature2) {
          return !_2.isUndefined(signature2);
        }),
        // Future signature types may need refactor of toDER
        function(signature2) {
          return BufferUtil2.concat([
            signature2.signature.toDER(),
            BufferUtil2.integerAsSingleByteBuffer(signature2.sigtype)
          ]);
        }
      );
    };
    MultiSigInput.prototype.clearSignatures = function() {
      this.signatures = new Array(this.publicKeys.length);
      this._updateScript();
    };
    MultiSigInput.prototype.isFullySigned = function() {
      return this.countSignatures() === this.threshold;
    };
    MultiSigInput.prototype.countMissingSignatures = function() {
      return this.threshold - this.countSignatures();
    };
    MultiSigInput.prototype.countSignatures = function() {
      return _2.reduce(this.signatures, function(sum, signature2) {
        return sum + !!signature2;
      }, 0);
    };
    MultiSigInput.prototype.publicKeysWithoutSignature = function() {
      var self2 = this;
      return _2.filter(this.publicKeys, function(publicKey) {
        return !self2.signatures[self2.publicKeyIndex[publicKey.toString()]];
      });
    };
    MultiSigInput.prototype.isValidSignature = function(transaction2, signature2, signingMethod) {
      signature2.signature.nhashtype = signature2.sigtype;
      return Sighash.verify(
        transaction2,
        signature2.signature,
        signature2.publicKey,
        signature2.inputIndex,
        this.output.script,
        signingMethod
      );
    };
    MultiSigInput.normalizeSignatures = function(transaction2, input2, inputIndex, signatures, publicKeys, signingMethod) {
      return publicKeys.map(function(pubKey) {
        var signatureMatch = null;
        signatures = signatures.filter(function(signatureBuffer) {
          if (signatureMatch) {
            return true;
          }
          var signature2 = new TransactionSignature({
            signature: Signature2.fromTxFormat(signatureBuffer),
            publicKey: pubKey,
            prevTxId: input2.prevTxId,
            outputIndex: input2.outputIndex,
            inputIndex,
            sigtype: Signature2.SIGHASH_ALL
          });
          signature2.signature.nhashtype = signature2.sigtype;
          var isMatch = Sighash.verify(
            transaction2,
            signature2.signature,
            signature2.publicKey,
            signature2.inputIndex,
            input2.output.script,
            signingMethod
          );
          if (isMatch) {
            signatureMatch = signature2;
            return false;
          }
          return true;
        });
        return signatureMatch ? signatureMatch : null;
      });
    };
    MultiSigInput.OPCODES_SIZE = 1;
    MultiSigInput.SIGNATURE_SIZE = 73;
    MultiSigInput.prototype._estimateSize = function() {
      return MultiSigInput.OPCODES_SIZE + this.threshold * MultiSigInput.SIGNATURE_SIZE;
    };
    multisig = MultiSigInput;
    return multisig;
  }
  var multisigscripthash;
  var hasRequiredMultisigscripthash;
  function requireMultisigscripthash() {
    if (hasRequiredMultisigscripthash)
      return multisigscripthash;
    hasRequiredMultisigscripthash = 1;
    var _2 = lodashExports;
    var inherits2 = inherits_browserExports;
    var Input = requireInput$1();
    var Output = requireOutput();
    var $2 = preconditions;
    var Address2 = requireAddress();
    var Script = requireScript();
    var Signature2 = signature$2;
    var Sighash = requireSighash();
    var SighashWitness = requireSighashwitness();
    var BufferWriter2 = bufferwriter;
    var BufferUtil2 = bufferExports;
    var TransactionSignature = requireSignature();
    function MultiSigScriptHashInput(input2, pubkeys, threshold, signatures, opts) {
      opts = opts || {};
      Input.apply(this, arguments);
      var self2 = this;
      pubkeys = pubkeys || input2.publicKeys;
      threshold = threshold || input2.threshold;
      signatures = signatures || input2.signatures;
      if (opts.noSorting) {
        this.publicKeys = pubkeys;
      } else {
        this.publicKeys = _2.sortBy(pubkeys, function(publicKey) {
          return publicKey.toString("hex");
        });
      }
      this.redeemScript = Script.buildMultisigOut(this.publicKeys, threshold, opts);
      var nested = Script.buildWitnessMultisigOutFromScript(this.redeemScript);
      if (nested.equals(this.output.script)) {
        this.nestedWitness = false;
        this.type = Address2.PayToWitnessScriptHash;
      } else if (Script.buildScriptHashOut(nested).equals(this.output.script)) {
        this.nestedWitness = true;
        this.type = Address2.PayToScriptHash;
      } else if (Script.buildScriptHashOut(this.redeemScript).equals(this.output.script)) {
        this.nestedWitness = false;
        this.type = Address2.PayToScriptHash;
      } else {
        throw new Error("Provided public keys don't hash to the provided output");
      }
      if (this.nestedWitness) {
        var scriptSig = new Script();
        scriptSig.add(nested.toBuffer());
        this.setScript(scriptSig);
      }
      this.publicKeyIndex = {};
      _2.each(this.publicKeys, function(publicKey, index) {
        self2.publicKeyIndex[publicKey.toString()] = index;
      });
      this.threshold = threshold;
      this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);
    }
    inherits2(MultiSigScriptHashInput, Input);
    MultiSigScriptHashInput.prototype.toObject = function() {
      var obj = Input.prototype.toObject.apply(this, arguments);
      obj.threshold = this.threshold;
      obj.publicKeys = _2.map(this.publicKeys, function(publicKey) {
        return publicKey.toString();
      });
      obj.signatures = this._serializeSignatures();
      return obj;
    };
    MultiSigScriptHashInput.prototype._deserializeSignatures = function(signatures) {
      return _2.map(signatures, function(signature2) {
        if (!signature2) {
          return void 0;
        }
        return new TransactionSignature(signature2);
      });
    };
    MultiSigScriptHashInput.prototype._serializeSignatures = function() {
      return _2.map(this.signatures, function(signature2) {
        if (!signature2) {
          return void 0;
        }
        return signature2.toObject();
      });
    };
    MultiSigScriptHashInput.prototype.getScriptCode = function() {
      var writer = new BufferWriter2();
      if (!this.redeemScript.hasCodeseparators()) {
        var redeemScriptBuffer = this.redeemScript.toBuffer();
        writer.writeVarintNum(redeemScriptBuffer.length);
        writer.write(redeemScriptBuffer);
      } else {
        throw new Error("@TODO");
      }
      return writer.toBuffer();
    };
    MultiSigScriptHashInput.prototype.getSighash = function(transaction2, privateKey, index, sigtype) {
      var self2 = this;
      var hash2;
      if (self2.nestedWitness || self2.type === Address2.PayToWitnessScriptHash) {
        var scriptCode = self2.getScriptCode();
        var satoshisBuffer = self2.getSatoshisBuffer();
        hash2 = SighashWitness.sighash(transaction2, sigtype, index, scriptCode, satoshisBuffer);
      } else {
        hash2 = Sighash.sighash(transaction2, sigtype, index, self2.redeemScript);
      }
      return hash2;
    };
    MultiSigScriptHashInput.prototype.getSignatures = function(transaction2, privateKey, index, sigtype, hashData, signingMethod) {
      $2.checkState(this.output instanceof Output);
      sigtype = sigtype || Signature2.SIGHASH_ALL;
      signingMethod = signingMethod || "ecdsa";
      var self2 = this;
      var results = [];
      _2.each(this.publicKeys, function(publicKey) {
        if (publicKey.toString() === privateKey.publicKey.toString()) {
          var signature2;
          if (self2.nestedWitness || self2.type === Address2.PayToWitnessScriptHash) {
            var scriptCode = self2.getScriptCode();
            var satoshisBuffer = self2.getSatoshisBuffer();
            signature2 = SighashWitness.sign(transaction2, privateKey, sigtype, index, scriptCode, satoshisBuffer, signingMethod);
          } else {
            signature2 = Sighash.sign(transaction2, privateKey, sigtype, index, self2.redeemScript, signingMethod);
          }
          results.push(new TransactionSignature({
            publicKey: privateKey.publicKey,
            prevTxId: self2.prevTxId,
            outputIndex: self2.outputIndex,
            inputIndex: index,
            signature: signature2,
            sigtype
          }));
        }
      });
      return results;
    };
    MultiSigScriptHashInput.prototype.addSignature = function(transaction2, signature2, signingMethod) {
      $2.checkState(!this.isFullySigned(), "All needed signatures have already been added");
      $2.checkArgument(
        !_2.isUndefined(this.publicKeyIndex[signature2.publicKey.toString()]),
        "Signature has no matching public key"
      );
      $2.checkState(this.isValidSignature(transaction2, signature2, signingMethod), "Invalid Signature!");
      this.signatures[this.publicKeyIndex[signature2.publicKey.toString()]] = signature2;
      this._updateScript();
      return this;
    };
    MultiSigScriptHashInput.prototype._updateScript = function() {
      if (this.nestedWitness || this.type === Address2.PayToWitnessScriptHash) {
        var stack = [
          buffer$2.Buffer.alloc(0)
        ];
        var signatures = this._createSignatures();
        for (var i2 = 0; i2 < signatures.length; i2++) {
          stack.push(signatures[i2]);
        }
        stack.push(this.redeemScript.toBuffer());
        this.setWitnesses(stack);
      } else {
        var scriptSig = Script.buildP2SHMultisigIn(
          this.publicKeys,
          this.threshold,
          this._createSignatures(),
          { cachedMultisig: this.redeemScript }
        );
        this.setScript(scriptSig);
      }
      return this;
    };
    MultiSigScriptHashInput.prototype._createSignatures = function() {
      return _2.map(
        _2.filter(this.signatures, function(signature2) {
          return !_2.isUndefined(signature2);
        }),
        function(signature2) {
          return BufferUtil2.concat([
            signature2.signature.toDER(),
            BufferUtil2.integerAsSingleByteBuffer(signature2.sigtype)
          ]);
        }
      );
    };
    MultiSigScriptHashInput.prototype.clearSignatures = function() {
      this.signatures = new Array(this.publicKeys.length);
      this._updateScript();
    };
    MultiSigScriptHashInput.prototype.isFullySigned = function() {
      return this.countSignatures() === this.threshold;
    };
    MultiSigScriptHashInput.prototype.countMissingSignatures = function() {
      return this.threshold - this.countSignatures();
    };
    MultiSigScriptHashInput.prototype.countSignatures = function() {
      return _2.reduce(this.signatures, function(sum, signature2) {
        return sum + !!signature2;
      }, 0);
    };
    MultiSigScriptHashInput.prototype.publicKeysWithoutSignature = function() {
      var self2 = this;
      return _2.filter(this.publicKeys, function(publicKey) {
        return !self2.signatures[self2.publicKeyIndex[publicKey.toString()]];
      });
    };
    MultiSigScriptHashInput.prototype.isValidSignature = function(transaction2, signature2, signingMethod) {
      signingMethod = signingMethod || "ecdsa";
      if (this.nestedWitness || this.type === Address2.PayToWitnessScriptHash) {
        signature2.signature.nhashtype = signature2.sigtype;
        var scriptCode = this.getScriptCode();
        var satoshisBuffer = this.getSatoshisBuffer();
        return SighashWitness.verify(
          transaction2,
          signature2.signature,
          signature2.publicKey,
          signature2.inputIndex,
          scriptCode,
          satoshisBuffer,
          signingMethod
        );
      } else {
        signature2.signature.nhashtype = signature2.sigtype;
        return Sighash.verify(
          transaction2,
          signature2.signature,
          signature2.publicKey,
          signature2.inputIndex,
          this.redeemScript,
          signingMethod
        );
      }
    };
    MultiSigScriptHashInput.OPCODES_SIZE = 7;
    MultiSigScriptHashInput.SIGNATURE_SIZE = 74;
    MultiSigScriptHashInput.PUBKEY_SIZE = 34;
    MultiSigScriptHashInput.REDEEM_SCRIPT_SIZE = 34;
    MultiSigScriptHashInput.prototype._estimateSize = function() {
      var WITNESS_DISCOUNT = 4;
      var witnessSize = MultiSigScriptHashInput.OPCODES_SIZE + this.threshold * MultiSigScriptHashInput.SIGNATURE_SIZE + this.publicKeys.length * MultiSigScriptHashInput.PUBKEY_SIZE;
      if (this.type === Address2.PayToWitnessScriptHash) {
        return witnessSize / WITNESS_DISCOUNT;
      } else if (this.nestedWitness) {
        return witnessSize / WITNESS_DISCOUNT + MultiSigScriptHashInput.REDEEM_SCRIPT_SIZE;
      } else {
        return witnessSize;
      }
    };
    multisigscripthash = MultiSigScriptHashInput;
    return multisigscripthash;
  }
  var hasRequiredInput;
  function requireInput() {
    if (hasRequiredInput)
      return input$1.exports;
    hasRequiredInput = 1;
    input$1.exports = requireInput$1();
    input$1.exports.PublicKey = requirePublickey$1();
    input$1.exports.PublicKeyHash = requirePublickeyhash();
    input$1.exports.MultiSig = requireMultisig();
    input$1.exports.MultiSigScriptHash = requireMultisigscripthash();
    return input$1.exports;
  }
  var sighash_1;
  var hasRequiredSighash;
  function requireSighash() {
    if (hasRequiredSighash)
      return sighash_1;
    hasRequiredSighash = 1;
    var Signature2 = signature$2;
    var Script = requireScript();
    var Output = requireOutput();
    var BufferReader2 = bufferreader;
    var BufferWriter2 = bufferwriter;
    var BN2 = bn$2;
    var Hash2 = hashExports;
    var ECDSA2 = requireEcdsa();
    var $2 = preconditions;
    var _2 = lodashExports;
    const schnorr2 = src;
    var SIGHASH_SINGLE_BUG = "0000000000000000000000000000000000000000000000000000000000000001";
    var BITS_64_ON = "ffffffffffffffff";
    var sighash = function sighash2(transaction2, sighashType, inputNumber, subscript) {
      var Transaction2 = requireTransaction$1();
      var Input = requireInput();
      var i2;
      var txcopy = Transaction2.shallowCopy(transaction2);
      subscript = new Script(subscript);
      subscript.removeCodeseparators();
      for (i2 = 0; i2 < txcopy.inputs.length; i2++) {
        txcopy.inputs[i2] = new Input(txcopy.inputs[i2]).setScript(Script.empty());
      }
      txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);
      if ((sighashType & 31) === Signature2.SIGHASH_NONE || (sighashType & 31) === Signature2.SIGHASH_SINGLE) {
        for (i2 = 0; i2 < txcopy.inputs.length; i2++) {
          if (i2 !== inputNumber) {
            txcopy.inputs[i2].sequenceNumber = 0;
          }
        }
      }
      if ((sighashType & 31) === Signature2.SIGHASH_NONE) {
        txcopy.outputs = [];
      } else if ((sighashType & 31) === Signature2.SIGHASH_SINGLE) {
        if (inputNumber >= txcopy.outputs.length) {
          return buffer$2.Buffer.from(SIGHASH_SINGLE_BUG, "hex");
        }
        txcopy.outputs.length = inputNumber + 1;
        for (i2 = 0; i2 < inputNumber; i2++) {
          txcopy.outputs[i2] = new Output({
            satoshis: BN2.fromBuffer(buffer$2.Buffer.from(BITS_64_ON, "hex")),
            script: Script.empty()
          });
        }
      }
      if (sighashType & Signature2.SIGHASH_ANYONECANPAY) {
        txcopy.inputs = [txcopy.inputs[inputNumber]];
      }
      var buf = new BufferWriter2().write(txcopy.toBuffer()).writeInt32LE(sighashType).toBuffer();
      var ret = Hash2.sha256sha256(buf);
      ret = new BufferReader2(ret).readReverse();
      return ret;
    };
    function sign2(transaction2, privateKey, sighashType, inputIndex, subscript, signingMethod) {
      signingMethod = signingMethod || "ecdsa";
      let hashbuf = sighash(transaction2, sighashType, inputIndex, subscript);
      let sig;
      switch (signingMethod) {
        case "ecdsa":
          sig = ECDSA2.sign(hashbuf, privateKey, "little").set({ nhashtype: sighashType });
          break;
        case "schnorr":
          sig = schnorr2.sign(privateKey.toString(), hashbuf);
          break;
        default:
          throw new Error("signingMethod not supported ", signingMethod);
      }
      return sig;
    }
    function verify2(transaction2, signature2, publicKey, inputIndex, subscript, signingMethod) {
      $2.checkArgument(!_2.isUndefined(transaction2), "Transaction Undefined");
      $2.checkArgument(!_2.isUndefined(signature2) && !_2.isUndefined(signature2.nhashtype), "Signature Undefined");
      signingMethod = signingMethod || "ecdsa";
      let hashbuf = sighash(transaction2, signature2.nhashtype, inputIndex, subscript);
      let verified = false;
      switch (signingMethod) {
        case "ecdsa":
          verified = ECDSA2.verify(hashbuf, signature2, publicKey, "little");
          break;
        case "schnorr":
          verified = schnorr2.verify(publicKey, hashbuf, signature2);
          break;
        default:
          throw new Error("signingMethod not supported ", signingMethod);
      }
      return verified;
    }
    sighash_1 = {
      sighash,
      sign: sign2,
      verify: verify2
    };
    return sighash_1;
  }
  var _$5 = lodashExports;
  var errors$2 = errorsExports;
  var $$4 = preconditions;
  var UNITS = {
    "BTC": [1e8, 8],
    "mBTC": [1e5, 5],
    "uBTC": [100, 2],
    "bits": [100, 2],
    "satoshis": [1, 0]
  };
  function Unit$1(amount, code2) {
    if (!(this instanceof Unit$1)) {
      return new Unit$1(amount, code2);
    }
    if (_$5.isNumber(code2)) {
      if (code2 <= 0) {
        throw new errors$2.Unit.InvalidRate(code2);
      }
      amount = amount / code2;
      code2 = Unit$1.BTC;
    }
    this._value = this._from(amount, code2);
    var self2 = this;
    var defineAccesor = function(key2) {
      Object.defineProperty(self2, key2, {
        get: function() {
          return self2.to(key2);
        },
        enumerable: true
      });
    };
    Object.keys(UNITS).forEach(defineAccesor);
  }
  Object.keys(UNITS).forEach(function(key2) {
    Unit$1[key2] = key2;
  });
  Unit$1.fromObject = function fromObject(data2) {
    $$4.checkArgument(_$5.isObject(data2), "Argument is expected to be an object");
    return new Unit$1(data2.amount, data2.code);
  };
  Unit$1.fromBTC = function(amount) {
    return new Unit$1(amount, Unit$1.BTC);
  };
  Unit$1.fromMillis = Unit$1.fromMilis = function(amount) {
    return new Unit$1(amount, Unit$1.mBTC);
  };
  Unit$1.fromMicros = Unit$1.fromBits = function(amount) {
    return new Unit$1(amount, Unit$1.bits);
  };
  Unit$1.fromSatoshis = function(amount) {
    return new Unit$1(amount, Unit$1.satoshis);
  };
  Unit$1.fromFiat = function(amount, rate) {
    return new Unit$1(amount, rate);
  };
  Unit$1.prototype._from = function(amount, code2) {
    if (!UNITS[code2]) {
      throw new errors$2.Unit.UnknownCode(code2);
    }
    return parseInt((amount * UNITS[code2][0]).toFixed());
  };
  Unit$1.prototype.to = function(code2) {
    if (_$5.isNumber(code2)) {
      if (code2 <= 0) {
        throw new errors$2.Unit.InvalidRate(code2);
      }
      return parseFloat((this.BTC * code2).toFixed(2));
    }
    if (!UNITS[code2]) {
      throw new errors$2.Unit.UnknownCode(code2);
    }
    var value = this._value / UNITS[code2][0];
    return parseFloat(value.toFixed(UNITS[code2][1]));
  };
  Unit$1.prototype.toBTC = function() {
    return this.to(Unit$1.BTC);
  };
  Unit$1.prototype.toMillis = Unit$1.prototype.toMilis = function() {
    return this.to(Unit$1.mBTC);
  };
  Unit$1.prototype.toMicros = Unit$1.prototype.toBits = function() {
    return this.to(Unit$1.bits);
  };
  Unit$1.prototype.toSatoshis = function() {
    return this.to(Unit$1.satoshis);
  };
  Unit$1.prototype.atRate = function(rate) {
    return this.to(rate);
  };
  Unit$1.prototype.toString = function() {
    return this.satoshis + " satoshis";
  };
  Unit$1.prototype.toObject = Unit$1.prototype.toJSON = function toObject2() {
    return {
      amount: this.BTC,
      code: Unit$1.BTC
    };
  };
  Unit$1.prototype.inspect = function() {
    return "<Unit: " + this.toString() + ">";
  };
  var unit = Unit$1;
  var unspentoutput;
  var hasRequiredUnspentoutput;
  function requireUnspentoutput() {
    if (hasRequiredUnspentoutput)
      return unspentoutput;
    hasRequiredUnspentoutput = 1;
    var _2 = lodashExports;
    var $2 = preconditions;
    var JSUtil2 = js$1;
    var Script = requireScript();
    var Address2 = requireAddress();
    var Unit2 = unit;
    function UnspentOutput(data2) {
      if (!(this instanceof UnspentOutput)) {
        return new UnspentOutput(data2);
      }
      $2.checkArgument(_2.isObject(data2), "Must provide an object from where to extract data");
      var address2 = data2.address ? new Address2(data2.address) : void 0;
      var txId = data2.txid ? data2.txid : data2.txId;
      if (!txId || !JSUtil2.isHexaString(txId) || txId.length > 64) {
        throw new Error("Invalid TXID in object", data2);
      }
      var outputIndex = _2.isUndefined(data2.vout) ? data2.outputIndex : data2.vout;
      if (!_2.isNumber(outputIndex)) {
        throw new Error("Invalid outputIndex, received " + outputIndex);
      }
      $2.checkArgument(
        !_2.isUndefined(data2.scriptPubKey) || !_2.isUndefined(data2.script),
        "Must provide the scriptPubKey for that output!"
      );
      var script2 = new Script(data2.scriptPubKey || data2.script);
      $2.checkArgument(
        !_2.isUndefined(data2.amount) || !_2.isUndefined(data2.satoshis),
        "Must provide an amount for the output"
      );
      var amount = !_2.isUndefined(data2.amount) ? new Unit2.fromBTC(data2.amount).toSatoshis() : data2.satoshis;
      $2.checkArgument(_2.isNumber(amount), "Amount must be a number");
      JSUtil2.defineImmutable(this, {
        address: address2,
        txId,
        outputIndex,
        script: script2,
        satoshis: amount
      });
    }
    UnspentOutput.prototype.inspect = function() {
      return "<UnspentOutput: " + this.txId + ":" + this.outputIndex + ", satoshis: " + this.satoshis + ", address: " + this.address + ">";
    };
    UnspentOutput.prototype.toString = function() {
      return this.txId + ":" + this.outputIndex;
    };
    UnspentOutput.fromObject = function(data2) {
      return new UnspentOutput(data2);
    };
    UnspentOutput.prototype.toObject = UnspentOutput.prototype.toJSON = function toObject2() {
      return {
        address: this.address ? this.address.toString() : void 0,
        txid: this.txId,
        vout: this.outputIndex,
        scriptPubKey: this.script.toBuffer().toString("hex"),
        amount: Unit2.fromSatoshis(this.satoshis).toBTC()
      };
    };
    unspentoutput = UnspentOutput;
    return unspentoutput;
  }
  var transaction;
  var hasRequiredTransaction$1;
  function requireTransaction$1() {
    if (hasRequiredTransaction$1)
      return transaction;
    hasRequiredTransaction$1 = 1;
    var _2 = lodashExports;
    var $2 = preconditions;
    var buffer2 = buffer$2;
    var compare = buffer$2.Buffer.compare || requireBufferCompare();
    var errors2 = errorsExports;
    var BufferUtil2 = bufferExports;
    var JSUtil2 = js$1;
    var BufferReader2 = bufferreader;
    var BufferWriter2 = bufferwriter;
    var Hash2 = hashExports;
    var Signature2 = signature$2;
    var Sighash = requireSighash();
    var SighashWitness = requireSighashwitness();
    var Address2 = requireAddress();
    var UnspentOutput = requireUnspentoutput();
    var Input = requireInput();
    var PublicKeyHashInput = Input.PublicKeyHash;
    var PublicKeyInput = Input.PublicKey;
    var MultiSigScriptHashInput = Input.MultiSigScriptHash;
    var MultiSigInput = Input.MultiSig;
    var Output = requireOutput();
    var Script = requireScript();
    var PrivateKey2 = requirePrivatekey();
    var BN2 = bn$2;
    function Transaction2(serialized, opts) {
      if (!(this instanceof Transaction2)) {
        return new Transaction2(serialized);
      }
      this.inputs = [];
      this.outputs = [];
      this._inputAmount = void 0;
      this._outputAmount = void 0;
      if (serialized) {
        if (serialized instanceof Transaction2) {
          return Transaction2.shallowCopy(serialized);
        } else if (JSUtil2.isHexa(serialized)) {
          this.fromString(serialized);
        } else if (BufferUtil2.isBuffer(serialized)) {
          this.fromBuffer(serialized);
        } else if (_2.isObject(serialized)) {
          this.fromObject(serialized, opts);
        } else {
          throw new errors2.InvalidArgument("Must provide an object or string to deserialize a transaction");
        }
      } else {
        this._newTransaction();
      }
    }
    var CURRENT_VERSION = 2;
    var DEFAULT_NLOCKTIME = 0;
    var MAX_BLOCK_SIZE = 1e6;
    Transaction2.DUST_AMOUNT = 546;
    Transaction2.FEE_SECURITY_MARGIN = 150;
    Transaction2.MAX_MONEY = 21e6 * 1e8;
    Transaction2.NLOCKTIME_BLOCKHEIGHT_LIMIT = 5e8;
    Transaction2.NLOCKTIME_MAX_VALUE = 4294967295;
    Transaction2.FEE_PER_KB = 1e5;
    Transaction2.CHANGE_OUTPUT_MAX_SIZE = 20 + 4 + 34 + 4;
    Transaction2.MAXIMUM_EXTRA_SIZE = 4 + 9 + 9 + 4;
    Transaction2.shallowCopy = function(transaction2) {
      var copy = new Transaction2(transaction2.toBuffer());
      return copy;
    };
    var hashProperty = {
      configurable: false,
      enumerable: true,
      get: function() {
        this._hash = new BufferReader2(this._getHash()).readReverse().toString("hex");
        return this._hash;
      }
    };
    var witnessHashProperty = {
      configurable: false,
      enumerable: true,
      get: function() {
        return new BufferReader2(this._getWitnessHash()).readReverse().toString("hex");
      }
    };
    Object.defineProperty(Transaction2.prototype, "witnessHash", witnessHashProperty);
    Object.defineProperty(Transaction2.prototype, "hash", hashProperty);
    Object.defineProperty(Transaction2.prototype, "id", hashProperty);
    var ioProperty = {
      configurable: false,
      enumerable: true,
      get: function() {
        return this._getInputAmount();
      }
    };
    Object.defineProperty(Transaction2.prototype, "inputAmount", ioProperty);
    ioProperty.get = function() {
      return this._getOutputAmount();
    };
    Object.defineProperty(Transaction2.prototype, "outputAmount", ioProperty);
    Transaction2.prototype._getHash = function() {
      return Hash2.sha256sha256(this.toBuffer(true));
    };
    Transaction2.prototype._getWitnessHash = function() {
      return Hash2.sha256sha256(this.toBuffer(false));
    };
    Transaction2.prototype.serialize = function(unsafe) {
      if (true === unsafe || unsafe && unsafe.disableAll) {
        return this.uncheckedSerialize();
      } else {
        return this.checkedSerialize(unsafe);
      }
    };
    Transaction2.prototype.uncheckedSerialize = Transaction2.prototype.toString = function() {
      return this.toBuffer().toString("hex");
    };
    Transaction2.prototype.checkedSerialize = function(opts) {
      var serializationError = this.getSerializationError(opts);
      if (serializationError) {
        serializationError.message += " - For more information please see: https://github.com/bitpay/bitcore/blob/master/packages/bitcore-lib/docs/transaction.md#serialization-checks";
        throw serializationError;
      }
      return this.uncheckedSerialize();
    };
    Transaction2.prototype.invalidSatoshis = function() {
      var invalid = false;
      for (var i2 = 0; i2 < this.outputs.length; i2++) {
        if (this.outputs[i2].invalidSatoshis()) {
          invalid = true;
        }
      }
      return invalid;
    };
    Transaction2.prototype.getSerializationError = function(opts) {
      opts = opts || {};
      if (this.invalidSatoshis()) {
        return new errors2.Transaction.InvalidSatoshis();
      }
      var unspent = this._getUnspentValue();
      var unspentError;
      if (unspent < 0) {
        if (!opts.disableMoreOutputThanInput) {
          unspentError = new errors2.Transaction.InvalidOutputAmountSum();
        }
      } else {
        unspentError = this._hasFeeError(opts, unspent);
      }
      return unspentError || this._hasDustOutputs(opts) || this._isMissingSignatures(opts);
    };
    Transaction2.prototype._hasFeeError = function(opts, unspent) {
      if (!_2.isUndefined(this._fee) && this._fee !== unspent) {
        return new errors2.Transaction.FeeError.Different(
          "Unspent value is " + unspent + " but specified fee is " + this._fee
        );
      }
      if (!opts.disableLargeFees) {
        var maximumFee = Math.floor(Transaction2.FEE_SECURITY_MARGIN * this._estimateFee());
        if (unspent > maximumFee) {
          if (this._missingChange()) {
            return new errors2.Transaction.ChangeAddressMissing(
              "Fee is too large and no change address was provided"
            );
          }
          return new errors2.Transaction.FeeError.TooLarge(
            "expected less than " + maximumFee + " but got " + unspent
          );
        }
      }
      if (!opts.disableSmallFees) {
        var minimumFee = Math.ceil(this._estimateFee() / Transaction2.FEE_SECURITY_MARGIN);
        if (unspent < minimumFee) {
          return new errors2.Transaction.FeeError.TooSmall(
            "expected more than " + minimumFee + " but got " + unspent
          );
        }
      }
    };
    Transaction2.prototype._missingChange = function() {
      return !this._changeScript;
    };
    Transaction2.prototype._hasDustOutputs = function(opts) {
      if (opts.disableDustOutputs) {
        return;
      }
      var index, output2;
      for (index in this.outputs) {
        output2 = this.outputs[index];
        if (output2.satoshis < Transaction2.DUST_AMOUNT && !output2.script.isDataOut()) {
          return new errors2.Transaction.DustOutputs();
        }
      }
    };
    Transaction2.prototype._isMissingSignatures = function(opts) {
      if (opts.disableIsFullySigned) {
        return;
      }
      if (!this.isFullySigned()) {
        return new errors2.Transaction.MissingSignatures();
      }
    };
    Transaction2.prototype.inspect = function() {
      return "<Transaction: " + this.uncheckedSerialize() + ">";
    };
    Transaction2.prototype.toBuffer = function(noWitness) {
      var writer = new BufferWriter2();
      return this.toBufferWriter(writer, noWitness).toBuffer();
    };
    Transaction2.prototype.hasWitnesses = function() {
      for (var i2 = 0; i2 < this.inputs.length; i2++) {
        if (this.inputs[i2].hasWitnesses()) {
          return true;
        }
      }
      return false;
    };
    Transaction2.prototype.toBufferWriter = function(writer, noWitness) {
      writer.writeInt32LE(this.version);
      var hasWitnesses = this.hasWitnesses();
      if (hasWitnesses && !noWitness) {
        writer.write(buffer$2.Buffer.from("0001", "hex"));
      }
      writer.writeVarintNum(this.inputs.length);
      _2.each(this.inputs, function(input2) {
        input2.toBufferWriter(writer);
      });
      writer.writeVarintNum(this.outputs.length);
      _2.each(this.outputs, function(output2) {
        output2.toBufferWriter(writer);
      });
      if (hasWitnesses && !noWitness) {
        _2.each(this.inputs, function(input2) {
          var witnesses = input2.getWitnesses();
          writer.writeVarintNum(witnesses.length);
          for (var j = 0; j < witnesses.length; j++) {
            writer.writeVarintNum(witnesses[j].length);
            writer.write(witnesses[j]);
          }
        });
      }
      writer.writeUInt32LE(this.nLockTime);
      return writer;
    };
    Transaction2.prototype.fromBuffer = function(buffer3) {
      var reader = new BufferReader2(buffer3);
      return this.fromBufferReader(reader);
    };
    Transaction2.prototype.fromBufferReader = function(reader) {
      $2.checkArgument(!reader.finished(), "No transaction data received");
      this.version = reader.readInt32LE();
      var sizeTxIns = reader.readVarintNum();
      var hasWitnesses = false;
      if (sizeTxIns === 0 && reader.buf[reader.pos] !== 0) {
        reader.pos += 1;
        hasWitnesses = true;
        sizeTxIns = reader.readVarintNum();
      }
      for (var i2 = 0; i2 < sizeTxIns; i2++) {
        var input2 = Input.fromBufferReader(reader);
        this.inputs.push(input2);
      }
      var sizeTxOuts = reader.readVarintNum();
      for (var j = 0; j < sizeTxOuts; j++) {
        this.outputs.push(Output.fromBufferReader(reader));
      }
      if (hasWitnesses) {
        for (var k2 = 0; k2 < sizeTxIns; k2++) {
          var itemCount = reader.readVarintNum();
          var witnesses = [];
          for (var l = 0; l < itemCount; l++) {
            var size = reader.readVarintNum();
            var item = reader.read(size);
            witnesses.push(item);
          }
          this.inputs[k2].setWitnesses(witnesses);
        }
      }
      this.nLockTime = reader.readUInt32LE();
      return this;
    };
    Transaction2.prototype.toObject = Transaction2.prototype.toJSON = function toObject2() {
      var inputs = [];
      this.inputs.forEach(function(input2) {
        inputs.push(input2.toObject());
      });
      var outputs = [];
      this.outputs.forEach(function(output2) {
        outputs.push(output2.toObject());
      });
      var obj = {
        hash: this.hash,
        version: this.version,
        inputs,
        outputs,
        nLockTime: this.nLockTime
      };
      if (this._changeScript) {
        obj.changeScript = this._changeScript.toString();
      }
      if (!_2.isUndefined(this._changeIndex)) {
        obj.changeIndex = this._changeIndex;
      }
      if (!_2.isUndefined(this._fee)) {
        obj.fee = this._fee;
      }
      return obj;
    };
    Transaction2.prototype.fromObject = function fromObject(arg, opts) {
      $2.checkArgument(_2.isObject(arg) || arg instanceof Transaction2);
      var self2 = this;
      var transaction2;
      if (arg instanceof Transaction2) {
        transaction2 = transaction2.toObject();
      } else {
        transaction2 = arg;
      }
      _2.each(transaction2.inputs, function(input2) {
        if (!input2.output || !input2.output.script) {
          self2.uncheckedAddInput(new Input(input2));
          return;
        }
        var script2 = new Script(input2.output.script);
        var txin;
        if ((script2.isScriptHashOut() || script2.isWitnessScriptHashOut()) && input2.publicKeys && input2.threshold) {
          txin = new Input.MultiSigScriptHash(
            input2,
            input2.publicKeys,
            input2.threshold,
            input2.signatures,
            opts
          );
        } else if (script2.isPublicKeyHashOut() || script2.isWitnessPublicKeyHashOut() || script2.isScriptHashOut()) {
          txin = new Input.PublicKeyHash(input2);
        } else if (script2.isPublicKeyOut()) {
          txin = new Input.PublicKey(input2);
        } else {
          throw new errors2.Transaction.Input.UnsupportedScript(input2.output.script);
        }
        self2.addInput(txin);
      });
      _2.each(transaction2.outputs, function(output2) {
        self2.addOutput(new Output(output2));
      });
      if (transaction2.changeIndex) {
        this._changeIndex = transaction2.changeIndex;
      }
      if (transaction2.changeScript) {
        this._changeScript = new Script(transaction2.changeScript);
      }
      if (transaction2.fee) {
        this._fee = transaction2.fee;
      }
      this.nLockTime = transaction2.nLockTime;
      this.version = transaction2.version;
      this._checkConsistency(arg);
      return this;
    };
    Transaction2.prototype._checkConsistency = function(arg) {
      if (!_2.isUndefined(this._changeIndex)) {
        $2.checkState(this._changeScript, "Change script is expected.");
        $2.checkState(this.outputs[this._changeIndex], "Change index points to undefined output.");
        $2.checkState(this.outputs[this._changeIndex].script.toString() === this._changeScript.toString(), "Change output has an unexpected script.");
      }
      if (arg && arg.hash) {
        $2.checkState(arg.hash === this.hash, "Hash in object does not match transaction hash.");
      }
    };
    Transaction2.prototype.lockUntilDate = function(time) {
      $2.checkArgument(time);
      if (_2.isNumber(time) && time < Transaction2.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
        throw new errors2.Transaction.LockTimeTooEarly();
      }
      if (_2.isDate(time)) {
        time = time.getTime() / 1e3;
      }
      for (var i2 = 0; i2 < this.inputs.length; i2++) {
        if (this.inputs[i2].sequenceNumber === Input.DEFAULT_SEQNUMBER) {
          this.inputs[i2].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;
        }
      }
      this.nLockTime = time;
      return this;
    };
    Transaction2.prototype.lockUntilBlockHeight = function(height) {
      $2.checkArgument(_2.isNumber(height));
      if (height >= Transaction2.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
        throw new errors2.Transaction.BlockHeightTooHigh();
      }
      if (height < 0) {
        throw new errors2.Transaction.NLockTimeOutOfRange();
      }
      for (var i2 = 0; i2 < this.inputs.length; i2++) {
        if (this.inputs[i2].sequenceNumber === Input.DEFAULT_SEQNUMBER) {
          this.inputs[i2].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;
        }
      }
      this.nLockTime = height;
      return this;
    };
    Transaction2.prototype.getLockTime = function() {
      if (!this.nLockTime) {
        return null;
      }
      if (this.nLockTime < Transaction2.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
        return this.nLockTime;
      }
      return new Date(1e3 * this.nLockTime);
    };
    Transaction2.prototype.fromString = function(string) {
      this.fromBuffer(buffer2.Buffer.from(string, "hex"));
    };
    Transaction2.prototype._newTransaction = function() {
      this.version = CURRENT_VERSION;
      this.nLockTime = DEFAULT_NLOCKTIME;
    };
    Transaction2.prototype.from = function(utxo, pubkeys, threshold, opts) {
      if (_2.isArray(utxo)) {
        var self2 = this;
        _2.each(utxo, function(utxo2) {
          self2.from(utxo2, pubkeys, threshold, opts);
        });
        return this;
      }
      var exists2 = _2.some(this.inputs, function(input2) {
        return input2.prevTxId.toString("hex") === utxo.txId && input2.outputIndex === utxo.outputIndex;
      });
      if (exists2) {
        return this;
      }
      if (pubkeys && threshold) {
        this._fromMultisigUtxo(utxo, pubkeys, threshold, opts);
      } else {
        this._fromNonP2SH(utxo);
      }
      return this;
    };
    Transaction2.prototype.associateInputs = function(utxos, pubkeys, threshold, opts) {
      let indexes = [];
      for (let utxo of utxos) {
        const index = this.inputs.findIndex((i2) => i2.prevTxId.toString("hex") === utxo.txId && i2.outputIndex === utxo.outputIndex);
        indexes.push(index);
        if (index >= 0) {
          const sequenceNumber = this.inputs[index].sequenceNumber;
          this.inputs[index] = this._getInputFrom(utxo, pubkeys, threshold, opts);
          this.inputs[index].sequenceNumber = sequenceNumber;
        }
      }
      return indexes;
    };
    Transaction2.prototype._selectInputType = function(utxo, pubkeys, threshold) {
      var clazz;
      utxo = new UnspentOutput(utxo);
      if (pubkeys && threshold) {
        if (utxo.script.isMultisigOut()) {
          clazz = MultiSigInput;
        } else if (utxo.script.isScriptHashOut() || utxo.script.isWitnessScriptHashOut()) {
          clazz = MultiSigScriptHashInput;
        }
      } else if (utxo.script.isPublicKeyHashOut() || utxo.script.isWitnessPublicKeyHashOut() || utxo.script.isScriptHashOut()) {
        clazz = PublicKeyHashInput;
      } else if (utxo.script.isPublicKeyOut()) {
        clazz = PublicKeyInput;
      } else {
        clazz = Input;
      }
      return clazz;
    };
    Transaction2.prototype._getInputFrom = function(utxo, pubkeys, threshold, opts) {
      utxo = new UnspentOutput(utxo);
      const InputClass = this._selectInputType(utxo, pubkeys, threshold);
      const input2 = {
        output: new Output({
          script: utxo.script,
          satoshis: utxo.satoshis
        }),
        prevTxId: utxo.txId,
        outputIndex: utxo.outputIndex,
        sequenceNumber: utxo.sequenceNumber,
        script: Script.empty()
      };
      let args = pubkeys && threshold ? [pubkeys, threshold, false, opts] : [];
      return new InputClass(input2, ...args);
    };
    Transaction2.prototype._fromNonP2SH = function(utxo) {
      const input2 = this._getInputFrom(utxo);
      this.addInput(input2);
    };
    Transaction2.prototype._fromMultisigUtxo = function(utxo, pubkeys, threshold, opts) {
      $2.checkArgument(
        threshold <= pubkeys.length,
        "Number of required signatures must be greater than the number of public keys"
      );
      const input2 = this._getInputFrom(utxo, pubkeys, threshold, opts);
      this.addInput(input2);
    };
    Transaction2.prototype.addInput = function(input2, outputScript, satoshis) {
      $2.checkArgumentType(input2, Input, "input");
      if (!input2.output && (_2.isUndefined(outputScript) || _2.isUndefined(satoshis))) {
        throw new errors2.Transaction.NeedMoreInfo("Need information about the UTXO script and satoshis");
      }
      if (!input2.output && outputScript && !_2.isUndefined(satoshis)) {
        outputScript = outputScript instanceof Script ? outputScript : new Script(outputScript);
        $2.checkArgumentType(satoshis, "number", "satoshis");
        input2.output = new Output({
          script: outputScript,
          satoshis
        });
      }
      return this.uncheckedAddInput(input2);
    };
    Transaction2.prototype.uncheckedAddInput = function(input2) {
      $2.checkArgumentType(input2, Input, "input");
      this.inputs.push(input2);
      this._inputAmount = void 0;
      this._updateChangeOutput();
      return this;
    };
    Transaction2.prototype.hasAllUtxoInfo = function() {
      return _2.every(this.inputs.map(function(input2) {
        return !!input2.output;
      }));
    };
    Transaction2.prototype.fee = function(amount) {
      $2.checkArgument(_2.isNumber(amount), "amount must be a number");
      this._fee = amount;
      this._updateChangeOutput();
      return this;
    };
    Transaction2.prototype.feePerKb = function(amount) {
      $2.checkArgument(_2.isNumber(amount), "amount must be a number");
      this._feePerKb = amount;
      this._updateChangeOutput();
      return this;
    };
    Transaction2.prototype.feePerByte = function(amount) {
      $2.checkArgument(_2.isNumber(amount), "amount must be a number");
      this._feePerByte = amount;
      this._updateChangeOutput();
      return this;
    };
    Transaction2.prototype.change = function(address2) {
      $2.checkArgument(address2, "address is required");
      this._changeScript = Script.fromAddress(address2);
      this._updateChangeOutput();
      return this;
    };
    Transaction2.prototype.getChangeOutput = function() {
      if (!_2.isUndefined(this._changeIndex)) {
        return this.outputs[this._changeIndex];
      }
      return null;
    };
    Transaction2.prototype.to = function(address2, amount) {
      if (_2.isArray(address2)) {
        var self2 = this;
        _2.each(address2, function(to) {
          self2.to(to.address, to.satoshis);
        });
        return this;
      }
      $2.checkArgument(
        JSUtil2.isNaturalNumber(amount),
        "Amount is expected to be a positive integer"
      );
      this.addOutput(new Output({
        script: Script(new Address2(address2)),
        satoshis: amount
      }));
      return this;
    };
    Transaction2.prototype.addData = function(value) {
      this.addOutput(new Output({
        script: Script.buildDataOut(value),
        satoshis: 0
      }));
      return this;
    };
    Transaction2.prototype.addOutput = function(output2) {
      $2.checkArgumentType(output2, Output, "output");
      this._addOutput(output2);
      this._updateChangeOutput();
      return this;
    };
    Transaction2.prototype.clearOutputs = function() {
      this.outputs = [];
      this._clearSignatures();
      this._outputAmount = void 0;
      this._changeIndex = void 0;
      this._updateChangeOutput();
      return this;
    };
    Transaction2.prototype._addOutput = function(output2) {
      this.outputs.push(output2);
      this._outputAmount = void 0;
    };
    Transaction2.prototype._getOutputAmount = function() {
      if (_2.isUndefined(this._outputAmount)) {
        var self2 = this;
        this._outputAmount = 0;
        _2.each(this.outputs, function(output2) {
          self2._outputAmount += output2.satoshis;
        });
      }
      return this._outputAmount;
    };
    Transaction2.prototype._getInputAmount = function() {
      if (_2.isUndefined(this._inputAmount)) {
        this._inputAmount = _2.sumBy(this.inputs, function(input2) {
          if (_2.isUndefined(input2.output)) {
            throw new errors2.Transaction.Input.MissingPreviousOutput();
          }
          return input2.output.satoshis;
        });
      }
      return this._inputAmount;
    };
    Transaction2.prototype._updateChangeOutput = function() {
      if (!this._changeScript) {
        return;
      }
      this._clearSignatures();
      if (!_2.isUndefined(this._changeIndex)) {
        this._removeOutput(this._changeIndex);
      }
      var available = this._getUnspentValue();
      var fee = this.getFee();
      var changeAmount = available - fee;
      if (changeAmount > Transaction2.DUST_AMOUNT) {
        this._changeIndex = this.outputs.length;
        this._addOutput(new Output({
          script: this._changeScript,
          satoshis: changeAmount
        }));
      } else {
        this._changeIndex = void 0;
      }
    };
    Transaction2.prototype.getFee = function() {
      if (this.isCoinbase()) {
        return 0;
      }
      if (!_2.isUndefined(this._fee)) {
        return this._fee;
      }
      if (!this._changeScript) {
        return this._getUnspentValue();
      }
      return this._estimateFee();
    };
    Transaction2.prototype._estimateFee = function() {
      var estimatedSize = this._estimateSize();
      var available = this._getUnspentValue();
      var feeRate = this._feePerByte || (this._feePerKb || Transaction2.FEE_PER_KB) / 1e3;
      function getFee(size) {
        return size * feeRate;
      }
      var fee = Math.ceil(getFee(estimatedSize));
      var feeWithChange = Math.ceil(getFee(estimatedSize) + getFee(Transaction2.CHANGE_OUTPUT_MAX_SIZE));
      if (!this._changeScript || available <= feeWithChange) {
        return fee;
      }
      return feeWithChange;
    };
    Transaction2.prototype._getUnspentValue = function() {
      return this._getInputAmount() - this._getOutputAmount();
    };
    Transaction2.prototype._clearSignatures = function() {
      _2.each(this.inputs, function(input2) {
        input2.clearSignatures();
      });
    };
    Transaction2.prototype._estimateSize = function() {
      var result = Transaction2.MAXIMUM_EXTRA_SIZE;
      _2.each(this.inputs, function(input2) {
        result += 32 + 4;
        result += input2._estimateSize();
      });
      _2.each(this.outputs, function(output2) {
        result += output2.script.toBuffer().length + 9;
      });
      return Math.ceil(result);
    };
    Transaction2.prototype._removeOutput = function(index) {
      var output2 = this.outputs[index];
      this.outputs = _2.without(this.outputs, output2);
      this._outputAmount = void 0;
    };
    Transaction2.prototype.removeOutput = function(index) {
      this._removeOutput(index);
      this._updateChangeOutput();
    };
    Transaction2.prototype.sort = function() {
      this.sortInputs(function(inputs) {
        var copy = Array.prototype.concat.apply([], inputs);
        let i2 = 0;
        copy.forEach((x) => {
          x.i = i2++;
        });
        copy.sort(function(first, second) {
          return compare(first.prevTxId, second.prevTxId) || first.outputIndex - second.outputIndex || first.i - second.i;
        });
        return copy;
      });
      this.sortOutputs(function(outputs) {
        var copy = Array.prototype.concat.apply([], outputs);
        let i2 = 0;
        copy.forEach((x) => {
          x.i = i2++;
        });
        copy.sort(function(first, second) {
          return first.satoshis - second.satoshis || compare(first.script.toBuffer(), second.script.toBuffer()) || first.i - second.i;
        });
        return copy;
      });
      return this;
    };
    Transaction2.prototype.shuffleOutputs = function() {
      return this.sortOutputs(_2.shuffle);
    };
    Transaction2.prototype.sortOutputs = function(sortingFunction) {
      var outs = sortingFunction(this.outputs);
      return this._newOutputOrder(outs);
    };
    Transaction2.prototype.sortInputs = function(sortingFunction) {
      this.inputs = sortingFunction(this.inputs);
      this._clearSignatures();
      return this;
    };
    Transaction2.prototype._newOutputOrder = function(newOutputs) {
      var isInvalidSorting = this.outputs.length !== newOutputs.length || _2.difference(this.outputs, newOutputs).length !== 0;
      if (isInvalidSorting) {
        throw new errors2.Transaction.InvalidSorting();
      }
      if (!_2.isUndefined(this._changeIndex)) {
        var changeOutput = this.outputs[this._changeIndex];
        this._changeIndex = _2.findIndex(newOutputs, changeOutput);
      }
      this.outputs = newOutputs;
      return this;
    };
    Transaction2.prototype.removeInput = function(txId, outputIndex) {
      var index;
      if (!outputIndex && _2.isNumber(txId)) {
        index = txId;
      } else {
        index = _2.findIndex(this.inputs, function(input3) {
          return input3.prevTxId.toString("hex") === txId && input3.outputIndex === outputIndex;
        });
      }
      if (index < 0 || index >= this.inputs.length) {
        throw new errors2.Transaction.InvalidIndex(index, this.inputs.length);
      }
      var input2 = this.inputs[index];
      this.inputs = _2.without(this.inputs, input2);
      this._inputAmount = void 0;
      this._updateChangeOutput();
    };
    Transaction2.prototype.sign = function(privateKey, sigtype, signingMethod) {
      $2.checkState(this.hasAllUtxoInfo(), "Not all utxo information is available to sign the transaction.");
      var self2 = this;
      if (_2.isArray(privateKey)) {
        _2.each(privateKey, function(privateKey2) {
          self2.sign(privateKey2, sigtype, signingMethod);
        });
        return this;
      }
      _2.each(this.getSignatures(privateKey, sigtype, signingMethod), function(signature2) {
        self2.applySignature(signature2, signingMethod);
      });
      return this;
    };
    Transaction2.prototype.getSignatures = function(privKey, sigtype, signingMethod) {
      privKey = new PrivateKey2(privKey);
      sigtype = sigtype || Signature2.SIGHASH_ALL;
      var transaction2 = this;
      var results = [];
      var hashData = Hash2.sha256ripemd160(privKey.publicKey.toBuffer());
      _2.each(this.inputs, function forEachInput(input2, index) {
        _2.each(input2.getSignatures(transaction2, privKey, index, sigtype, hashData, signingMethod), function(signature2) {
          results.push(signature2);
        });
      });
      return results;
    };
    Transaction2.prototype.applySignature = function(signature2, signingMethod) {
      this.inputs[signature2.inputIndex].addSignature(this, signature2, signingMethod);
      return this;
    };
    Transaction2.prototype.isFullySigned = function() {
      _2.each(this.inputs, function(input2) {
        if (input2.isFullySigned === Input.prototype.isFullySigned) {
          throw new errors2.Transaction.UnableToVerifySignature(
            "Unrecognized script kind, or not enough information to execute script.This usually happens when creating a transaction from a serialized transaction"
          );
        }
      });
      return _2.every(_2.map(this.inputs, function(input2) {
        return input2.isFullySigned();
      }));
    };
    Transaction2.prototype.isValidSignature = function(signature2, signingMethod) {
      var self2 = this;
      if (this.inputs[signature2.inputIndex].isValidSignature === Input.prototype.isValidSignature) {
        throw new errors2.Transaction.UnableToVerifySignature(
          "Unrecognized script kind, or not enough information to execute script.This usually happens when creating a transaction from a serialized transaction"
        );
      }
      return this.inputs[signature2.inputIndex].isValidSignature(self2, signature2, signingMethod);
    };
    Transaction2.prototype.verifySignature = function(sig, pubkey, nin, subscript, sigversion, satoshis, signingMethod) {
      if (_2.isUndefined(sigversion)) {
        sigversion = 0;
      }
      if (sigversion === 1) {
        var subscriptBuffer = subscript.toBuffer();
        var scriptCodeWriter = new BufferWriter2();
        scriptCodeWriter.writeVarintNum(subscriptBuffer.length);
        scriptCodeWriter.write(subscriptBuffer);
        var satoshisBuffer;
        if (satoshis) {
          $2.checkState(JSUtil2.isNaturalNumber(satoshis));
          satoshisBuffer = new BufferWriter2().writeUInt64LEBN(new BN2(satoshis)).toBuffer();
        } else {
          satoshisBuffer = this.inputs[nin].getSatoshisBuffer();
        }
        var verified = SighashWitness.verify(
          this,
          sig,
          pubkey,
          nin,
          scriptCodeWriter.toBuffer(),
          satoshisBuffer,
          signingMethod
        );
        return verified;
      }
      return Sighash.verify(this, sig, pubkey, nin, subscript, signingMethod);
    };
    Transaction2.prototype.verify = function() {
      if (this.inputs.length === 0) {
        return "transaction txins empty";
      }
      if (this.outputs.length === 0) {
        return "transaction txouts empty";
      }
      var valueoutbn = new BN2(0);
      for (var i2 = 0; i2 < this.outputs.length; i2++) {
        var txout = this.outputs[i2];
        if (txout.invalidSatoshis()) {
          return "transaction txout " + i2 + " satoshis is invalid";
        }
        if (txout._satoshisBN.gt(new BN2(Transaction2.MAX_MONEY, 10))) {
          return "transaction txout " + i2 + " greater than MAX_MONEY";
        }
        valueoutbn = valueoutbn.add(txout._satoshisBN);
        if (valueoutbn.gt(new BN2(Transaction2.MAX_MONEY))) {
          return "transaction txout " + i2 + " total output greater than MAX_MONEY";
        }
      }
      if (this.toBuffer().length > MAX_BLOCK_SIZE) {
        return "transaction over the maximum block size";
      }
      var txinmap = {};
      for (i2 = 0; i2 < this.inputs.length; i2++) {
        var txin = this.inputs[i2];
        var inputid = txin.prevTxId + ":" + txin.outputIndex;
        if (!_2.isUndefined(txinmap[inputid])) {
          return "transaction input " + i2 + " duplicate input";
        }
        txinmap[inputid] = true;
      }
      var isCoinbase = this.isCoinbase();
      if (isCoinbase) {
        var buf = this.inputs[0]._scriptBuffer;
        if (buf.length < 2 || buf.length > 100) {
          return "coinbase transaction script size invalid";
        }
      } else {
        for (i2 = 0; i2 < this.inputs.length; i2++) {
          if (this.inputs[i2].isNull()) {
            return "transaction input " + i2 + " has null input";
          }
        }
      }
      return true;
    };
    Transaction2.prototype.isCoinbase = function() {
      return this.inputs.length === 1 && this.inputs[0].isNull();
    };
    Transaction2.prototype.isRBF = function() {
      for (var i2 = 0; i2 < this.inputs.length; i2++) {
        var input2 = this.inputs[i2];
        if (input2.sequenceNumber < Input.MAXINT - 1) {
          return true;
        }
      }
      return false;
    };
    Transaction2.prototype.enableRBF = function() {
      for (var i2 = 0; i2 < this.inputs.length; i2++) {
        var input2 = this.inputs[i2];
        if (input2.sequenceNumber >= Input.MAXINT - 1) {
          input2.sequenceNumber = Input.DEFAULT_RBF_SEQNUMBER;
        }
      }
      return this;
    };
    Transaction2.prototype.setVersion = function(version2) {
      $2.checkArgument(
        JSUtil2.isNaturalNumber(version2) && version2 <= CURRENT_VERSION,
        "Wrong version number"
      );
      this.version = version2;
      return this;
    };
    transaction = Transaction2;
    return transaction;
  }
  var hasRequiredTransaction;
  function requireTransaction() {
    if (hasRequiredTransaction)
      return transaction$1.exports;
    hasRequiredTransaction = 1;
    transaction$1.exports = requireTransaction$1();
    transaction$1.exports.Input = requireInput();
    transaction$1.exports.Output = requireOutput();
    transaction$1.exports.UnspentOutput = requireUnspentoutput();
    transaction$1.exports.Signature = requireSignature();
    transaction$1.exports.Sighash = requireSighash();
    transaction$1.exports.SighashWitness = requireSighashwitness();
    return transaction$1.exports;
  }
  var interpreter;
  var hasRequiredInterpreter;
  function requireInterpreter() {
    if (hasRequiredInterpreter)
      return interpreter;
    hasRequiredInterpreter = 1;
    var _2 = lodashExports;
    var Script = requireScript$1();
    var Opcode2 = opcode;
    var BN2 = bn$2;
    var Hash2 = hashExports;
    var Signature2 = signature$2;
    var PublicKey2 = requirePublickey();
    var Interpreter = function Interpreter2(obj) {
      if (!(this instanceof Interpreter2)) {
        return new Interpreter2(obj);
      }
      if (obj) {
        this.initialize();
        this.set(obj);
      } else {
        this.initialize();
      }
    };
    Interpreter.SIGVERSION_BASE = 0;
    Interpreter.SIGVERSION_WITNESS_V0 = 1;
    Interpreter.SIGVERSION_TAPROOT = 2;
    Interpreter.SIGVERSION_TAPSCRIPT = 3;
    Interpreter.prototype.verifyWitnessProgram = function(version2, program, witness, satoshis, flags) {
      var scriptPubKey = new Script();
      var stack = [];
      if (version2 === 0) {
        if (program.length === 32) {
          if (witness.length === 0) {
            this.errstr = "SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY";
            return false;
          }
          var scriptPubKeyBuffer = witness[witness.length - 1];
          scriptPubKey = new Script(scriptPubKeyBuffer);
          var hash2 = Hash2.sha256(scriptPubKeyBuffer);
          if (hash2.toString("hex") !== program.toString("hex")) {
            this.errstr = "SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH";
            return false;
          }
          stack = witness.slice(0, -1);
        } else if (program.length === 20) {
          if (witness.length !== 2) {
            this.errstr = "SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH";
            return false;
          }
          scriptPubKey.add(Opcode2.OP_DUP);
          scriptPubKey.add(Opcode2.OP_HASH160);
          scriptPubKey.add(program);
          scriptPubKey.add(Opcode2.OP_EQUALVERIFY);
          scriptPubKey.add(Opcode2.OP_CHECKSIG);
          stack = witness;
        } else {
          this.errstr = "SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH";
          return false;
        }
      } else if (flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM) {
        this.errstr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM";
        return false;
      } else {
        return true;
      }
      this.initialize();
      this.set({
        script: scriptPubKey,
        stack,
        sigversion: Interpreter.SIGVERSION_WITNESS_V0,
        satoshis,
        flags
      });
      if (!this.evaluate()) {
        return false;
      }
      if (this.stack.length !== 1) {
        this.errstr = "SCRIPT_ERR_EVAL_FALSE";
        return false;
      }
      var buf = this.stack[this.stack.length - 1];
      if (!Interpreter.castToBool(buf)) {
        this.errstr = "SCRIPT_ERR_EVAL_FALSE_IN_STACK";
        return false;
      }
      return true;
    };
    Interpreter.prototype.verify = function(scriptSig, scriptPubkey, tx, nin, flags, witness, satoshis) {
      var Transaction2 = requireTransaction();
      if (_2.isUndefined(tx)) {
        tx = new Transaction2();
      }
      if (_2.isUndefined(nin)) {
        nin = 0;
      }
      if (_2.isUndefined(flags)) {
        flags = 0;
      }
      if (_2.isUndefined(witness)) {
        witness = null;
      }
      if (_2.isUndefined(satoshis)) {
        satoshis = 0;
      }
      this.set({
        script: scriptSig,
        tx,
        nin,
        sigversion: Interpreter.SIGVERSION_BASE,
        satoshis: 0,
        flags
      });
      var stackCopy;
      if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {
        this.errstr = "SCRIPT_ERR_SIG_PUSHONLY";
        return false;
      }
      if (!this.evaluate()) {
        return false;
      }
      if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {
        stackCopy = this.stack.slice();
      }
      var stack = this.stack;
      this.initialize();
      this.set({
        script: scriptPubkey,
        stack,
        tx,
        nin,
        flags
      });
      if (!this.evaluate()) {
        return false;
      }
      if (this.stack.length === 0) {
        this.errstr = "SCRIPT_ERR_EVAL_FALSE_NO_RESULT";
        return false;
      }
      var buf = this.stack[this.stack.length - 1];
      if (!Interpreter.castToBool(buf)) {
        this.errstr = "SCRIPT_ERR_EVAL_FALSE_IN_STACK";
        return false;
      }
      var hadWitness = false;
      if (flags & Interpreter.SCRIPT_VERIFY_WITNESS) {
        var witnessValues = {};
        if (scriptPubkey.isWitnessProgram(witnessValues)) {
          hadWitness = true;
          if (scriptSig.toBuffer().length !== 0) {
            return false;
          }
          if (!this.verifyWitnessProgram(witnessValues.version, witnessValues.program, witness, satoshis, this.flags)) {
            return false;
          }
        }
      }
      if (flags & Interpreter.SCRIPT_VERIFY_P2SH && scriptPubkey.isScriptHashOut()) {
        if (!scriptSig.isPushOnly()) {
          this.errstr = "SCRIPT_ERR_SIG_PUSHONLY";
          return false;
        }
        if (stackCopy.length === 0) {
          throw new Error("internal error - stack copy empty");
        }
        var redeemScriptSerialized = stackCopy[stackCopy.length - 1];
        var redeemScript = Script.fromBuffer(redeemScriptSerialized);
        stackCopy.pop();
        this.initialize();
        this.set({
          script: redeemScript,
          stack: stackCopy,
          tx,
          nin,
          flags
        });
        if (!this.evaluate()) {
          return false;
        }
        if (stackCopy.length === 0) {
          this.errstr = "SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK";
          return false;
        }
        if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {
          this.errstr = "SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK";
          return false;
        }
        if (flags & Interpreter.SCRIPT_VERIFY_WITNESS) {
          var p2shWitnessValues = {};
          if (redeemScript.isWitnessProgram(p2shWitnessValues)) {
            hadWitness = true;
            var redeemScriptPush = new Script();
            redeemScriptPush.add(redeemScript.toBuffer());
            if (scriptSig.toHex() !== redeemScriptPush.toHex()) {
              this.errstr = "SCRIPT_ERR_WITNESS_MALLEATED_P2SH";
              return false;
            }
            if (!this.verifyWitnessProgram(p2shWitnessValues.version, p2shWitnessValues.program, witness, satoshis, this.flags)) {
              return false;
            }
            stack = [stack[0]];
          }
        }
      }
      if ((this.flags & Interpreter.SCRIPT_VERIFY_CLEANSTACK) != 0) {
        if ((this.flags & Interpreter.SCRIPT_VERIFY_P2SH) == 0)
          throw "flags & SCRIPT_VERIFY_P2SH";
        if (stackCopy.length != 1) {
          this.errstr = "SCRIPT_ERR_CLEANSTACK";
          return false;
        }
      }
      if (this.flags & Interpreter.SCRIPT_VERIFY_WITNESS) {
        if (!hadWitness && witness.length > 0) {
          this.errstr = "SCRIPT_ERR_WITNESS_UNEXPECTED";
          return false;
        }
      }
      return true;
    };
    interpreter = Interpreter;
    Interpreter.prototype.initialize = function(obj) {
      this.stack = [];
      this.altstack = [];
      this.pc = 0;
      this.satoshis = 0;
      this.sigversion = Interpreter.SIGVERSION_BASE;
      this.pbegincodehash = 0;
      this.nOpCount = 0;
      this.vfExec = [];
      this.errstr = "";
      this.flags = 0;
    };
    Interpreter.prototype.set = function(obj) {
      this.script = obj.script || this.script;
      this.tx = obj.tx || this.tx;
      this.nin = typeof obj.nin !== "undefined" ? obj.nin : this.nin;
      this.stack = obj.stack || this.stack;
      this.altstack = obj.altack || this.altstack;
      this.pc = typeof obj.pc !== "undefined" ? obj.pc : this.pc;
      this.pbegincodehash = typeof obj.pbegincodehash !== "undefined" ? obj.pbegincodehash : this.pbegincodehash;
      this.sigversion = typeof obj.sigversion !== "undefined" ? obj.sigversion : this.sigversion;
      this.satoshis = typeof obj.satoshis !== "undefined" ? obj.satoshis : this.satoshis;
      this.nOpCount = typeof obj.nOpCount !== "undefined" ? obj.nOpCount : this.nOpCount;
      this.vfExec = obj.vfExec || this.vfExec;
      this.errstr = obj.errstr || this.errstr;
      this.flags = typeof obj.flags !== "undefined" ? obj.flags : this.flags;
    };
    Interpreter.true = buffer$2.Buffer.from([1]);
    Interpreter.false = buffer$2.Buffer.from([]);
    Interpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;
    Interpreter.LOCKTIME_THRESHOLD = 5e8;
    Interpreter.LOCKTIME_THRESHOLD_BN = new BN2(Interpreter.LOCKTIME_THRESHOLD);
    Interpreter.SCRIPT_VERIFY_NONE = 0;
    Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM = 1 << 12;
    Interpreter.SCRIPT_VERIFY_P2SH = 1 << 0;
    Interpreter.SCRIPT_VERIFY_STRICTENC = 1 << 1;
    Interpreter.SCRIPT_VERIFY_DERSIG = 1 << 2;
    Interpreter.SCRIPT_VERIFY_LOW_S = 1 << 3;
    Interpreter.SCRIPT_VERIFY_NULLDUMMY = 1 << 4;
    Interpreter.SCRIPT_VERIFY_SIGPUSHONLY = 1 << 5;
    Interpreter.SCRIPT_VERIFY_MINIMALDATA = 1 << 6;
    Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 7;
    Interpreter.SCRIPT_VERIFY_CLEANSTACK = 1 << 8, // CLTV See BIP65 for details.
    Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = 1 << 9;
    Interpreter.SCRIPT_VERIFY_WITNESS = 1 << 10;
    Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 11;
    Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = 1 << 10;
    Interpreter.SCRIPT_VERIFY_MINIMALIF = 1 << 13;
    Interpreter.SCRIPT_VERIFY_NULLFAIL = 1 << 14;
    Interpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE = 1 << 15;
    Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID = 1 << 16;
    Interpreter.SCRIPT_ENABLE_REPLAY_PROTECTION = 1 << 17;
    Interpreter.SCRIPT_ENABLE_MONOLITH_OPCODES = 1 << 18;
    Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 << 31;
    Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG = 1 << 22;
    Interpreter.SEQUENCE_LOCKTIME_MASK = 65535;
    Interpreter.castToBool = function(buf) {
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (buf[i2] !== 0) {
          if (i2 === buf.length - 1 && buf[i2] === 128) {
            return false;
          }
          return true;
        }
      }
      return false;
    };
    Interpreter.prototype.checkSignatureEncoding = function(buf) {
      var sig;
      if (buf.length == 0) {
        return true;
      }
      if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature2.isTxDER(buf)) {
        this.errstr = "SCRIPT_ERR_SIG_DER_INVALID_FORMAT";
        return false;
      } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {
        sig = Signature2.fromTxFormat(buf);
        if (!sig.hasLowS()) {
          this.errstr = "SCRIPT_ERR_SIG_DER_HIGH_S";
          return false;
        }
      } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {
        sig = Signature2.fromTxFormat(buf);
        if (!sig.hasDefinedHashtype()) {
          this.errstr = "SCRIPT_ERR_SIG_HASHTYPE";
          return false;
        }
      }
      return true;
    };
    Interpreter.prototype.checkPubkeyEncoding = function(buf) {
      if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey2.isValid(buf)) {
        this.errstr = "SCRIPT_ERR_PUBKEYTYPE";
        return false;
      }
      if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && this.sigversion == Interpreter.SIGVERSION_WITNESS_V0 && !PublicKey2.fromBuffer(buf).compressed) {
        this.errstr = "SCRIPT_ERR_WITNESS_PUBKEYTYPE";
        return false;
      }
      return true;
    };
    Interpreter.prototype.evaluate = function() {
      if (this.script.toBuffer().length > 1e4) {
        this.errstr = "SCRIPT_ERR_SCRIPT_SIZE";
        return false;
      }
      try {
        while (this.pc < this.script.chunks.length) {
          var fSuccess = this.step();
          if (!fSuccess) {
            return false;
          }
        }
        if (this.stack.length + this.altstack.length > 1e3) {
          this.errstr = "SCRIPT_ERR_STACK_SIZE";
          return false;
        }
      } catch (e) {
        this.errstr = "SCRIPT_ERR_UNKNOWN_ERROR: " + e;
        return false;
      }
      if (this.vfExec.length > 0) {
        this.errstr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL";
        return false;
      }
      return true;
    };
    Interpreter.prototype.checkLockTime = function(nLockTime) {
      if (!(this.tx.nLockTime < Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN) || this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))) {
        return false;
      }
      if (nLockTime.gt(new BN2(this.tx.nLockTime))) {
        return false;
      }
      if (!this.tx.inputs[this.nin].isFinal()) {
        return false;
      }
      return true;
    };
    Interpreter.prototype.checkSequence = function(nSequence) {
      var txToSequence = this.tx.inputs[this.nin].sequenceNumber;
      if (this.tx.version < 2) {
        return false;
      }
      if (txToSequence & SEQUENCE_LOCKTIME_DISABLE_FLAG) {
        return false;
      }
      var nLockTimeMask = Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG | Interpreter.SEQUENCE_LOCKTIME_MASK;
      var txToSequenceMasked = new BN2(txToSequence & nLockTimeMask);
      var nSequenceMasked = nSequence.and(nLockTimeMask);
      var SEQUENCE_LOCKTIME_TYPE_FLAG_BN = new BN2(Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG);
      if (!(txToSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) && nSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) || txToSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) && nSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN))) {
        return false;
      }
      if (nSequenceMasked.gt(txToSequenceMasked)) {
        return false;
      }
      return true;
    };
    Interpreter.prototype.step = function() {
      var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0;
      var fExec = this.vfExec.indexOf(false) === -1;
      var buf, buf1, buf2, spliced, n2, x1, x2, bn2, bn1, bn22, bufSig, bufPubkey, subscript;
      var sig, pubkey;
      var fValue, fSuccess;
      var chunk = this.script.chunks[this.pc];
      this.pc++;
      var opcodenum = chunk.opcodenum;
      if (_2.isUndefined(opcodenum)) {
        this.errstr = "SCRIPT_ERR_UNDEFINED_OPCODE";
        return false;
      }
      if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {
        this.errstr = "SCRIPT_ERR_PUSH_SIZE";
        return false;
      }
      if (opcodenum > Opcode2.OP_16 && ++this.nOpCount > 201) {
        this.errstr = "SCRIPT_ERR_OP_COUNT";
        return false;
      }
      if (opcodenum === Opcode2.OP_CAT || opcodenum === Opcode2.OP_SUBSTR || opcodenum === Opcode2.OP_LEFT || opcodenum === Opcode2.OP_RIGHT || opcodenum === Opcode2.OP_INVERT || opcodenum === Opcode2.OP_AND || opcodenum === Opcode2.OP_OR || opcodenum === Opcode2.OP_XOR || opcodenum === Opcode2.OP_2MUL || opcodenum === Opcode2.OP_2DIV || opcodenum === Opcode2.OP_MUL || opcodenum === Opcode2.OP_DIV || opcodenum === Opcode2.OP_MOD || opcodenum === Opcode2.OP_LSHIFT || opcodenum === Opcode2.OP_RSHIFT) {
        this.errstr = "SCRIPT_ERR_DISABLED_OPCODE";
        return false;
      }
      if (fExec && 0 <= opcodenum && opcodenum <= Opcode2.OP_PUSHDATA4) {
        if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {
          this.errstr = "SCRIPT_ERR_MINIMALDATA";
          return false;
        }
        if (!chunk.buf) {
          this.stack.push(Interpreter.false);
        } else if (chunk.len !== chunk.buf.length) {
          throw new Error("Length of push value not equal to length of data");
        } else {
          this.stack.push(chunk.buf);
        }
      } else if (fExec || Opcode2.OP_IF <= opcodenum && opcodenum <= Opcode2.OP_ENDIF) {
        switch (opcodenum) {
          case Opcode2.OP_1NEGATE:
          case Opcode2.OP_1:
          case Opcode2.OP_2:
          case Opcode2.OP_3:
          case Opcode2.OP_4:
          case Opcode2.OP_5:
          case Opcode2.OP_6:
          case Opcode2.OP_7:
          case Opcode2.OP_8:
          case Opcode2.OP_9:
          case Opcode2.OP_10:
          case Opcode2.OP_11:
          case Opcode2.OP_12:
          case Opcode2.OP_13:
          case Opcode2.OP_14:
          case Opcode2.OP_15:
          case Opcode2.OP_16:
            {
              n2 = opcodenum - (Opcode2.OP_1 - 1);
              buf = new BN2(n2).toScriptNumBuffer();
              this.stack.push(buf);
            }
            break;
          case Opcode2.OP_NOP:
            break;
          case Opcode2.OP_NOP2:
          case Opcode2.OP_CHECKLOCKTIMEVERIFY:
            if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {
              if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
                this.errstr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS";
                return false;
              }
              break;
            }
            if (this.stack.length < 1) {
              this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
              return false;
            }
            var nLockTime = BN2.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);
            if (nLockTime.lt(new BN2(0))) {
              this.errstr = "SCRIPT_ERR_NEGATIVE_LOCKTIME";
              return false;
            }
            if (!this.checkLockTime(nLockTime)) {
              this.errstr = "SCRIPT_ERR_UNSATISFIED_LOCKTIME";
              return false;
            }
            break;
          case Opcode2.OP_NOP3:
          case Opcode2.OP_CHECKSEQUENCEVERIFY:
            if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {
              if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
                this.errstr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS";
                return false;
              }
              break;
            }
            if (this.stack.length < 1) {
              this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
              return false;
            }
            var nSequence = BN2.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);
            if (nSequence.lt(new BN2(0))) {
              this.errstr = "SCRIPT_ERR_NEGATIVE_LOCKTIME";
              return false;
            }
            if ((nSequence & Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0) {
              break;
            }
            if (!this.checkSequence(nSequence)) {
              this.errstr = "SCRIPT_ERR_UNSATISFIED_LOCKTIME";
              return false;
            }
            break;
          case Opcode2.OP_NOP1:
          case Opcode2.OP_NOP4:
          case Opcode2.OP_NOP5:
          case Opcode2.OP_NOP6:
          case Opcode2.OP_NOP7:
          case Opcode2.OP_NOP8:
          case Opcode2.OP_NOP9:
          case Opcode2.OP_NOP10:
            {
              if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
                this.errstr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS";
                return false;
              }
            }
            break;
          case Opcode2.OP_IF:
          case Opcode2.OP_NOTIF:
            {
              fValue = false;
              if (fExec) {
                if (this.stack.length < 1) {
                  this.errstr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL";
                  return false;
                }
                buf = this.stack[this.stack.length - 1];
                if (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALIF) {
                  buf = this.stack[this.stack.length - 1];
                  if (buf.length > 1) {
                    this.errstr = "SCRIPT_ERR_MINIMALIF";
                    return false;
                  }
                  if (buf.length == 1 && buf[0] != 1) {
                    this.errstr = "SCRIPT_ERR_MINIMALIF";
                    return false;
                  }
                }
                fValue = Interpreter.castToBool(buf);
                if (opcodenum === Opcode2.OP_NOTIF) {
                  fValue = !fValue;
                }
                this.stack.pop();
              }
              this.vfExec.push(fValue);
            }
            break;
          case Opcode2.OP_ELSE:
            {
              if (this.vfExec.length === 0) {
                this.errstr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL";
                return false;
              }
              this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];
            }
            break;
          case Opcode2.OP_ENDIF:
            {
              if (this.vfExec.length === 0) {
                this.errstr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL";
                return false;
              }
              this.vfExec.pop();
            }
            break;
          case Opcode2.OP_VERIFY:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = this.stack[this.stack.length - 1];
              fValue = Interpreter.castToBool(buf);
              if (fValue) {
                this.stack.pop();
              } else {
                this.errstr = "SCRIPT_ERR_VERIFY";
                return false;
              }
            }
            break;
          case Opcode2.OP_RETURN: {
            this.errstr = "SCRIPT_ERR_OP_RETURN";
            return false;
          }
          case Opcode2.OP_TOALTSTACK:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.altstack.push(this.stack.pop());
            }
            break;
          case Opcode2.OP_FROMALTSTACK:
            {
              if (this.altstack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_ALTSTACK_OPERATION";
                return false;
              }
              this.stack.push(this.altstack.pop());
            }
            break;
          case Opcode2.OP_2DROP:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.pop();
              this.stack.pop();
            }
            break;
          case Opcode2.OP_2DUP:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = this.stack[this.stack.length - 2];
              buf2 = this.stack[this.stack.length - 1];
              this.stack.push(buf1);
              this.stack.push(buf2);
            }
            break;
          case Opcode2.OP_3DUP:
            {
              if (this.stack.length < 3) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = this.stack[this.stack.length - 3];
              buf2 = this.stack[this.stack.length - 2];
              var buf3 = this.stack[this.stack.length - 1];
              this.stack.push(buf1);
              this.stack.push(buf2);
              this.stack.push(buf3);
            }
            break;
          case Opcode2.OP_2OVER:
            {
              if (this.stack.length < 4) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = this.stack[this.stack.length - 4];
              buf2 = this.stack[this.stack.length - 3];
              this.stack.push(buf1);
              this.stack.push(buf2);
            }
            break;
          case Opcode2.OP_2ROT:
            {
              if (this.stack.length < 6) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              spliced = this.stack.splice(this.stack.length - 6, 2);
              this.stack.push(spliced[0]);
              this.stack.push(spliced[1]);
            }
            break;
          case Opcode2.OP_2SWAP:
            {
              if (this.stack.length < 4) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              spliced = this.stack.splice(this.stack.length - 4, 2);
              this.stack.push(spliced[0]);
              this.stack.push(spliced[1]);
            }
            break;
          case Opcode2.OP_IFDUP:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = this.stack[this.stack.length - 1];
              fValue = Interpreter.castToBool(buf);
              if (fValue) {
                this.stack.push(buf);
              }
            }
            break;
          case Opcode2.OP_DEPTH:
            {
              buf = new BN2(this.stack.length).toScriptNumBuffer();
              this.stack.push(buf);
            }
            break;
          case Opcode2.OP_DROP:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.pop();
            }
            break;
          case Opcode2.OP_DUP:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.push(this.stack[this.stack.length - 1]);
            }
            break;
          case Opcode2.OP_NIP:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.splice(this.stack.length - 2, 1);
            }
            break;
          case Opcode2.OP_OVER:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.push(this.stack[this.stack.length - 2]);
            }
            break;
          case Opcode2.OP_PICK:
          case Opcode2.OP_ROLL:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = this.stack[this.stack.length - 1];
              bn2 = BN2.fromScriptNumBuffer(buf, fRequireMinimal);
              n2 = bn2.toNumber();
              this.stack.pop();
              if (n2 < 0 || n2 >= this.stack.length) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = this.stack[this.stack.length - n2 - 1];
              if (opcodenum === Opcode2.OP_ROLL) {
                this.stack.splice(this.stack.length - n2 - 1, 1);
              }
              this.stack.push(buf);
            }
            break;
          case Opcode2.OP_ROT:
            {
              if (this.stack.length < 3) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              x1 = this.stack[this.stack.length - 3];
              x2 = this.stack[this.stack.length - 2];
              var x3 = this.stack[this.stack.length - 1];
              this.stack[this.stack.length - 3] = x2;
              this.stack[this.stack.length - 2] = x3;
              this.stack[this.stack.length - 1] = x1;
            }
            break;
          case Opcode2.OP_SWAP:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              x1 = this.stack[this.stack.length - 2];
              x2 = this.stack[this.stack.length - 1];
              this.stack[this.stack.length - 2] = x2;
              this.stack[this.stack.length - 1] = x1;
            }
            break;
          case Opcode2.OP_TUCK:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);
            }
            break;
          case Opcode2.OP_SIZE:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              bn2 = new BN2(this.stack[this.stack.length - 1].length);
              this.stack.push(bn2.toScriptNumBuffer());
            }
            break;
          case Opcode2.OP_EQUAL:
          case Opcode2.OP_EQUALVERIFY:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = this.stack[this.stack.length - 2];
              buf2 = this.stack[this.stack.length - 1];
              var fEqual = buf1.toString("hex") === buf2.toString("hex");
              this.stack.pop();
              this.stack.pop();
              this.stack.push(fEqual ? Interpreter.true : Interpreter.false);
              if (opcodenum === Opcode2.OP_EQUALVERIFY) {
                if (fEqual) {
                  this.stack.pop();
                } else {
                  this.errstr = "SCRIPT_ERR_EQUALVERIFY";
                  return false;
                }
              }
            }
            break;
          case Opcode2.OP_1ADD:
          case Opcode2.OP_1SUB:
          case Opcode2.OP_NEGATE:
          case Opcode2.OP_ABS:
          case Opcode2.OP_NOT:
          case Opcode2.OP_0NOTEQUAL:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = this.stack[this.stack.length - 1];
              bn2 = BN2.fromScriptNumBuffer(buf, fRequireMinimal);
              switch (opcodenum) {
                case Opcode2.OP_1ADD:
                  bn2 = bn2.add(BN2.One);
                  break;
                case Opcode2.OP_1SUB:
                  bn2 = bn2.sub(BN2.One);
                  break;
                case Opcode2.OP_NEGATE:
                  bn2 = bn2.neg();
                  break;
                case Opcode2.OP_ABS:
                  if (bn2.cmp(BN2.Zero) < 0) {
                    bn2 = bn2.neg();
                  }
                  break;
                case Opcode2.OP_NOT:
                  bn2 = new BN2((bn2.cmp(BN2.Zero) === 0) + 0);
                  break;
                case Opcode2.OP_0NOTEQUAL:
                  bn2 = new BN2((bn2.cmp(BN2.Zero) !== 0) + 0);
                  break;
              }
              this.stack.pop();
              this.stack.push(bn2.toScriptNumBuffer());
            }
            break;
          case Opcode2.OP_ADD:
          case Opcode2.OP_SUB:
          case Opcode2.OP_BOOLAND:
          case Opcode2.OP_BOOLOR:
          case Opcode2.OP_NUMEQUAL:
          case Opcode2.OP_NUMEQUALVERIFY:
          case Opcode2.OP_NUMNOTEQUAL:
          case Opcode2.OP_LESSTHAN:
          case Opcode2.OP_GREATERTHAN:
          case Opcode2.OP_LESSTHANOREQUAL:
          case Opcode2.OP_GREATERTHANOREQUAL:
          case Opcode2.OP_MIN:
          case Opcode2.OP_MAX:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              bn1 = BN2.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);
              bn22 = BN2.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);
              bn2 = new BN2(0);
              switch (opcodenum) {
                case Opcode2.OP_ADD:
                  bn2 = bn1.add(bn22);
                  break;
                case Opcode2.OP_SUB:
                  bn2 = bn1.sub(bn22);
                  break;
                case Opcode2.OP_BOOLAND:
                  bn2 = new BN2((bn1.cmp(BN2.Zero) !== 0 && bn22.cmp(BN2.Zero) !== 0) + 0);
                  break;
                case Opcode2.OP_BOOLOR:
                  bn2 = new BN2((bn1.cmp(BN2.Zero) !== 0 || bn22.cmp(BN2.Zero) !== 0) + 0);
                  break;
                case Opcode2.OP_NUMEQUAL:
                  bn2 = new BN2((bn1.cmp(bn22) === 0) + 0);
                  break;
                case Opcode2.OP_NUMEQUALVERIFY:
                  bn2 = new BN2((bn1.cmp(bn22) === 0) + 0);
                  break;
                case Opcode2.OP_NUMNOTEQUAL:
                  bn2 = new BN2((bn1.cmp(bn22) !== 0) + 0);
                  break;
                case Opcode2.OP_LESSTHAN:
                  bn2 = new BN2((bn1.cmp(bn22) < 0) + 0);
                  break;
                case Opcode2.OP_GREATERTHAN:
                  bn2 = new BN2((bn1.cmp(bn22) > 0) + 0);
                  break;
                case Opcode2.OP_LESSTHANOREQUAL:
                  bn2 = new BN2((bn1.cmp(bn22) <= 0) + 0);
                  break;
                case Opcode2.OP_GREATERTHANOREQUAL:
                  bn2 = new BN2((bn1.cmp(bn22) >= 0) + 0);
                  break;
                case Opcode2.OP_MIN:
                  bn2 = bn1.cmp(bn22) < 0 ? bn1 : bn22;
                  break;
                case Opcode2.OP_MAX:
                  bn2 = bn1.cmp(bn22) > 0 ? bn1 : bn22;
                  break;
              }
              this.stack.pop();
              this.stack.pop();
              this.stack.push(bn2.toScriptNumBuffer());
              if (opcodenum === Opcode2.OP_NUMEQUALVERIFY) {
                if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {
                  this.stack.pop();
                } else {
                  this.errstr = "SCRIPT_ERR_NUMEQUALVERIFY";
                  return false;
                }
              }
            }
            break;
          case Opcode2.OP_WITHIN:
            {
              if (this.stack.length < 3) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              bn1 = BN2.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);
              bn22 = BN2.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);
              var bn3 = BN2.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);
              fValue = bn22.cmp(bn1) <= 0 && bn1.cmp(bn3) < 0;
              this.stack.pop();
              this.stack.pop();
              this.stack.pop();
              this.stack.push(fValue ? Interpreter.true : Interpreter.false);
            }
            break;
          case Opcode2.OP_RIPEMD160:
          case Opcode2.OP_SHA1:
          case Opcode2.OP_SHA256:
          case Opcode2.OP_HASH160:
          case Opcode2.OP_HASH256:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = this.stack[this.stack.length - 1];
              var bufHash;
              if (opcodenum === Opcode2.OP_RIPEMD160) {
                bufHash = Hash2.ripemd160(buf);
              } else if (opcodenum === Opcode2.OP_SHA1) {
                bufHash = Hash2.sha1(buf);
              } else if (opcodenum === Opcode2.OP_SHA256) {
                bufHash = Hash2.sha256(buf);
              } else if (opcodenum === Opcode2.OP_HASH160) {
                bufHash = Hash2.sha256ripemd160(buf);
              } else if (opcodenum === Opcode2.OP_HASH256) {
                bufHash = Hash2.sha256sha256(buf);
              }
              this.stack.pop();
              this.stack.push(bufHash);
            }
            break;
          case Opcode2.OP_CODESEPARATOR:
            {
              this.pbegincodehash = this.pc;
            }
            break;
          case Opcode2.OP_CHECKSIG:
          case Opcode2.OP_CHECKSIGVERIFY:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              bufSig = this.stack[this.stack.length - 2];
              bufPubkey = this.stack[this.stack.length - 1];
              if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {
                return false;
              }
              subscript = new Script().set({
                chunks: this.script.chunks.slice(this.pbegincodehash)
              });
              var tmpScript = new Script().add(bufSig);
              subscript.findAndDelete(tmpScript);
              try {
                sig = Signature2.fromTxFormat(bufSig);
                pubkey = PublicKey2.fromBuffer(bufPubkey, false);
                fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis);
              } catch (e) {
                fSuccess = false;
              }
              if (!fSuccess && this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL && bufSig.length) {
                this.errstr = "SCRIPT_ERR_NULLFAIL";
                return false;
              }
              this.stack.pop();
              this.stack.pop();
              this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);
              if (opcodenum === Opcode2.OP_CHECKSIGVERIFY) {
                if (fSuccess) {
                  this.stack.pop();
                } else {
                  this.errstr = "SCRIPT_ERR_CHECKSIGVERIFY";
                  return false;
                }
              }
            }
            break;
          case Opcode2.OP_CHECKMULTISIG:
          case Opcode2.OP_CHECKMULTISIGVERIFY:
            {
              var i2 = 1;
              if (this.stack.length < i2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              var nKeysCount = BN2.fromScriptNumBuffer(this.stack[this.stack.length - i2], fRequireMinimal).toNumber();
              if (nKeysCount < 0 || nKeysCount > 20) {
                this.errstr = "SCRIPT_ERR_PUBKEY_COUNT";
                return false;
              }
              this.nOpCount += nKeysCount;
              if (this.nOpCount > 201) {
                this.errstr = "SCRIPT_ERR_OP_COUNT";
                return false;
              }
              var ikey = ++i2;
              i2 += nKeysCount;
              var ikey2 = nKeysCount + 2;
              if (this.stack.length < i2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              var nSigsCount = BN2.fromScriptNumBuffer(this.stack[this.stack.length - i2], fRequireMinimal).toNumber();
              if (nSigsCount < 0 || nSigsCount > nKeysCount) {
                this.errstr = "SCRIPT_ERR_SIG_COUNT";
                return false;
              }
              var isig = ++i2;
              i2 += nSigsCount;
              if (this.stack.length < i2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              subscript = new Script().set({
                chunks: this.script.chunks.slice(this.pbegincodehash)
              });
              for (var k2 = 0; k2 < nSigsCount; k2++) {
                bufSig = this.stack[this.stack.length - isig - k2];
                subscript.findAndDelete(new Script().add(bufSig));
              }
              fSuccess = true;
              while (fSuccess && nSigsCount > 0) {
                bufSig = this.stack[this.stack.length - isig];
                bufPubkey = this.stack[this.stack.length - ikey];
                if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {
                  return false;
                }
                var fOk;
                try {
                  sig = Signature2.fromTxFormat(bufSig);
                  pubkey = PublicKey2.fromBuffer(bufPubkey, false);
                  fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis);
                } catch (e) {
                  fOk = false;
                }
                if (fOk) {
                  isig++;
                  nSigsCount--;
                }
                ikey++;
                nKeysCount--;
                if (nSigsCount > nKeysCount) {
                  fSuccess = false;
                }
              }
              while (i2-- > 1) {
                if (!fSuccess && this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL && !ikey2 && this.stack[this.stack.length - 1].length) {
                  this.errstr = "SCRIPT_ERR_NULLFAIL";
                  return false;
                }
                if (ikey2 > 0) {
                  ikey2--;
                }
                this.stack.pop();
              }
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              if (this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY && this.stack[this.stack.length - 1].length) {
                this.errstr = "SCRIPT_ERR_SIG_NULLDUMMY";
                return false;
              }
              this.stack.pop();
              this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);
              if (opcodenum === Opcode2.OP_CHECKMULTISIGVERIFY) {
                if (fSuccess) {
                  this.stack.pop();
                } else {
                  this.errstr = "SCRIPT_ERR_CHECKMULTISIGVERIFY";
                  return false;
                }
              }
            }
            break;
          default:
            this.errstr = "SCRIPT_ERR_BAD_OPCODE";
            return false;
        }
      }
      return true;
    };
    return interpreter;
  }
  var hasRequiredScript;
  function requireScript() {
    if (hasRequiredScript)
      return script$1.exports;
    hasRequiredScript = 1;
    script$1.exports = requireScript$1();
    script$1.exports.Interpreter = requireInterpreter();
    return script$1.exports;
  }
  var address$1;
  var hasRequiredAddress;
  function requireAddress() {
    if (hasRequiredAddress)
      return address$1;
    hasRequiredAddress = 1;
    var _2 = lodashExports;
    var $2 = preconditions;
    var errors2 = errorsExports;
    var Base58Check2 = base58check;
    var Bech32 = bech32_1;
    var Networks = networks_1;
    var Hash2 = hashExports;
    var JSUtil2 = js$1;
    var PublicKey2 = requirePublickey();
    function Address2(data2, network, type2, multisigType) {
      if (!(this instanceof Address2)) {
        return new Address2(data2, network, type2);
      }
      if (_2.isArray(data2) && _2.isNumber(network)) {
        return Address2.createMultisig(data2, network, type2, false, multisigType);
      }
      if (data2 instanceof Address2) {
        return data2;
      }
      $2.checkArgument(data2, "First argument is required, please include address data.", "guide/address.html");
      if (network && !Networks.get(network)) {
        throw new TypeError('Second argument must be "livenet" or "testnet".');
      }
      if (type2 && (type2 !== Address2.PayToPublicKeyHash && type2 !== Address2.PayToScriptHash && type2 !== Address2.PayToWitnessPublicKeyHash && type2 !== Address2.PayToWitnessScriptHash && type2 !== Address2.PayToTaproot)) {
        throw new TypeError('Third argument must be "pubkeyhash", "scripthash", "witnesspubkeyhash", "witnessscripthash", or "taproot".');
      }
      var info = this._classifyArguments(data2, network, type2);
      info.network = info.network || Networks.get(network) || Networks.defaultNetwork;
      info.type = info.type || type2 || Address2.PayToPublicKeyHash;
      JSUtil2.defineImmutable(this, {
        hashBuffer: info.hashBuffer,
        network: info.network,
        type: info.type
      });
      return this;
    }
    Address2.prototype._classifyArguments = function(data2, network, type2) {
      if ((data2 instanceof buffer$2.Buffer || data2 instanceof Uint8Array) && (data2.length === 20 || data2.length === 32)) {
        return Address2._transformHash(data2, network, type2);
      } else if ((data2 instanceof buffer$2.Buffer || data2 instanceof Uint8Array) && data2.length >= 21) {
        return Address2._transformBuffer(data2, network, type2);
      } else if (data2 instanceof PublicKey2) {
        return Address2._transformPublicKey(data2, network, type2);
      } else if (data2 instanceof Script) {
        return Address2._transformScript(data2, network);
      } else if (typeof data2 === "string") {
        return Address2._transformString(data2, network, type2);
      } else if (_2.isObject(data2)) {
        return Address2._transformObject(data2);
      } else {
        throw new TypeError("First argument is an unrecognized data format.");
      }
    };
    Address2.PayToPublicKeyHash = "pubkeyhash";
    Address2.PayToScriptHash = "scripthash";
    Address2.PayToWitnessPublicKeyHash = "witnesspubkeyhash";
    Address2.PayToWitnessScriptHash = "witnessscripthash";
    Address2.PayToTaproot = "taproot";
    Address2._transformHash = function(hash2, network, type2) {
      var info = {};
      if (!(hash2 instanceof buffer$2.Buffer) && !(hash2 instanceof Uint8Array)) {
        throw new TypeError("Address supplied is not a buffer.");
      }
      if (hash2.length !== 20 && hash2.length !== 32) {
        throw new TypeError("Address hashbuffers must be either 20 or 32 bytes.");
      }
      info.hashBuffer = hash2;
      info.network = Networks.get(network) || Networks.defaultNetwork;
      info.type = type2;
      return info;
    };
    Address2._transformObject = function(data2) {
      $2.checkArgument(data2.hash || data2.hashBuffer, "Must provide a `hash` or `hashBuffer` property");
      $2.checkArgument(data2.type, "Must provide a `type` property");
      return {
        hashBuffer: data2.hash ? buffer$2.Buffer.from(data2.hash, "hex") : data2.hashBuffer,
        network: Networks.get(data2.network) || Networks.defaultNetwork,
        type: data2.type
      };
    };
    Address2._classifyFromVersion = function(buffer2) {
      var version2 = {};
      if (buffer2.length > 21) {
        var info = Bech32.decode(buffer2.toString("utf8"));
        if (info.version !== 0 && info.version !== 1) {
          throw new TypeError("Only witness v0 and v1 addresses are supported.");
        }
        if (info.version === 0) {
          if (info.data.length === 20) {
            version2.type = Address2.PayToWitnessPublicKeyHash;
          } else if (info.data.length === 32) {
            version2.type = Address2.PayToWitnessScriptHash;
          } else {
            throw new TypeError("Witness data must be either 20 or 32 bytes.");
          }
        } else if (info.version === 1) {
          if (info.data.length === 32) {
            version2.type = Address2.PayToTaproot;
          } else {
            throw new TypeError("Witness data must be 32 bytes for v1");
          }
        } else
          ;
        version2.network = Networks.get(info.prefix, "bech32prefix");
      } else {
        var pubkeyhashNetwork = Networks.get(buffer2[0], "pubkeyhash");
        var scripthashNetwork = Networks.get(buffer2[0], "scripthash");
        if (pubkeyhashNetwork) {
          version2.network = pubkeyhashNetwork;
          version2.type = Address2.PayToPublicKeyHash;
        } else if (scripthashNetwork) {
          version2.network = scripthashNetwork;
          version2.type = Address2.PayToScriptHash;
        }
      }
      return version2;
    };
    Address2._transformBuffer = function(buffer2, network, type2) {
      var info = {};
      if (!(buffer2 instanceof buffer$2.Buffer) && !(buffer2 instanceof Uint8Array)) {
        throw new TypeError("Address supplied is not a buffer.");
      }
      if (buffer2.length < 21) {
        throw new TypeError("Address buffer is incorrect length.");
      }
      var networkObj = Networks.get(network);
      var bufferVersion = Address2._classifyFromVersion(buffer2);
      if (network && !networkObj) {
        throw new TypeError("Unknown network");
      }
      if (!bufferVersion.network || networkObj && networkObj.xpubkey !== bufferVersion.network.xpubkey) {
        throw new TypeError("Address has mismatched network type.");
      }
      if (!bufferVersion.type || type2 && type2 !== bufferVersion.type) {
        throw new TypeError("Address has mismatched type.");
      }
      if (buffer2.length > 21) {
        info.hashBuffer = Bech32.decode(buffer2.toString("utf8")).data;
      } else {
        info.hashBuffer = buffer2.slice(1);
      }
      info.network = bufferVersion.network;
      info.type = bufferVersion.type;
      return info;
    };
    Address2._transformPublicKey = function(pubkey, network, type2) {
      var info = {};
      if (!(pubkey instanceof PublicKey2)) {
        throw new TypeError("Address must be an instance of PublicKey.");
      }
      if (type2 && type2 !== Address2.PayToScriptHash && type2 !== Address2.PayToWitnessPublicKeyHash && type2 !== Address2.PayToPublicKeyHash && type2 !== Address2.PayToTaproot) {
        throw new TypeError("Type must be either pubkeyhash, witnesspubkeyhash, scripthash, or taproot to transform public key.");
      }
      if (!pubkey.compressed && (type2 === Address2.PayToScriptHash || type2 === Address2.PayToWitnessPublicKeyHash)) {
        throw new TypeError("Witness addresses must use compressed public keys.");
      }
      if (type2 === Address2.PayToScriptHash) {
        info.hashBuffer = Hash2.sha256ripemd160(Script.buildWitnessV0Out(pubkey).toBuffer());
      } else if (type2 === Address2.PayToTaproot) {
        info.hashBuffer = Hash2.sha256ripemd160(Script.buildWitnessV1Out(pubkey).toBuffer());
      } else {
        info.hashBuffer = Hash2.sha256ripemd160(pubkey.toBuffer());
      }
      info.type = type2 || Address2.PayToPublicKeyHash;
      return info;
    };
    Address2._transformScript = function(script2, network) {
      $2.checkArgument(script2 instanceof Script, "script must be a Script instance");
      var info = script2.getAddressInfo(network);
      if (!info) {
        throw new errors2.Script.CantDeriveAddress(script2);
      }
      return info;
    };
    Address2.createMultisig = function(publicKeys, threshold, network, nestedWitness, type2) {
      network = network || publicKeys[0].network || Networks.defaultNetwork;
      if (type2 && type2 !== Address2.PayToScriptHash && type2 !== Address2.PayToWitnessScriptHash) {
        throw new TypeError("Type must be either scripthash or witnessscripthash to create multisig.");
      }
      if (nestedWitness || type2 === Address2.PayToWitnessScriptHash) {
        publicKeys = _2.map(publicKeys, PublicKey2);
        for (var i2 = 0; i2 < publicKeys.length; i2++) {
          if (!publicKeys[i2].compressed) {
            throw new TypeError("Witness addresses must use compressed public keys.");
          }
        }
      }
      var redeemScript = Script.buildMultisigOut(publicKeys, threshold);
      if (nestedWitness) {
        return Address2.payingTo(Script.buildWitnessMultisigOutFromScript(redeemScript), network);
      }
      return Address2.payingTo(redeemScript, network, type2);
    };
    Address2._transformString = function(data2, network, type2) {
      if (typeof data2 !== "string") {
        throw new TypeError("data parameter supplied is not a string.");
      }
      if (data2.length > 100) {
        throw new TypeError("address string is too long");
      }
      if (network && !Networks.get(network)) {
        throw new TypeError("Unknown network");
      }
      data2 = data2.trim();
      try {
        var info = Address2._transformBuffer(buffer$2.Buffer.from(data2, "utf8"), network, type2);
        return info;
      } catch (e) {
        if (type2 === Address2.PayToWitnessPublicKeyHash || type2 === Address2.PayToWitnessScriptHash || type2 === Address2.PayToTaproot) {
          throw e;
        }
      }
      var addressBuffer = Base58Check2.decode(data2);
      var info = Address2._transformBuffer(addressBuffer, network, type2);
      return info;
    };
    Address2.fromPublicKey = function(data2, network, type2) {
      var info = Address2._transformPublicKey(data2, network, type2);
      network = network || Networks.defaultNetwork;
      return new Address2(info.hashBuffer, network, info.type);
    };
    Address2.fromPublicKeyHash = function(hash2, network) {
      var info = Address2._transformHash(hash2);
      return new Address2(info.hashBuffer, network, Address2.PayToPublicKeyHash);
    };
    Address2.fromScriptHash = function(hash2, network, type2) {
      $2.checkArgument(hash2, "hash parameter is required");
      var info = Address2._transformHash(hash2);
      if (type2 === Address2.PayToWitnessScriptHash && hash2.length !== 32) {
        throw new TypeError("Address hashbuffer must be exactly 32 bytes for v0 witness script hash.");
      }
      var type2 = type2 || Address2.PayToScriptHash;
      return new Address2(info.hashBuffer, network, type2);
    };
    Address2.payingTo = function(script2, network, type2) {
      $2.checkArgument(script2, "script is required");
      $2.checkArgument(script2 instanceof Script, "script must be instance of Script");
      var hash2;
      if (type2 === Address2.PayToWitnessScriptHash) {
        hash2 = Hash2.sha256(script2.toBuffer());
      } else {
        hash2 = Hash2.sha256ripemd160(script2.toBuffer());
      }
      var type2 = type2 || Address2.PayToScriptHash;
      return Address2.fromScriptHash(hash2, network, type2);
    };
    Address2.fromScript = function(script2, network) {
      $2.checkArgument(script2 instanceof Script, "script must be a Script instance");
      var info = Address2._transformScript(script2, network);
      return new Address2(info.hashBuffer, network, info.type);
    };
    Address2.fromBuffer = function(buffer2, network, type2) {
      var info = Address2._transformBuffer(buffer2, network, type2);
      return new Address2(info.hashBuffer, info.network, info.type);
    };
    Address2.fromString = function(str, network, type2) {
      var info = Address2._transformString(str, network, type2);
      return new Address2(info.hashBuffer, info.network, info.type);
    };
    Address2.fromObject = function fromObject(obj) {
      $2.checkState(
        JSUtil2.isHexa(obj.hash),
        'Unexpected hash property, "' + obj.hash + '", expected to be hex.'
      );
      var hashBuffer = buffer$2.Buffer.from(obj.hash, "hex");
      return new Address2(hashBuffer, obj.network, obj.type);
    };
    Address2.getValidationError = function(data2, network, type2) {
      var error;
      try {
        new Address2(data2, network, type2);
      } catch (e) {
        error = e;
      }
      return error;
    };
    Address2.isValid = function(data2, network, type2) {
      return !Address2.getValidationError(data2, network, type2);
    };
    Address2.prototype.isPayToPublicKeyHash = function() {
      return this.type === Address2.PayToPublicKeyHash;
    };
    Address2.prototype.isPayToScriptHash = function() {
      return this.type === Address2.PayToScriptHash;
    };
    Address2.prototype.isPayToWitnessPublicKeyHash = function() {
      return this.type === Address2.PayToWitnessPublicKeyHash;
    };
    Address2.prototype.isPayToWitnessScriptHash = function() {
      return this.type === Address2.PayToWitnessScriptHash;
    };
    Address2.prototype.isPayToTaproot = function() {
      return this.type === Address2.PayToTaproot;
    };
    Address2.prototype.toBuffer = function() {
      if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash()) {
        return buffer$2.Buffer.from(this.toString(), "utf8");
      }
      var version2 = buffer$2.Buffer.from([this.network[this.type]]);
      return buffer$2.Buffer.concat([version2, this.hashBuffer]);
    };
    Address2.prototype.toObject = Address2.prototype.toJSON = function toObject2() {
      return {
        hash: this.hashBuffer.toString("hex"),
        type: this.type,
        network: this.network.toString()
      };
    };
    Address2.prototype.toString = function() {
      if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash() || this.isPayToTaproot()) {
        let prefix = this.network.bech32prefix;
        let version2 = 0;
        let encoding = Bech32.encodings.BECH32;
        if (this.isPayToTaproot()) {
          version2 = 1;
          encoding = Bech32.encodings.BECH32M;
        }
        return Bech32.encode(prefix, version2, this.hashBuffer, encoding);
      }
      return Base58Check2.encode(this.toBuffer());
    };
    Address2.prototype.inspect = function() {
      return "<Address: " + this.toString() + ", type: " + this.type + ", network: " + this.network + ">";
    };
    address$1 = Address2;
    var Script = requireScript();
    return address$1;
  }
  function Random() {
  }
  Random.getRandomBuffer = function(size) {
    if (process.browser)
      return Random.getRandomBufferBrowser(size);
    else
      return Random.getRandomBufferNode(size);
  };
  Random.getRandomBufferNode = function(size) {
    var crypto2 = require$$1$1;
    return crypto2.randomBytes(size);
  };
  Random.getRandomBufferBrowser = function(size) {
    if (!window.crypto && !window.msCrypto)
      throw new Error("window.crypto not available");
    if (window.crypto && window.crypto.getRandomValues)
      var crypto2 = window.crypto;
    else if (window.msCrypto && window.msCrypto.getRandomValues)
      var crypto2 = window.msCrypto;
    else
      throw new Error("window.crypto.getRandomValues not available");
    var bbuf = new Uint8Array(size);
    crypto2.getRandomValues(bbuf);
    var buf = buffer$2.Buffer.from(bbuf);
    return buf;
  };
  Random.getPseudoRandomBuffer = function(size) {
    var b32 = 4294967296;
    var b = buffer$2.Buffer.alloc(size);
    var r2;
    for (var i2 = 0; i2 <= size; i2++) {
      var j = Math.floor(i2 / 4);
      var k2 = i2 - j * 4;
      if (k2 === 0) {
        r2 = Math.random() * b32;
        b[i2] = r2 & 255;
      } else {
        b[i2] = (r2 = r2 >>> 8) & 255;
      }
    }
    return b;
  };
  var random$1 = Random;
  var privatekey;
  var hasRequiredPrivatekey;
  function requirePrivatekey() {
    if (hasRequiredPrivatekey)
      return privatekey;
    hasRequiredPrivatekey = 1;
    var _2 = lodashExports;
    var Address2 = requireAddress();
    var Base58Check2 = base58check;
    var BN2 = bn$2;
    var JSUtil2 = js$1;
    var Networks = networks_1;
    var Point2 = point$1;
    var PublicKey2 = requirePublickey();
    var Random2 = random$1;
    var $2 = preconditions;
    function PrivateKey2(data2, network) {
      if (!(this instanceof PrivateKey2)) {
        return new PrivateKey2(data2, network);
      }
      if (data2 instanceof PrivateKey2) {
        return data2;
      }
      var info = this._classifyArguments(data2, network);
      if (!info.bn || info.bn.cmp(new BN2(0)) === 0) {
        throw new TypeError("Number can not be equal to zero, undefined, null or false");
      }
      if (!info.bn.lt(Point2.getN())) {
        throw new TypeError("Number must be less than N");
      }
      if (typeof info.network === "undefined") {
        throw new TypeError('Must specify the network ("livenet" or "testnet")');
      }
      JSUtil2.defineImmutable(this, {
        bn: info.bn,
        compressed: info.compressed,
        network: info.network
      });
      Object.defineProperty(this, "publicKey", {
        configurable: false,
        enumerable: true,
        get: this.toPublicKey.bind(this)
      });
      return this;
    }
    PrivateKey2.prototype._classifyArguments = function(data2, network) {
      var info = {
        compressed: true,
        network: network ? Networks.get(network) : Networks.defaultNetwork
      };
      if (_2.isUndefined(data2) || _2.isNull(data2)) {
        info.bn = PrivateKey2._getRandomBN();
      } else if (data2 instanceof BN2) {
        info.bn = data2;
      } else if (data2 instanceof buffer$2.Buffer || data2 instanceof Uint8Array) {
        info = PrivateKey2._transformBuffer(data2, network);
      } else if (data2.bn && data2.network) {
        info = PrivateKey2._transformObject(data2);
      } else if (!network && Networks.get(data2)) {
        info.bn = PrivateKey2._getRandomBN();
        info.network = Networks.get(data2);
      } else if (typeof data2 === "string") {
        if (JSUtil2.isHexa(data2)) {
          info.bn = new BN2(buffer$2.Buffer.from(data2, "hex"));
        } else {
          info = PrivateKey2._transformWIF(data2, network);
        }
      } else {
        throw new TypeError("First argument is an unrecognized data type.");
      }
      return info;
    };
    PrivateKey2._getRandomBN = function() {
      var condition;
      var bn2;
      do {
        var privbuf = Random2.getRandomBuffer(32);
        bn2 = BN2.fromBuffer(privbuf);
        condition = bn2.lt(Point2.getN());
      } while (!condition);
      return bn2;
    };
    PrivateKey2._transformBuffer = function(buf, network) {
      var info = {};
      if (buf.length === 32) {
        return PrivateKey2._transformBNBuffer(buf, network);
      }
      info.network = Networks.get(buf[0], "privatekey");
      if (!info.network) {
        throw new Error("Invalid network");
      }
      if (network && info.network !== Networks.get(network)) {
        throw new TypeError("Private key network mismatch");
      }
      if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {
        info.compressed = true;
      } else if (buf.length === 1 + 32) {
        info.compressed = false;
      } else {
        throw new Error("Length of buffer must be 33 (uncompressed) or 34 (compressed)");
      }
      info.bn = BN2.fromBuffer(buf.slice(1, 32 + 1));
      return info;
    };
    PrivateKey2._transformBNBuffer = function(buf, network) {
      var info = {};
      info.network = Networks.get(network) || Networks.defaultNetwork;
      info.bn = BN2.fromBuffer(buf);
      info.compressed = false;
      return info;
    };
    PrivateKey2._transformWIF = function(str, network) {
      return PrivateKey2._transformBuffer(Base58Check2.decode(str), network);
    };
    PrivateKey2.fromBuffer = function(arg, network) {
      return new PrivateKey2(arg, network);
    };
    PrivateKey2._transformObject = function(json) {
      var bn2 = new BN2(json.bn, "hex");
      var network = Networks.get(json.network);
      return {
        bn: bn2,
        network,
        compressed: json.compressed
      };
    };
    PrivateKey2.fromString = PrivateKey2.fromWIF = function(str) {
      $2.checkArgument(_2.isString(str), "First argument is expected to be a string.");
      return new PrivateKey2(str);
    };
    PrivateKey2.fromObject = function(obj) {
      $2.checkArgument(_2.isObject(obj), "First argument is expected to be an object.");
      return new PrivateKey2(obj);
    };
    PrivateKey2.fromRandom = function(network) {
      var bn2 = PrivateKey2._getRandomBN();
      return new PrivateKey2(bn2, network);
    };
    PrivateKey2.getValidationError = function(data2, network) {
      var error;
      try {
        new PrivateKey2(data2, network);
      } catch (e) {
        error = e;
      }
      return error;
    };
    PrivateKey2.isValid = function(data2, network) {
      if (!data2) {
        return false;
      }
      return !PrivateKey2.getValidationError(data2, network);
    };
    PrivateKey2.prototype.toString = function() {
      return this.toBuffer().toString("hex");
    };
    PrivateKey2.prototype.toWIF = function() {
      var network = this.network;
      var compressed = this.compressed;
      var buf;
      if (compressed) {
        buf = buffer$2.Buffer.concat([
          buffer$2.Buffer.from([network.privatekey]),
          this.bn.toBuffer({ size: 32 }),
          buffer$2.Buffer.from([1])
        ]);
      } else {
        buf = buffer$2.Buffer.concat([
          buffer$2.Buffer.from([network.privatekey]),
          this.bn.toBuffer({ size: 32 })
        ]);
      }
      return Base58Check2.encode(buf);
    };
    PrivateKey2.prototype.toBigNumber = function() {
      return this.bn;
    };
    PrivateKey2.prototype.toBuffer = function() {
      return this.bn.toBuffer({ size: 32 });
    };
    PrivateKey2.prototype.toBufferNoPadding = function() {
      return this.bn.toBuffer();
    };
    PrivateKey2.prototype.toPublicKey = function() {
      if (!this._pubkey) {
        this._pubkey = PublicKey2.fromPrivateKey(this);
      }
      return this._pubkey;
    };
    PrivateKey2.prototype.toAddress = function(network, type2) {
      var pubkey = this.toPublicKey();
      return Address2.fromPublicKey(pubkey, network || this.network, type2);
    };
    PrivateKey2.prototype.toObject = PrivateKey2.prototype.toJSON = function toObject2() {
      return {
        bn: this.bn.toString("hex"),
        compressed: this.compressed,
        network: this.network.toString()
      };
    };
    PrivateKey2.prototype.inspect = function() {
      var uncompressed = !this.compressed ? ", uncompressed" : "";
      return "<PrivateKey: " + this.toString() + ", network: " + this.network + uncompressed + ">";
    };
    privatekey = PrivateKey2;
    return privatekey;
  }
  var publickey;
  var hasRequiredPublickey;
  function requirePublickey() {
    if (hasRequiredPublickey)
      return publickey;
    hasRequiredPublickey = 1;
    var BN2 = bn$2;
    var Point2 = point$1;
    var Hash2 = hashExports;
    var JSUtil2 = js$1;
    var Network2 = networks_1;
    var _2 = lodashExports;
    var $2 = preconditions;
    function PublicKey2(data2, extra) {
      if (!(this instanceof PublicKey2)) {
        return new PublicKey2(data2, extra);
      }
      $2.checkArgument(data2, "First argument is required, please include public key data.");
      if (data2 instanceof PublicKey2) {
        return data2;
      }
      extra = extra || {};
      var info = this._classifyArgs(data2, extra);
      info.point.validate();
      JSUtil2.defineImmutable(this, {
        point: info.point,
        compressed: info.compressed,
        network: info.network || Network2.defaultNetwork
      });
      return this;
    }
    PublicKey2.prototype._classifyArgs = function(data2, extra) {
      var info = {
        compressed: _2.isUndefined(extra.compressed) || extra.compressed
      };
      if (data2 instanceof Point2) {
        info.point = data2;
      } else if (data2.x && data2.y) {
        info = PublicKey2._transformObject(data2);
      } else if (typeof data2 === "string") {
        info = PublicKey2._transformDER(buffer$2.Buffer.from(data2, "hex"));
      } else if (PublicKey2._isBuffer(data2)) {
        info = PublicKey2._transformDER(data2);
      } else if (PublicKey2._isPrivateKey(data2)) {
        info = PublicKey2._transformPrivateKey(data2);
      } else {
        throw new TypeError("First argument is an unrecognized data format.");
      }
      if (!info.network) {
        info.network = _2.isUndefined(extra.network) ? void 0 : Network2.get(extra.network);
      }
      return info;
    };
    PublicKey2._isPrivateKey = function(param) {
      var PrivateKey2 = requirePrivatekey();
      return param instanceof PrivateKey2;
    };
    PublicKey2._isBuffer = function(param) {
      return param instanceof buffer$2.Buffer || param instanceof Uint8Array;
    };
    PublicKey2._transformPrivateKey = function(privkey) {
      $2.checkArgument(PublicKey2._isPrivateKey(privkey), "Must be an instance of PrivateKey");
      var info = {};
      info.point = Point2.getG().mul(privkey.bn);
      info.compressed = privkey.compressed;
      info.network = privkey.network;
      return info;
    };
    PublicKey2._transformDER = function(buf, strict) {
      $2.checkArgument(PublicKey2._isBuffer(buf), "Must be a hex buffer of DER encoded public key");
      var info = {};
      strict = _2.isUndefined(strict) ? true : strict;
      var x;
      var y;
      var xbuf;
      var ybuf;
      if (buf[0] === 4 || !strict && (buf[0] === 6 || buf[0] === 7)) {
        xbuf = buf.slice(1, 33);
        ybuf = buf.slice(33, 65);
        if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {
          throw new TypeError("Length of x and y must be 32 bytes");
        }
        x = new BN2(xbuf);
        y = new BN2(ybuf);
        info.point = new Point2(x, y);
        info.compressed = false;
      } else if (buf[0] === 3) {
        xbuf = buf.slice(1);
        x = new BN2(xbuf);
        info = PublicKey2._transformX(true, x);
        info.compressed = true;
      } else if (buf[0] === 2) {
        xbuf = buf.slice(1);
        x = new BN2(xbuf);
        info = PublicKey2._transformX(false, x);
        info.compressed = true;
      } else {
        throw new TypeError("Invalid DER format public key");
      }
      return info;
    };
    PublicKey2._transformX = function(odd, x) {
      $2.checkArgument(typeof odd === "boolean", "Must specify whether y is odd or not (true or false)");
      var info = {};
      info.point = Point2.fromX(odd, x);
      return info;
    };
    PublicKey2._transformObject = function(json) {
      var x = new BN2(json.x, "hex");
      var y = new BN2(json.y, "hex");
      var point2 = new Point2(x, y);
      return new PublicKey2(point2, {
        compressed: json.compressed
      });
    };
    PublicKey2.fromPrivateKey = function(privkey) {
      $2.checkArgument(PublicKey2._isPrivateKey(privkey), "Must be an instance of PrivateKey");
      var info = PublicKey2._transformPrivateKey(privkey);
      return new PublicKey2(info.point, {
        compressed: info.compressed,
        network: info.network
      });
    };
    PublicKey2.fromDER = PublicKey2.fromBuffer = function(buf, strict) {
      $2.checkArgument(PublicKey2._isBuffer(buf), "Must be a hex buffer of DER encoded public key");
      var info = PublicKey2._transformDER(buf, strict);
      return new PublicKey2(info.point, {
        compressed: info.compressed
      });
    };
    PublicKey2.fromPoint = function(point2, compressed) {
      $2.checkArgument(point2 instanceof Point2, "First argument must be an instance of Point.");
      return new PublicKey2(point2, {
        compressed
      });
    };
    PublicKey2.fromString = function(str, encoding) {
      var buf = buffer$2.Buffer.from(str, encoding || "hex");
      var info = PublicKey2._transformDER(buf);
      return new PublicKey2(info.point, {
        compressed: info.compressed
      });
    };
    PublicKey2.fromX = function(odd, x) {
      var info = PublicKey2._transformX(odd, x);
      return new PublicKey2(info.point, {
        compressed: info.compressed
      });
    };
    PublicKey2.getValidationError = function(data2) {
      var error;
      try {
        new PublicKey2(data2);
      } catch (e) {
        error = e;
      }
      return error;
    };
    PublicKey2.isValid = function(data2) {
      return !PublicKey2.getValidationError(data2);
    };
    PublicKey2.prototype.toObject = PublicKey2.prototype.toJSON = function toObject2() {
      return {
        x: this.point.getX().toString("hex", 2),
        y: this.point.getY().toString("hex", 2),
        compressed: this.compressed
      };
    };
    PublicKey2.prototype.toBuffer = PublicKey2.prototype.toDER = function() {
      var x = this.point.getX();
      var y = this.point.getY();
      var xbuf = x.toBuffer({
        size: 32
      });
      var ybuf = y.toBuffer({
        size: 32
      });
      var prefix;
      if (!this.compressed) {
        prefix = buffer$2.Buffer.from([4]);
        return buffer$2.Buffer.concat([prefix, xbuf, ybuf]);
      } else {
        var odd = ybuf[ybuf.length - 1] % 2;
        if (odd) {
          prefix = buffer$2.Buffer.from([3]);
        } else {
          prefix = buffer$2.Buffer.from([2]);
        }
        return buffer$2.Buffer.concat([prefix, xbuf]);
      }
    };
    PublicKey2.prototype._getID = function _getID() {
      return Hash2.sha256ripemd160(this.toBuffer());
    };
    PublicKey2.prototype.toAddress = function(network, type2) {
      var Address2 = requireAddress();
      return Address2.fromPublicKey(this, network || this.network, type2);
    };
    PublicKey2.prototype.toString = function() {
      return this.toDER().toString("hex");
    };
    PublicKey2.prototype.inspect = function() {
      return "<PublicKey: " + this.toString() + (this.compressed ? "" : ", uncompressed") + ">";
    };
    publickey = PublicKey2;
    return publickey;
  }
  var ecdsa;
  var hasRequiredEcdsa;
  function requireEcdsa() {
    if (hasRequiredEcdsa)
      return ecdsa;
    hasRequiredEcdsa = 1;
    var BN2 = bn$2;
    var Point2 = point$1;
    var Signature2 = signature$2;
    var PublicKey2 = requirePublickey();
    var Random2 = random$1;
    var Hash2 = hashExports;
    var BufferUtil2 = bufferExports;
    var _2 = lodashExports;
    var $2 = preconditions;
    var ECDSA2 = function ECDSA3(obj) {
      if (!(this instanceof ECDSA3)) {
        return new ECDSA3(obj);
      }
      if (obj) {
        this.set(obj);
      }
    };
    ECDSA2.prototype.set = function(obj) {
      this.hashbuf = obj.hashbuf || this.hashbuf;
      this.endian = obj.endian || this.endian;
      this.privkey = obj.privkey || this.privkey;
      this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);
      this.sig = obj.sig || this.sig;
      this.k = obj.k || this.k;
      this.verified = obj.verified || this.verified;
      return this;
    };
    ECDSA2.prototype.privkey2pubkey = function() {
      this.pubkey = this.privkey.toPublicKey();
    };
    ECDSA2.prototype.calci = function() {
      for (var i2 = 0; i2 < 4; i2++) {
        this.sig.i = i2;
        var Qprime;
        try {
          Qprime = this.toPublicKey();
        } catch (e) {
          console.error(e);
          continue;
        }
        if (Qprime.point.eq(this.pubkey.point)) {
          this.sig.compressed = this.pubkey.compressed;
          return this;
        }
      }
      this.sig.i = void 0;
      throw new Error("Unable to find valid recovery factor");
    };
    ECDSA2.fromString = function(str) {
      var obj = JSON.parse(str);
      return new ECDSA2(obj);
    };
    ECDSA2.prototype.randomK = function() {
      var N = Point2.getN();
      var k2;
      do {
        k2 = BN2.fromBuffer(Random2.getRandomBuffer(32));
      } while (!(k2.lt(N) && k2.gt(BN2.Zero)));
      this.k = k2;
      return this;
    };
    ECDSA2.prototype.deterministicK = function(badrs) {
      if (_2.isUndefined(badrs)) {
        badrs = 0;
      }
      var v = buffer$2.Buffer.alloc(32);
      v.fill(1);
      var k2 = buffer$2.Buffer.alloc(32);
      k2.fill(0);
      var x = this.privkey.bn.toBuffer({
        size: 32
      });
      var hashbuf = this.endian === "little" ? BufferUtil2.reverse(this.hashbuf) : this.hashbuf;
      k2 = Hash2.sha256hmac(buffer$2.Buffer.concat([v, buffer$2.Buffer.from([0]), x, hashbuf]), k2);
      v = Hash2.sha256hmac(v, k2);
      k2 = Hash2.sha256hmac(buffer$2.Buffer.concat([v, buffer$2.Buffer.from([1]), x, hashbuf]), k2);
      v = Hash2.sha256hmac(v, k2);
      v = Hash2.sha256hmac(v, k2);
      var T = BN2.fromBuffer(v);
      var N = Point2.getN();
      for (var i2 = 0; i2 < badrs || !(T.lt(N) && T.gt(BN2.Zero)); i2++) {
        k2 = Hash2.sha256hmac(buffer$2.Buffer.concat([v, buffer$2.Buffer.from([0])]), k2);
        v = Hash2.sha256hmac(v, k2);
        v = Hash2.sha256hmac(v, k2);
        T = BN2.fromBuffer(v);
      }
      this.k = T;
      return this;
    };
    ECDSA2.prototype.toPublicKey = function() {
      var i2 = this.sig.i;
      $2.checkArgument(i2 === 0 || i2 === 1 || i2 === 2 || i2 === 3, new Error("i must be equal to 0, 1, 2, or 3"));
      var e = BN2.fromBuffer(this.hashbuf);
      var r2 = this.sig.r;
      var s2 = this.sig.s;
      var isYOdd = i2 & 1;
      var isSecondKey = i2 >> 1;
      var n2 = Point2.getN();
      var G2 = Point2.getG();
      var x = isSecondKey ? r2.add(n2) : r2;
      var R = Point2.fromX(isYOdd, x);
      var nR = R.mul(n2);
      if (!nR.isInfinity()) {
        throw new Error("nR is not a valid curve point");
      }
      var eNeg = e.neg().umod(n2);
      var rInv = r2.invm(n2);
      var Q = R.mul(s2).add(G2.mul(eNeg)).mul(rInv);
      var pubkey = PublicKey2.fromPoint(Q, this.sig.compressed);
      return pubkey;
    };
    ECDSA2.prototype.sigError = function() {
      if (!BufferUtil2.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {
        return "hashbuf must be a 32 byte buffer";
      }
      var r2 = this.sig.r;
      var s2 = this.sig.s;
      if (!(r2.gt(BN2.Zero) && r2.lt(Point2.getN())) || !(s2.gt(BN2.Zero) && s2.lt(Point2.getN()))) {
        return "r and s not in range";
      }
      var e = BN2.fromBuffer(this.hashbuf, this.endian ? {
        endian: this.endian
      } : void 0);
      var n2 = Point2.getN();
      var sinv = s2.invm(n2);
      var u1 = sinv.mul(e).umod(n2);
      var u2 = sinv.mul(r2).umod(n2);
      var p2 = Point2.getG().mulAdd(u1, this.pubkey.point, u2);
      if (p2.isInfinity()) {
        return "p is infinity";
      }
      if (p2.getX().umod(n2).cmp(r2) !== 0) {
        return "Invalid signature";
      } else {
        return false;
      }
    };
    ECDSA2.toLowS = function(s2) {
      if (s2.gt(BN2.fromBuffer(buffer$2.Buffer.from("7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0", "hex")))) {
        s2 = Point2.getN().sub(s2);
      }
      return s2;
    };
    ECDSA2.prototype._findSignature = function(d, e) {
      var N = Point2.getN();
      var G2 = Point2.getG();
      var badrs = 0;
      var k2, Q, r2, s2;
      do {
        if (!this.k || badrs > 0) {
          this.deterministicK(badrs);
        }
        badrs++;
        k2 = this.k;
        Q = G2.mul(k2);
        r2 = Q.x.umod(N);
        s2 = k2.invm(N).mul(e.add(d.mul(r2))).umod(N);
      } while (r2.cmp(BN2.Zero) <= 0 || s2.cmp(BN2.Zero) <= 0);
      s2 = ECDSA2.toLowS(s2);
      return {
        s: s2,
        r: r2
      };
    };
    ECDSA2.prototype.sign = function() {
      var hashbuf = this.hashbuf;
      var privkey = this.privkey;
      var d = privkey.bn;
      $2.checkState(hashbuf && privkey && d, new Error("invalid parameters"));
      $2.checkState(BufferUtil2.isBuffer(hashbuf) && hashbuf.length === 32, new Error("hashbuf must be a 32 byte buffer"));
      var e = BN2.fromBuffer(hashbuf, this.endian ? {
        endian: this.endian
      } : void 0);
      var obj = this._findSignature(d, e);
      obj.compressed = this.pubkey.compressed;
      this.sig = new Signature2(obj);
      return this;
    };
    ECDSA2.prototype.signRandomK = function() {
      this.randomK();
      return this.sign();
    };
    ECDSA2.prototype.toString = function() {
      var obj = {};
      if (this.hashbuf) {
        obj.hashbuf = this.hashbuf.toString("hex");
      }
      if (this.privkey) {
        obj.privkey = this.privkey.toString();
      }
      if (this.pubkey) {
        obj.pubkey = this.pubkey.toString();
      }
      if (this.sig) {
        obj.sig = this.sig.toString();
      }
      if (this.k) {
        obj.k = this.k.toString();
      }
      return JSON.stringify(obj);
    };
    ECDSA2.prototype.verify = function() {
      if (!this.sigError()) {
        this.verified = true;
      } else {
        this.verified = false;
      }
      return this;
    };
    ECDSA2.sign = function(hashbuf, privkey, endian) {
      return ECDSA2().set({
        hashbuf,
        endian,
        privkey
      }).sign().sig;
    };
    ECDSA2.verify = function(hashbuf, sig, pubkey, endian) {
      return ECDSA2().set({
        hashbuf,
        endian,
        sig,
        pubkey
      }).verify().verified;
    };
    ecdsa = ECDSA2;
    return ecdsa;
  }
  var BufferWriter$4 = bufferwriter;
  var BufferReader$3 = bufferreader;
  var BN$3 = bn$2;
  var Varint = function Varint2(buf) {
    if (!(this instanceof Varint2))
      return new Varint2(buf);
    if (buffer$2.Buffer.isBuffer(buf)) {
      this.buf = buf;
    } else if (typeof buf === "number") {
      var num = buf;
      this.fromNumber(num);
    } else if (buf instanceof BN$3) {
      var bn2 = buf;
      this.fromBN(bn2);
    } else if (buf) {
      var obj = buf;
      this.set(obj);
    }
  };
  Varint.prototype.set = function(obj) {
    this.buf = obj.buf || this.buf;
    return this;
  };
  Varint.prototype.fromString = function(str) {
    this.set({
      buf: buffer$2.Buffer.from(str, "hex")
    });
    return this;
  };
  Varint.prototype.toString = function() {
    return this.buf.toString("hex");
  };
  Varint.prototype.fromBuffer = function(buf) {
    this.buf = buf;
    return this;
  };
  Varint.prototype.fromBufferReader = function(br) {
    this.buf = br.readVarintBuf();
    return this;
  };
  Varint.prototype.fromBN = function(bn2) {
    this.buf = BufferWriter$4().writeVarintBN(bn2).concat();
    return this;
  };
  Varint.prototype.fromNumber = function(num) {
    this.buf = BufferWriter$4().writeVarintNum(num).concat();
    return this;
  };
  Varint.prototype.toBuffer = function() {
    return this.buf;
  };
  Varint.prototype.toBN = function() {
    return BufferReader$3(this.buf).readVarintBN();
  };
  Varint.prototype.toNumber = function() {
    return BufferReader$3(this.buf).readVarintNum();
  };
  var varint = Varint;
  var block$1 = { exports: {} };
  var _$4 = lodashExports;
  var BN$2 = bn$2;
  var BufferUtil$2 = bufferExports;
  var BufferReader$2 = bufferreader;
  var BufferWriter$3 = bufferwriter;
  var Hash$a = hashExports;
  var $$3 = preconditions;
  var GENESIS_BITS = 486604799;
  var BlockHeader$2 = function BlockHeader2(arg) {
    if (!(this instanceof BlockHeader2)) {
      return new BlockHeader2(arg);
    }
    var info = BlockHeader2._from(arg);
    this.version = info.version;
    this.prevHash = info.prevHash;
    this.merkleRoot = info.merkleRoot;
    this.time = info.time;
    this.timestamp = info.time;
    this.bits = info.bits;
    this.nonce = info.nonce;
    if (info.hash) {
      $$3.checkState(
        this.hash === info.hash,
        "Argument object hash property does not match block hash."
      );
    }
    return this;
  };
  BlockHeader$2._from = function _from(arg) {
    var info = {};
    if (BufferUtil$2.isBuffer(arg)) {
      info = BlockHeader$2._fromBufferReader(BufferReader$2(arg));
    } else if (_$4.isObject(arg)) {
      info = BlockHeader$2._fromObject(arg);
    } else {
      throw new TypeError("Unrecognized argument for BlockHeader");
    }
    return info;
  };
  BlockHeader$2._fromObject = function _fromObject(data2) {
    $$3.checkArgument(data2, "data is required");
    var prevHash = data2.prevHash;
    var merkleRoot = data2.merkleRoot;
    if (_$4.isString(data2.prevHash)) {
      prevHash = BufferUtil$2.reverse(buffer$2.Buffer.from(data2.prevHash, "hex"));
    }
    if (_$4.isString(data2.merkleRoot)) {
      merkleRoot = BufferUtil$2.reverse(buffer$2.Buffer.from(data2.merkleRoot, "hex"));
    }
    var info = {
      hash: data2.hash,
      version: data2.version,
      prevHash,
      merkleRoot,
      time: data2.time,
      timestamp: data2.time,
      bits: data2.bits,
      nonce: data2.nonce
    };
    return info;
  };
  BlockHeader$2.fromObject = function fromObject(obj) {
    var info = BlockHeader$2._fromObject(obj);
    return new BlockHeader$2(info);
  };
  BlockHeader$2.fromRawBlock = function fromRawBlock(data2) {
    if (!BufferUtil$2.isBuffer(data2)) {
      data2 = buffer$2.Buffer.from(data2, "binary");
    }
    var br = BufferReader$2(data2);
    br.pos = BlockHeader$2.Constants.START_OF_HEADER;
    var info = BlockHeader$2._fromBufferReader(br);
    return new BlockHeader$2(info);
  };
  BlockHeader$2.fromBuffer = function fromBuffer(buf) {
    var info = BlockHeader$2._fromBufferReader(BufferReader$2(buf));
    return new BlockHeader$2(info);
  };
  BlockHeader$2.fromString = function fromString(str) {
    var buf = buffer$2.Buffer.from(str, "hex");
    return BlockHeader$2.fromBuffer(buf);
  };
  BlockHeader$2._fromBufferReader = function _fromBufferReader(br) {
    var info = {};
    info.version = br.readInt32LE();
    info.prevHash = br.read(32);
    info.merkleRoot = br.read(32);
    info.time = br.readUInt32LE();
    info.bits = br.readUInt32LE();
    info.nonce = br.readUInt32LE();
    return info;
  };
  BlockHeader$2.fromBufferReader = function fromBufferReader(br) {
    var info = BlockHeader$2._fromBufferReader(br);
    return new BlockHeader$2(info);
  };
  BlockHeader$2.prototype.toObject = BlockHeader$2.prototype.toJSON = function toObject2() {
    return {
      hash: this.hash,
      version: this.version,
      prevHash: BufferUtil$2.reverse(this.prevHash).toString("hex"),
      merkleRoot: BufferUtil$2.reverse(this.merkleRoot).toString("hex"),
      time: this.time,
      bits: this.bits,
      nonce: this.nonce
    };
  };
  BlockHeader$2.prototype.toBuffer = function toBuffer2() {
    return this.toBufferWriter().concat();
  };
  BlockHeader$2.prototype.toString = function toString() {
    return this.toBuffer().toString("hex");
  };
  BlockHeader$2.prototype.toBufferWriter = function toBufferWriter(bw) {
    if (!bw) {
      bw = new BufferWriter$3();
    }
    bw.writeInt32LE(this.version);
    bw.write(this.prevHash);
    bw.write(this.merkleRoot);
    bw.writeUInt32LE(this.time);
    bw.writeUInt32LE(this.bits);
    bw.writeUInt32LE(this.nonce);
    return bw;
  };
  BlockHeader$2.prototype.getTargetDifficulty = function getTargetDifficulty(bits) {
    bits = bits || this.bits;
    var target = new BN$2(bits & 16777215);
    var mov = 8 * ((bits >>> 24) - 3);
    while (mov-- > 0) {
      target = target.mul(new BN$2(2));
    }
    return target;
  };
  BlockHeader$2.prototype.getDifficulty = function getDifficulty() {
    var difficulty1TargetBN = this.getTargetDifficulty(GENESIS_BITS).mul(new BN$2(Math.pow(10, 8)));
    var currentTargetBN = this.getTargetDifficulty();
    var difficultyString = difficulty1TargetBN.div(currentTargetBN).toString(10);
    var decimalPos = difficultyString.length - 8;
    difficultyString = difficultyString.slice(0, decimalPos) + "." + difficultyString.slice(decimalPos);
    return parseFloat(difficultyString);
  };
  BlockHeader$2.prototype._getHash = function hash2() {
    var buf = this.toBuffer();
    return Hash$a.sha256sha256(buf);
  };
  var idProperty$1 = {
    configurable: false,
    enumerable: true,
    /**
     * @returns {string} - The big endian hash buffer of the header
     */
    get: function() {
      if (!this._id) {
        this._id = BufferReader$2(this._getHash()).readReverse().toString("hex");
      }
      return this._id;
    },
    set: _$4.noop
  };
  Object.defineProperty(BlockHeader$2.prototype, "id", idProperty$1);
  Object.defineProperty(BlockHeader$2.prototype, "hash", idProperty$1);
  BlockHeader$2.prototype.validTimestamp = function validTimestamp() {
    var currentTime = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
    if (this.time > currentTime + BlockHeader$2.Constants.MAX_TIME_OFFSET) {
      return false;
    }
    return true;
  };
  BlockHeader$2.prototype.validProofOfWork = function validProofOfWork() {
    var pow3 = new BN$2(this.id, "hex");
    var target = this.getTargetDifficulty();
    if (pow3.cmp(target) > 0) {
      return false;
    }
    return true;
  };
  BlockHeader$2.prototype.inspect = function inspect() {
    return "<BlockHeader " + this.id + ">";
  };
  BlockHeader$2.Constants = {
    START_OF_HEADER: 8,
    // Start buffer position in raw block data
    MAX_TIME_OFFSET: 2 * 60 * 60,
    // The max a timestamp can be in the future
    LARGEST_HASH: new BN$2("10000000000000000000000000000000000000000000000000000000000000000", "hex")
  };
  var blockheader = BlockHeader$2;
  var _$3 = lodashExports;
  var BlockHeader$1 = blockheader;
  var BN$1 = bn$2;
  var BufferUtil$1 = bufferExports;
  var BufferReader$1 = bufferreader;
  var BufferWriter$2 = bufferwriter;
  var Hash$9 = hashExports;
  var Transaction$1 = requireTransaction();
  var $$2 = preconditions;
  function Block(arg) {
    if (!(this instanceof Block)) {
      return new Block(arg);
    }
    _$3.extend(this, Block._from(arg));
    return this;
  }
  Block.MAX_BLOCK_SIZE = 1e6;
  Block._from = function _from(arg) {
    var info = {};
    if (BufferUtil$1.isBuffer(arg)) {
      info = Block._fromBufferReader(BufferReader$1(arg));
    } else if (_$3.isObject(arg)) {
      info = Block._fromObject(arg);
    } else {
      throw new TypeError("Unrecognized argument for Block");
    }
    return info;
  };
  Block._fromObject = function _fromObject(data2) {
    var transactions = [];
    data2.transactions.forEach(function(tx) {
      if (tx instanceof Transaction$1) {
        transactions.push(tx);
      } else {
        transactions.push(Transaction$1().fromObject(tx));
      }
    });
    var info = {
      header: BlockHeader$1.fromObject(data2.header),
      transactions
    };
    return info;
  };
  Block.fromObject = function fromObject(obj) {
    var info = Block._fromObject(obj);
    return new Block(info);
  };
  Block._fromBufferReader = function _fromBufferReader(br) {
    var info = {};
    $$2.checkState(!br.finished(), "No block data received");
    info.header = BlockHeader$1.fromBufferReader(br);
    var transactions = br.readVarintNum();
    info.transactions = [];
    for (var i2 = 0; i2 < transactions; i2++) {
      info.transactions.push(Transaction$1().fromBufferReader(br));
    }
    return info;
  };
  Block.fromBufferReader = function fromBufferReader(br) {
    $$2.checkArgument(br, "br is required");
    var info = Block._fromBufferReader(br);
    return new Block(info);
  };
  Block.fromBuffer = function fromBuffer(buf) {
    return Block.fromBufferReader(new BufferReader$1(buf));
  };
  Block.fromString = function fromString(str) {
    var buf = buffer$2.Buffer.from(str, "hex");
    return Block.fromBuffer(buf);
  };
  Block.fromRawBlock = function fromRawBlock(data2) {
    if (!BufferUtil$1.isBuffer(data2)) {
      data2 = buffer$2.Buffer.from(data2, "binary");
    }
    var br = BufferReader$1(data2);
    br.pos = Block.Values.START_OF_BLOCK;
    var info = Block._fromBufferReader(br);
    return new Block(info);
  };
  Block.prototype.toObject = Block.prototype.toJSON = function toObject2() {
    var transactions = [];
    this.transactions.forEach(function(tx) {
      transactions.push(tx.toObject());
    });
    return {
      header: this.header.toObject(),
      transactions
    };
  };
  Block.prototype.toBuffer = function toBuffer2() {
    return this.toBufferWriter().concat();
  };
  Block.prototype.toString = function toString() {
    return this.toBuffer().toString("hex");
  };
  Block.prototype.toBufferWriter = function toBufferWriter(bw) {
    if (!bw) {
      bw = new BufferWriter$2();
    }
    bw.write(this.header.toBuffer());
    bw.writeVarintNum(this.transactions.length);
    for (var i2 = 0; i2 < this.transactions.length; i2++) {
      this.transactions[i2].toBufferWriter(bw);
    }
    return bw;
  };
  Block.prototype.getTransactionHashes = function getTransactionHashes() {
    var hashes = [];
    if (this.transactions.length === 0) {
      return [Block.Values.NULL_HASH];
    }
    for (var t = 0; t < this.transactions.length; t++) {
      hashes.push(this.transactions[t]._getHash());
    }
    return hashes;
  };
  Block.prototype.getMerkleTree = function getMerkleTree() {
    var tree = this.getTransactionHashes();
    var j = 0;
    for (var size = this.transactions.length; size > 1; size = Math.floor((size + 1) / 2)) {
      for (var i2 = 0; i2 < size; i2 += 2) {
        var i22 = Math.min(i2 + 1, size - 1);
        var buf = buffer$2.Buffer.concat([tree[j + i2], tree[j + i22]]);
        tree.push(Hash$9.sha256sha256(buf));
      }
      j += size;
    }
    return tree;
  };
  Block.prototype.getMerkleRoot = function getMerkleRoot() {
    var tree = this.getMerkleTree();
    return tree[tree.length - 1];
  };
  Block.prototype.validMerkleRoot = function validMerkleRoot() {
    var h = new BN$1(this.header.merkleRoot.toString("hex"), "hex");
    var c = new BN$1(this.getMerkleRoot().toString("hex"), "hex");
    if (h.cmp(c) !== 0) {
      return false;
    }
    return true;
  };
  Block.prototype._getHash = function() {
    return this.header._getHash();
  };
  var idProperty = {
    configurable: false,
    enumerable: true,
    /**
     * @returns {string} - The big endian hash buffer of the header
     */
    get: function() {
      if (!this._id) {
        this._id = this.header.id;
      }
      return this._id;
    },
    set: _$3.noop
  };
  Object.defineProperty(Block.prototype, "id", idProperty);
  Object.defineProperty(Block.prototype, "hash", idProperty);
  Block.prototype.inspect = function inspect() {
    return "<Block " + this.id + ">";
  };
  Block.Values = {
    START_OF_BLOCK: 8,
    // Start of block in raw block data
    NULL_HASH: buffer$2.Buffer.from("0000000000000000000000000000000000000000000000000000000000000000", "hex")
  };
  var block = Block;
  var _$2 = lodashExports;
  var BlockHeader = blockheader;
  var BufferUtil = bufferExports;
  var BufferReader = bufferreader;
  var BufferWriter$1 = bufferwriter;
  var Hash$8 = hashExports;
  var Transaction = requireTransaction();
  var errors$1 = errorsExports;
  var $$1 = preconditions;
  function MerkleBlock(arg) {
    if (!(this instanceof MerkleBlock)) {
      return new MerkleBlock(arg);
    }
    var info = {};
    if (BufferUtil.isBuffer(arg)) {
      info = MerkleBlock._fromBufferReader(BufferReader(arg));
    } else if (_$2.isObject(arg)) {
      var header;
      if (arg.header instanceof BlockHeader) {
        header = arg.header;
      } else {
        header = BlockHeader.fromObject(arg.header);
      }
      info = {
        /**
         * @name MerkleBlock#header
         * @type {BlockHeader}
         */
        header,
        /**
         * @name MerkleBlock#numTransactions
         * @type {Number}
         */
        numTransactions: arg.numTransactions,
        /**
         * @name MerkleBlock#hashes
         * @type {String[]}
         */
        hashes: arg.hashes,
        /**
         * @name MerkleBlock#flags
         * @type {Number[]}
         */
        flags: arg.flags
      };
    } else {
      throw new TypeError("Unrecognized argument for MerkleBlock");
    }
    _$2.extend(this, info);
    this._flagBitsUsed = 0;
    this._hashesUsed = 0;
    return this;
  }
  MerkleBlock.fromBuffer = function fromBuffer(buf) {
    return MerkleBlock.fromBufferReader(BufferReader(buf));
  };
  MerkleBlock.fromBufferReader = function fromBufferReader(br) {
    return new MerkleBlock(MerkleBlock._fromBufferReader(br));
  };
  MerkleBlock.prototype.toBuffer = function toBuffer2() {
    return this.toBufferWriter().concat();
  };
  MerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) {
    if (!bw) {
      bw = new BufferWriter$1();
    }
    bw.write(this.header.toBuffer());
    bw.writeUInt32LE(this.numTransactions);
    bw.writeVarintNum(this.hashes.length);
    for (var i2 = 0; i2 < this.hashes.length; i2++) {
      bw.write(buffer$2.Buffer.from(this.hashes[i2], "hex"));
    }
    bw.writeVarintNum(this.flags.length);
    for (i2 = 0; i2 < this.flags.length; i2++) {
      bw.writeUInt8(this.flags[i2]);
    }
    return bw;
  };
  MerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject2() {
    return {
      header: this.header.toObject(),
      numTransactions: this.numTransactions,
      hashes: this.hashes,
      flags: this.flags
    };
  };
  MerkleBlock.prototype.validMerkleTree = function validMerkleTree() {
    $$1.checkState(_$2.isArray(this.flags), "MerkleBlock flags is not an array");
    $$1.checkState(_$2.isArray(this.hashes), "MerkleBlock hashes is not an array");
    if (this.hashes.length > this.numTransactions) {
      return false;
    }
    if (this.flags.length * 8 < this.hashes.length) {
      return false;
    }
    var height = this._calcTreeHeight();
    var opts = { hashesUsed: 0, flagBitsUsed: 0 };
    var root2 = this._traverseMerkleTree(height, 0, opts);
    if (opts.hashesUsed !== this.hashes.length) {
      return false;
    }
    return BufferUtil.equals(root2, this.header.merkleRoot);
  };
  MerkleBlock.prototype.filterdTxsHash = function filterdTxsHash() {
    $$1.checkState(_$2.isArray(this.flags), "MerkleBlock flags is not an array");
    $$1.checkState(_$2.isArray(this.hashes), "MerkleBlock hashes is not an array");
    if (this.hashes.length > this.numTransactions) {
      throw new errors$1.MerkleBlock.InvalidMerkleTree();
    }
    if (this.flags.length * 8 < this.hashes.length) {
      throw new errors$1.MerkleBlock.InvalidMerkleTree();
    }
    if (this.hashes.length === 1) {
      return [];
    }
    var height = this._calcTreeHeight();
    var opts = { hashesUsed: 0, flagBitsUsed: 0 };
    var txs = this._traverseMerkleTree(height, 0, opts, true);
    if (opts.hashesUsed !== this.hashes.length) {
      throw new errors$1.MerkleBlock.InvalidMerkleTree();
    }
    return txs;
  };
  MerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts, checkForTxs) {
    opts = opts || {};
    opts.txs = opts.txs || [];
    opts.flagBitsUsed = opts.flagBitsUsed || 0;
    opts.hashesUsed = opts.hashesUsed || 0;
    var checkForTxs = checkForTxs || false;
    if (opts.flagBitsUsed > this.flags.length * 8) {
      return null;
    }
    var isParentOfMatch = this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7) & 1;
    if (depth === 0 || !isParentOfMatch) {
      if (opts.hashesUsed >= this.hashes.length) {
        return null;
      }
      var hash2 = this.hashes[opts.hashesUsed++];
      if (depth === 0 && isParentOfMatch) {
        opts.txs.push(hash2);
      }
      return buffer$2.Buffer.from(hash2, "hex");
    } else {
      var left = this._traverseMerkleTree(depth - 1, pos * 2, opts);
      var right = left;
      if (pos * 2 + 1 < this._calcTreeWidth(depth - 1)) {
        right = this._traverseMerkleTree(depth - 1, pos * 2 + 1, opts);
      }
      if (checkForTxs) {
        return opts.txs;
      } else {
        return Hash$8.sha256sha256(new buffer$2.Buffer.concat([left, right]));
      }
    }
  };
  MerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) {
    return this.numTransactions + (1 << height) - 1 >> height;
  };
  MerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() {
    var height = 0;
    while (this._calcTreeWidth(height) > 1) {
      height++;
    }
    return height;
  };
  MerkleBlock.prototype.hasTransaction = function hasTransaction(tx) {
    $$1.checkArgument(!_$2.isUndefined(tx), "tx cannot be undefined");
    $$1.checkArgument(
      tx instanceof Transaction || typeof tx === "string",
      'Invalid tx given, tx must be a "string" or "Transaction"'
    );
    var hash2 = tx;
    if (tx instanceof Transaction) {
      hash2 = BufferUtil.reverse(buffer$2.Buffer.from(tx.id, "hex")).toString("hex");
    }
    var txs = [];
    var height = this._calcTreeHeight();
    this._traverseMerkleTree(height, 0, { txs });
    return txs.indexOf(hash2) !== -1;
  };
  MerkleBlock._fromBufferReader = function _fromBufferReader(br) {
    $$1.checkState(!br.finished(), "No merkleblock data received");
    var info = {};
    info.header = BlockHeader.fromBufferReader(br);
    info.numTransactions = br.readUInt32LE();
    var numHashes = br.readVarintNum();
    info.hashes = [];
    for (var i2 = 0; i2 < numHashes; i2++) {
      info.hashes.push(br.read(32).toString("hex"));
    }
    var numFlags = br.readVarintNum();
    info.flags = [];
    for (i2 = 0; i2 < numFlags; i2++) {
      info.flags.push(br.readUInt8());
    }
    return info;
  };
  MerkleBlock.fromObject = function fromObject(obj) {
    return new MerkleBlock(obj);
  };
  var merkleblock = MerkleBlock;
  block$1.exports = block;
  block$1.exports.BlockHeader = blockheader;
  block$1.exports.MerkleBlock = merkleblock;
  var blockExports = block$1.exports;
  var hdpublickey;
  var hasRequiredHdpublickey;
  function requireHdpublickey() {
    if (hasRequiredHdpublickey)
      return hdpublickey;
    hasRequiredHdpublickey = 1;
    var _2 = lodashExports;
    var $2 = preconditions;
    var BN2 = bn$2;
    var Base582 = base58;
    var Base58Check2 = base58check;
    var Hash2 = hashExports;
    var HDPrivateKey = requireHdprivatekey();
    var Network2 = networks_1;
    var Point2 = point$1;
    var PublicKey2 = requirePublickey();
    var bitcoreErrors = errorsExports;
    var errors2 = bitcoreErrors;
    var hdErrors = bitcoreErrors.HDPublicKey;
    var assert2 = requireAssert();
    var JSUtil2 = js$1;
    var BufferUtil2 = bufferExports;
    function HDPublicKey(arg) {
      if (arg instanceof HDPublicKey) {
        return arg;
      }
      if (!(this instanceof HDPublicKey)) {
        return new HDPublicKey(arg);
      }
      if (arg) {
        if (_2.isString(arg) || BufferUtil2.isBuffer(arg)) {
          var error = HDPublicKey.getSerializedError(arg);
          if (!error) {
            return this._buildFromSerialized(arg);
          } else if (BufferUtil2.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {
            return this._buildFromSerialized(arg.toString());
          } else {
            if (error instanceof hdErrors.ArgumentIsPrivateExtended) {
              return new HDPrivateKey(arg).hdPublicKey;
            }
            throw error;
          }
        } else {
          if (_2.isObject(arg)) {
            if (arg instanceof HDPrivateKey) {
              return this._buildFromPrivate(arg);
            } else {
              return this._buildFromObject(arg);
            }
          } else {
            throw new hdErrors.UnrecognizedArgument(arg);
          }
        }
      } else {
        throw new hdErrors.MustSupplyArgument();
      }
    }
    HDPublicKey.isValidPath = function(arg) {
      if (_2.isString(arg)) {
        var indexes = HDPrivateKey._getDerivationIndexes(arg);
        return indexes !== null && _2.every(indexes, HDPublicKey.isValidPath);
      }
      if (_2.isNumber(arg)) {
        return arg >= 0 && arg < HDPublicKey.Hardened;
      }
      return false;
    };
    HDPublicKey.prototype.derive = function(arg, hardened) {
      return this.deriveChild(arg, hardened);
    };
    HDPublicKey.prototype.deriveChild = function(arg, hardened) {
      if (_2.isNumber(arg)) {
        return this._deriveWithNumber(arg, hardened);
      } else if (_2.isString(arg)) {
        return this._deriveFromString(arg);
      } else {
        throw new hdErrors.InvalidDerivationArgument(arg);
      }
    };
    HDPublicKey.prototype._deriveWithNumber = function(index, hardened) {
      if (index >= HDPublicKey.Hardened || hardened) {
        throw new hdErrors.InvalidIndexCantDeriveHardened();
      }
      if (index < 0) {
        throw new hdErrors.InvalidPath(index);
      }
      var indexBuffer = BufferUtil2.integerAsBuffer(index);
      var data2 = BufferUtil2.concat([this.publicKey.toBuffer(), indexBuffer]);
      var hash2 = Hash2.sha512hmac(data2, this._buffers.chainCode);
      var leftPart = BN2.fromBuffer(hash2.slice(0, 32), { size: 32 });
      var chainCode = hash2.slice(32, 64);
      var publicKey;
      try {
        publicKey = PublicKey2.fromPoint(Point2.getG().mul(leftPart).add(this.publicKey.point));
      } catch (e) {
        return this._deriveWithNumber(index + 1);
      }
      var derived = new HDPublicKey({
        network: this.network,
        depth: this.depth + 1,
        parentFingerPrint: this.fingerPrint,
        childIndex: index,
        chainCode,
        publicKey
      });
      return derived;
    };
    HDPublicKey.prototype._deriveFromString = function(path) {
      if (_2.includes(path, "'")) {
        throw new hdErrors.InvalidIndexCantDeriveHardened();
      } else if (!HDPublicKey.isValidPath(path)) {
        throw new hdErrors.InvalidPath(path);
      }
      var indexes = HDPrivateKey._getDerivationIndexes(path);
      var derived = indexes.reduce(function(prev, index) {
        return prev._deriveWithNumber(index);
      }, this);
      return derived;
    };
    HDPublicKey.isValidSerialized = function(data2, network) {
      return _2.isNull(HDPublicKey.getSerializedError(data2, network));
    };
    HDPublicKey.getSerializedError = function(data2, network) {
      if (!(_2.isString(data2) || BufferUtil2.isBuffer(data2))) {
        return new hdErrors.UnrecognizedArgument("expected buffer or string");
      }
      if (!Base582.validCharacters(data2)) {
        return new errors2.InvalidB58Char("(unknown)", data2);
      }
      try {
        data2 = Base58Check2.decode(data2);
      } catch (e) {
        return new errors2.InvalidB58Checksum(data2);
      }
      if (data2.length !== HDPublicKey.DataSize) {
        return new hdErrors.InvalidLength(data2);
      }
      if (!_2.isUndefined(network)) {
        var error = HDPublicKey._validateNetwork(data2, network);
        if (error) {
          return error;
        }
      }
      var version2 = BufferUtil2.integerFromBuffer(data2.slice(0, 4));
      if (version2 === Network2.livenet.xprivkey || version2 === Network2.testnet.xprivkey) {
        return new hdErrors.ArgumentIsPrivateExtended();
      }
      return null;
    };
    HDPublicKey._validateNetwork = function(data2, networkArg) {
      var network = Network2.get(networkArg);
      if (!network) {
        return new errors2.InvalidNetworkArgument(networkArg);
      }
      var version2 = data2.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);
      if (BufferUtil2.integerFromBuffer(version2) !== network.xpubkey) {
        return new errors2.InvalidNetwork(version2);
      }
      return null;
    };
    HDPublicKey.prototype._buildFromPrivate = function(arg) {
      var args = _2.clone(arg._buffers);
      var point2 = Point2.getG().mul(BN2.fromBuffer(args.privateKey));
      args.publicKey = Point2.pointToCompressed(point2);
      args.version = BufferUtil2.integerAsBuffer(Network2.get(BufferUtil2.integerFromBuffer(args.version)).xpubkey);
      args.privateKey = void 0;
      args.checksum = void 0;
      args.xprivkey = void 0;
      return this._buildFromBuffers(args);
    };
    HDPublicKey.prototype._buildFromObject = function(arg) {
      var buffers = {
        version: arg.network ? BufferUtil2.integerAsBuffer(Network2.get(arg.network).xpubkey) : arg.version,
        depth: _2.isNumber(arg.depth) ? BufferUtil2.integerAsSingleByteBuffer(arg.depth) : arg.depth,
        parentFingerPrint: _2.isNumber(arg.parentFingerPrint) ? BufferUtil2.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,
        childIndex: _2.isNumber(arg.childIndex) ? BufferUtil2.integerAsBuffer(arg.childIndex) : arg.childIndex,
        chainCode: _2.isString(arg.chainCode) ? buffer$2.Buffer.from(arg.chainCode, "hex") : arg.chainCode,
        publicKey: _2.isString(arg.publicKey) ? buffer$2.Buffer.from(arg.publicKey, "hex") : BufferUtil2.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),
        checksum: _2.isNumber(arg.checksum) ? BufferUtil2.integerAsBuffer(arg.checksum) : arg.checksum
      };
      return this._buildFromBuffers(buffers);
    };
    HDPublicKey.prototype._buildFromSerialized = function(arg) {
      var decoded = Base58Check2.decode(arg);
      var buffers = {
        version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),
        depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),
        parentFingerPrint: decoded.slice(
          HDPublicKey.ParentFingerPrintStart,
          HDPublicKey.ParentFingerPrintEnd
        ),
        childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),
        chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),
        publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),
        checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),
        xpubkey: arg
      };
      return this._buildFromBuffers(buffers);
    };
    HDPublicKey.prototype._buildFromBuffers = function(arg) {
      HDPublicKey._validateBufferArguments(arg);
      JSUtil2.defineImmutable(this, {
        _buffers: arg
      });
      var sequence = [
        arg.version,
        arg.depth,
        arg.parentFingerPrint,
        arg.childIndex,
        arg.chainCode,
        arg.publicKey
      ];
      var concat2 = BufferUtil2.concat(sequence);
      var checksum = Base58Check2.checksum(concat2);
      if (!arg.checksum || !arg.checksum.length) {
        arg.checksum = checksum;
      } else {
        if (arg.checksum.toString("hex") !== checksum.toString("hex")) {
          throw new errors2.InvalidB58Checksum(concat2, checksum);
        }
      }
      var network = Network2.get(BufferUtil2.integerFromBuffer(arg.version));
      var xpubkey;
      xpubkey = Base58Check2.encode(BufferUtil2.concat(sequence));
      arg.xpubkey = buffer$2.Buffer.from(xpubkey);
      var publicKey = new PublicKey2(arg.publicKey, { network });
      var size = HDPublicKey.ParentFingerPrintSize;
      var fingerPrint = Hash2.sha256ripemd160(publicKey.toBuffer()).slice(0, size);
      JSUtil2.defineImmutable(this, {
        xpubkey,
        network,
        depth: BufferUtil2.integerFromSingleByteBuffer(arg.depth),
        publicKey,
        fingerPrint
      });
      return this;
    };
    HDPublicKey._validateBufferArguments = function(arg) {
      var checkBuffer2 = function(name2, size) {
        var buff = arg[name2];
        assert2(BufferUtil2.isBuffer(buff), name2 + " argument is not a buffer, it's " + typeof buff);
        assert2(
          buff.length === size,
          name2 + " has not the expected size: found " + buff.length + ", expected " + size
        );
      };
      checkBuffer2("version", HDPublicKey.VersionSize);
      checkBuffer2("depth", HDPublicKey.DepthSize);
      checkBuffer2("parentFingerPrint", HDPublicKey.ParentFingerPrintSize);
      checkBuffer2("childIndex", HDPublicKey.ChildIndexSize);
      checkBuffer2("chainCode", HDPublicKey.ChainCodeSize);
      checkBuffer2("publicKey", HDPublicKey.PublicKeySize);
      if (arg.checksum && arg.checksum.length) {
        checkBuffer2("checksum", HDPublicKey.CheckSumSize);
      }
    };
    HDPublicKey.fromString = function(arg) {
      $2.checkArgument(_2.isString(arg), "No valid string was provided");
      return new HDPublicKey(arg);
    };
    HDPublicKey.fromObject = function(arg) {
      $2.checkArgument(_2.isObject(arg), "No valid argument was provided");
      return new HDPublicKey(arg);
    };
    HDPublicKey.prototype.toString = function() {
      return this.xpubkey;
    };
    HDPublicKey.prototype.inspect = function() {
      return "<HDPublicKey: " + this.xpubkey + ">";
    };
    HDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject2() {
      return {
        network: Network2.get(BufferUtil2.integerFromBuffer(this._buffers.version)).name,
        depth: BufferUtil2.integerFromSingleByteBuffer(this._buffers.depth),
        fingerPrint: BufferUtil2.integerFromBuffer(this.fingerPrint),
        parentFingerPrint: BufferUtil2.integerFromBuffer(this._buffers.parentFingerPrint),
        childIndex: BufferUtil2.integerFromBuffer(this._buffers.childIndex),
        chainCode: BufferUtil2.bufferToHex(this._buffers.chainCode),
        publicKey: this.publicKey.toString(),
        checksum: BufferUtil2.integerFromBuffer(this._buffers.checksum),
        xpubkey: this.xpubkey
      };
    };
    HDPublicKey.fromBuffer = function(arg) {
      return new HDPublicKey(arg);
    };
    HDPublicKey.prototype.toBuffer = function() {
      return BufferUtil2.copy(this._buffers.xpubkey);
    };
    HDPublicKey.Hardened = 2147483648;
    HDPublicKey.RootElementAlias = ["m", "M"];
    HDPublicKey.VersionSize = 4;
    HDPublicKey.DepthSize = 1;
    HDPublicKey.ParentFingerPrintSize = 4;
    HDPublicKey.ChildIndexSize = 4;
    HDPublicKey.ChainCodeSize = 32;
    HDPublicKey.PublicKeySize = 33;
    HDPublicKey.CheckSumSize = 4;
    HDPublicKey.DataSize = 78;
    HDPublicKey.SerializedByteSize = 82;
    HDPublicKey.VersionStart = 0;
    HDPublicKey.VersionEnd = HDPublicKey.VersionStart + HDPublicKey.VersionSize;
    HDPublicKey.DepthStart = HDPublicKey.VersionEnd;
    HDPublicKey.DepthEnd = HDPublicKey.DepthStart + HDPublicKey.DepthSize;
    HDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;
    HDPublicKey.ParentFingerPrintEnd = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;
    HDPublicKey.ChildIndexStart = HDPublicKey.ParentFingerPrintEnd;
    HDPublicKey.ChildIndexEnd = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;
    HDPublicKey.ChainCodeStart = HDPublicKey.ChildIndexEnd;
    HDPublicKey.ChainCodeEnd = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;
    HDPublicKey.PublicKeyStart = HDPublicKey.ChainCodeEnd;
    HDPublicKey.PublicKeyEnd = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;
    HDPublicKey.ChecksumStart = HDPublicKey.PublicKeyEnd;
    HDPublicKey.ChecksumEnd = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;
    assert2(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);
    assert2(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);
    hdpublickey = HDPublicKey;
    return hdpublickey;
  }
  var hdprivatekey;
  var hasRequiredHdprivatekey;
  function requireHdprivatekey() {
    if (hasRequiredHdprivatekey)
      return hdprivatekey;
    hasRequiredHdprivatekey = 1;
    var assert2 = requireAssert();
    var buffer2 = buffer$2;
    var _2 = lodashExports;
    var $2 = preconditions;
    var BN2 = bn$2;
    var Base582 = base58;
    var Base58Check2 = base58check;
    var Hash2 = hashExports;
    var Network2 = networks_1;
    var Point2 = point$1;
    var PrivateKey2 = requirePrivatekey();
    var Random2 = random$1;
    var errors2 = errorsExports;
    var hdErrors = errors2.HDPrivateKey;
    var BufferUtil2 = bufferExports;
    var JSUtil2 = js$1;
    var MINIMUM_ENTROPY_BITS = 128;
    var BITS_TO_BYTES = 1 / 8;
    var MAXIMUM_ENTROPY_BITS = 512;
    function HDPrivateKey(arg) {
      if (arg instanceof HDPrivateKey) {
        return arg;
      }
      if (!(this instanceof HDPrivateKey)) {
        return new HDPrivateKey(arg);
      }
      if (!arg) {
        return this._generateRandomly();
      }
      if (Network2.get(arg)) {
        return this._generateRandomly(arg);
      } else if (_2.isString(arg) || BufferUtil2.isBuffer(arg)) {
        if (HDPrivateKey.isValidSerialized(arg)) {
          this._buildFromSerialized(arg);
        } else if (JSUtil2.isValidJSON(arg)) {
          this._buildFromJSON(arg);
        } else if (BufferUtil2.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {
          this._buildFromSerialized(arg.toString());
        } else {
          throw HDPrivateKey.getSerializedError(arg);
        }
      } else if (_2.isObject(arg)) {
        this._buildFromObject(arg);
      } else {
        throw new hdErrors.UnrecognizedArgument(arg);
      }
    }
    HDPrivateKey.isValidPath = function(arg, hardened) {
      if (_2.isString(arg)) {
        var indexes = HDPrivateKey._getDerivationIndexes(arg);
        return indexes !== null && _2.every(indexes, HDPrivateKey.isValidPath);
      }
      if (_2.isNumber(arg)) {
        if (arg < HDPrivateKey.Hardened && hardened === true) {
          arg += HDPrivateKey.Hardened;
        }
        return arg >= 0 && arg < HDPrivateKey.MaxIndex;
      }
      return false;
    };
    HDPrivateKey._getDerivationIndexes = function(path) {
      var steps = path.split("/");
      if (_2.includes(HDPrivateKey.RootElementAlias, path)) {
        return [];
      }
      if (!_2.includes(HDPrivateKey.RootElementAlias, steps[0])) {
        return null;
      }
      var indexes = steps.slice(1).map(function(step) {
        var isHardened = step.slice(-1) === "'";
        if (isHardened) {
          step = step.slice(0, -1);
        }
        if (!step || step[0] === "-") {
          return NaN;
        }
        var index = +step;
        if (isHardened) {
          index += HDPrivateKey.Hardened;
        }
        return index;
      });
      return _2.some(indexes, isNaN) ? null : indexes;
    };
    HDPrivateKey.prototype.derive = function(arg, hardened) {
      return this.deriveNonCompliantChild(arg, hardened);
    };
    HDPrivateKey.prototype.deriveChild = function(arg, hardened) {
      if (_2.isNumber(arg)) {
        return this._deriveWithNumber(arg, hardened);
      } else if (_2.isString(arg)) {
        return this._deriveFromString(arg);
      } else {
        throw new hdErrors.InvalidDerivationArgument(arg);
      }
    };
    HDPrivateKey.prototype.deriveNonCompliantChild = function(arg, hardened) {
      if (_2.isNumber(arg)) {
        return this._deriveWithNumber(arg, hardened, true);
      } else if (_2.isString(arg)) {
        return this._deriveFromString(arg, true);
      } else {
        throw new hdErrors.InvalidDerivationArgument(arg);
      }
    };
    HDPrivateKey.prototype._deriveWithNumber = function(index, hardened, nonCompliant) {
      if (!HDPrivateKey.isValidPath(index, hardened)) {
        throw new hdErrors.InvalidPath(index);
      }
      hardened = index >= HDPrivateKey.Hardened ? true : hardened;
      if (index < HDPrivateKey.Hardened && hardened === true) {
        index += HDPrivateKey.Hardened;
      }
      var indexBuffer = BufferUtil2.integerAsBuffer(index);
      var data2;
      if (hardened && nonCompliant) {
        var nonZeroPadded = this.privateKey.bn.toBuffer();
        data2 = BufferUtil2.concat([buffer$2.Buffer.from([0]), nonZeroPadded, indexBuffer]);
      } else if (hardened) {
        var privateKeyBuffer = this.privateKey.bn.toBuffer({ size: 32 });
        assert2(privateKeyBuffer.length === 32, "length of private key buffer is expected to be 32 bytes");
        data2 = BufferUtil2.concat([buffer$2.Buffer.from([0]), privateKeyBuffer, indexBuffer]);
      } else {
        data2 = BufferUtil2.concat([this.publicKey.toBuffer(), indexBuffer]);
      }
      var hash2 = Hash2.sha512hmac(data2, this._buffers.chainCode);
      var leftPart = BN2.fromBuffer(hash2.slice(0, 32), {
        size: 32
      });
      var chainCode = hash2.slice(32, 64);
      var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point2.getN()).toBuffer({
        size: 32
      });
      if (!PrivateKey2.isValid(privateKey)) {
        return this._deriveWithNumber(index + 1, null, nonCompliant);
      }
      var derived = new HDPrivateKey({
        network: this.network,
        depth: this.depth + 1,
        parentFingerPrint: this.fingerPrint,
        childIndex: index,
        chainCode,
        privateKey
      });
      return derived;
    };
    HDPrivateKey.prototype._deriveFromString = function(path, nonCompliant) {
      if (!HDPrivateKey.isValidPath(path)) {
        throw new hdErrors.InvalidPath(path);
      }
      var indexes = HDPrivateKey._getDerivationIndexes(path);
      var derived = indexes.reduce(function(prev, index) {
        return prev._deriveWithNumber(index, null, nonCompliant);
      }, this);
      return derived;
    };
    HDPrivateKey.isValidSerialized = function(data2, network) {
      return !HDPrivateKey.getSerializedError(data2, network);
    };
    HDPrivateKey.getSerializedError = function(data2, network) {
      if (!(_2.isString(data2) || BufferUtil2.isBuffer(data2))) {
        return new hdErrors.UnrecognizedArgument("Expected string or buffer");
      }
      if (!Base582.validCharacters(data2)) {
        return new errors2.InvalidB58Char("(unknown)", data2);
      }
      try {
        data2 = Base58Check2.decode(data2);
      } catch (e) {
        return new errors2.InvalidB58Checksum(data2);
      }
      if (data2.length !== HDPrivateKey.DataLength) {
        return new hdErrors.InvalidLength(data2);
      }
      if (!_2.isUndefined(network)) {
        var error = HDPrivateKey._validateNetwork(data2, network);
        if (error) {
          return error;
        }
      }
      return null;
    };
    HDPrivateKey._validateNetwork = function(data2, networkArg) {
      var network = Network2.get(networkArg);
      if (!network) {
        return new errors2.InvalidNetworkArgument(networkArg);
      }
      var version2 = data2.slice(0, 4);
      if (BufferUtil2.integerFromBuffer(version2) !== network.xprivkey) {
        return new errors2.InvalidNetwork(version2);
      }
      return null;
    };
    HDPrivateKey.fromString = function(arg) {
      $2.checkArgument(_2.isString(arg), "No valid string was provided");
      return new HDPrivateKey(arg);
    };
    HDPrivateKey.fromObject = function(arg) {
      $2.checkArgument(_2.isObject(arg), "No valid argument was provided");
      return new HDPrivateKey(arg);
    };
    HDPrivateKey.prototype._buildFromJSON = function(arg) {
      return this._buildFromObject(JSON.parse(arg));
    };
    HDPrivateKey.prototype._buildFromObject = function(arg) {
      var buffers = {
        version: arg.network ? BufferUtil2.integerAsBuffer(Network2.get(arg.network).xprivkey) : arg.version,
        depth: _2.isNumber(arg.depth) ? BufferUtil2.integerAsSingleByteBuffer(arg.depth) : arg.depth,
        parentFingerPrint: _2.isNumber(arg.parentFingerPrint) ? BufferUtil2.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,
        childIndex: _2.isNumber(arg.childIndex) ? BufferUtil2.integerAsBuffer(arg.childIndex) : arg.childIndex,
        chainCode: _2.isString(arg.chainCode) ? buffer$2.Buffer.from(arg.chainCode, "hex") : arg.chainCode,
        privateKey: _2.isString(arg.privateKey) && JSUtil2.isHexa(arg.privateKey) ? buffer$2.Buffer.from(arg.privateKey, "hex") : arg.privateKey,
        checksum: arg.checksum ? arg.checksum.length ? arg.checksum : BufferUtil2.integerAsBuffer(arg.checksum) : void 0
      };
      return this._buildFromBuffers(buffers);
    };
    HDPrivateKey.prototype._buildFromSerialized = function(arg) {
      var decoded = Base58Check2.decode(arg);
      var buffers = {
        version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),
        depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),
        parentFingerPrint: decoded.slice(
          HDPrivateKey.ParentFingerPrintStart,
          HDPrivateKey.ParentFingerPrintEnd
        ),
        childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),
        chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),
        privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),
        checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),
        xprivkey: arg
      };
      return this._buildFromBuffers(buffers);
    };
    HDPrivateKey.prototype._generateRandomly = function(network) {
      return HDPrivateKey.fromSeed(Random2.getRandomBuffer(64), network);
    };
    HDPrivateKey.fromSeed = function(hexa, network) {
      if (JSUtil2.isHexaString(hexa)) {
        hexa = buffer$2.Buffer.from(hexa, "hex");
      }
      if (!buffer$2.Buffer.isBuffer(hexa)) {
        throw new hdErrors.InvalidEntropyArgument(hexa);
      }
      if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {
        throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);
      }
      if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {
        throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);
      }
      var hash2 = Hash2.sha512hmac(hexa, buffer$2.Buffer.from("Bitcoin seed"));
      return new HDPrivateKey({
        network: Network2.get(network) || Network2.defaultNetwork,
        depth: 0,
        parentFingerPrint: 0,
        childIndex: 0,
        privateKey: hash2.slice(0, 32),
        chainCode: hash2.slice(32, 64)
      });
    };
    HDPrivateKey.prototype._calcHDPublicKey = function() {
      if (!this._hdPublicKey) {
        var HDPublicKey = requireHdpublickey();
        this._hdPublicKey = new HDPublicKey(this);
      }
    };
    HDPrivateKey.prototype._buildFromBuffers = function(arg) {
      HDPrivateKey._validateBufferArguments(arg);
      JSUtil2.defineImmutable(this, {
        _buffers: arg
      });
      var sequence = [
        arg.version,
        arg.depth,
        arg.parentFingerPrint,
        arg.childIndex,
        arg.chainCode,
        BufferUtil2.emptyBuffer(1),
        arg.privateKey
      ];
      var concat2 = buffer2.Buffer.concat(sequence);
      if (!arg.checksum || !arg.checksum.length) {
        arg.checksum = Base58Check2.checksum(concat2);
      } else {
        if (arg.checksum.toString() !== Base58Check2.checksum(concat2).toString()) {
          throw new errors2.InvalidB58Checksum(concat2);
        }
      }
      var network = Network2.get(BufferUtil2.integerFromBuffer(arg.version));
      var xprivkey;
      xprivkey = Base58Check2.encode(buffer2.Buffer.concat(sequence));
      arg.xprivkey = buffer$2.Buffer.from(xprivkey);
      var privateKey = new PrivateKey2(BN2.fromBuffer(arg.privateKey), network);
      var publicKey = privateKey.toPublicKey();
      var size = HDPrivateKey.ParentFingerPrintSize;
      var fingerPrint = Hash2.sha256ripemd160(publicKey.toBuffer()).slice(0, size);
      JSUtil2.defineImmutable(this, {
        xprivkey,
        network,
        depth: BufferUtil2.integerFromSingleByteBuffer(arg.depth),
        privateKey,
        publicKey,
        fingerPrint
      });
      this._hdPublicKey = null;
      Object.defineProperty(this, "hdPublicKey", {
        configurable: false,
        enumerable: true,
        get: function() {
          this._calcHDPublicKey();
          return this._hdPublicKey;
        }
      });
      Object.defineProperty(this, "xpubkey", {
        configurable: false,
        enumerable: true,
        get: function() {
          this._calcHDPublicKey();
          return this._hdPublicKey.xpubkey;
        }
      });
      return this;
    };
    HDPrivateKey._validateBufferArguments = function(arg) {
      var checkBuffer2 = function(name2, size) {
        var buff = arg[name2];
        assert2(BufferUtil2.isBuffer(buff), name2 + " argument is not a buffer");
        assert2(
          buff.length === size,
          name2 + " has not the expected size: found " + buff.length + ", expected " + size
        );
      };
      checkBuffer2("version", HDPrivateKey.VersionSize);
      checkBuffer2("depth", HDPrivateKey.DepthSize);
      checkBuffer2("parentFingerPrint", HDPrivateKey.ParentFingerPrintSize);
      checkBuffer2("childIndex", HDPrivateKey.ChildIndexSize);
      checkBuffer2("chainCode", HDPrivateKey.ChainCodeSize);
      checkBuffer2("privateKey", HDPrivateKey.PrivateKeySize);
      if (arg.checksum && arg.checksum.length) {
        checkBuffer2("checksum", HDPrivateKey.CheckSumSize);
      }
    };
    HDPrivateKey.prototype.toString = function() {
      return this.xprivkey;
    };
    HDPrivateKey.prototype.inspect = function() {
      return "<HDPrivateKey: " + this.xprivkey + ">";
    };
    HDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject2() {
      return {
        network: Network2.get(BufferUtil2.integerFromBuffer(this._buffers.version), "xprivkey").name,
        depth: BufferUtil2.integerFromSingleByteBuffer(this._buffers.depth),
        fingerPrint: BufferUtil2.integerFromBuffer(this.fingerPrint),
        parentFingerPrint: BufferUtil2.integerFromBuffer(this._buffers.parentFingerPrint),
        childIndex: BufferUtil2.integerFromBuffer(this._buffers.childIndex),
        chainCode: BufferUtil2.bufferToHex(this._buffers.chainCode),
        privateKey: this.privateKey.toBuffer().toString("hex"),
        checksum: BufferUtil2.integerFromBuffer(this._buffers.checksum),
        xprivkey: this.xprivkey
      };
    };
    HDPrivateKey.fromBuffer = function(arg) {
      return new HDPrivateKey(arg.toString());
    };
    HDPrivateKey.prototype.toBuffer = function() {
      return BufferUtil2.copy(this._buffers.xprivkey);
    };
    HDPrivateKey.DefaultDepth = 0;
    HDPrivateKey.DefaultFingerprint = 0;
    HDPrivateKey.DefaultChildIndex = 0;
    HDPrivateKey.Hardened = 2147483648;
    HDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;
    HDPrivateKey.RootElementAlias = ["m", "M", "m'", "M'"];
    HDPrivateKey.VersionSize = 4;
    HDPrivateKey.DepthSize = 1;
    HDPrivateKey.ParentFingerPrintSize = 4;
    HDPrivateKey.ChildIndexSize = 4;
    HDPrivateKey.ChainCodeSize = 32;
    HDPrivateKey.PrivateKeySize = 32;
    HDPrivateKey.CheckSumSize = 4;
    HDPrivateKey.DataLength = 78;
    HDPrivateKey.SerializedByteSize = 82;
    HDPrivateKey.VersionStart = 0;
    HDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;
    HDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;
    HDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;
    HDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;
    HDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;
    HDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;
    HDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;
    HDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;
    HDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;
    HDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;
    HDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;
    HDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;
    HDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;
    assert2(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);
    hdprivatekey = HDPrivateKey;
    return hdprivatekey;
  }
  var _$1 = lodashExports;
  var PrivateKey = requirePrivatekey();
  var PublicKey = requirePublickey();
  var Address$2 = requireAddress();
  var BufferWriter = bufferwriter;
  var ECDSA = requireEcdsa();
  var Signature = signature$2;
  var sha256sha256 = hashExports.sha256sha256;
  var JSUtil = js$1;
  var $ = preconditions;
  function Message(message2) {
    if (!(this instanceof Message)) {
      return new Message(message2);
    }
    $.checkArgument(_$1.isString(message2), "First argument should be a string");
    this.message = message2;
    return this;
  }
  Message.MAGIC_BYTES = buffer$2.Buffer.from("Bitcoin Signed Message:\n");
  Message.prototype.magicHash = function magicHash() {
    var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);
    var messageBuffer = buffer$2.Buffer.from(this.message);
    var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);
    var buf = buffer$2.Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);
    var hash2 = sha256sha256(buf);
    return hash2;
  };
  Message.prototype._sign = function _sign(privateKey) {
    $.checkArgument(privateKey instanceof PrivateKey, "First argument should be an instance of PrivateKey");
    var hash2 = this.magicHash();
    var ecdsa2 = new ECDSA();
    ecdsa2.hashbuf = hash2;
    ecdsa2.privkey = privateKey;
    ecdsa2.pubkey = privateKey.toPublicKey();
    ecdsa2.signRandomK();
    ecdsa2.calci();
    return ecdsa2.sig;
  };
  Message.prototype.sign = function sign2(privateKey) {
    var signature2 = this._sign(privateKey);
    return signature2.toCompact().toString("base64");
  };
  Message.prototype._verify = function _verify(publicKey, signature2) {
    $.checkArgument(publicKey instanceof PublicKey, "First argument should be an instance of PublicKey");
    $.checkArgument(signature2 instanceof Signature, "Second argument should be an instance of Signature");
    var hash2 = this.magicHash();
    var verified = ECDSA.verify(hash2, signature2, publicKey);
    if (!verified) {
      this.error = "The signature was invalid";
    }
    return verified;
  };
  Message.prototype.verify = function verify2(bitcoinAddress, signatureString) {
    $.checkArgument(bitcoinAddress);
    $.checkArgument(signatureString && _$1.isString(signatureString));
    if (_$1.isString(bitcoinAddress)) {
      bitcoinAddress = Address$2.fromString(bitcoinAddress);
    }
    var signature2 = Signature.fromCompact(buffer$2.Buffer.from(signatureString, "base64"));
    var ecdsa2 = new ECDSA();
    ecdsa2.hashbuf = this.magicHash();
    ecdsa2.sig = signature2;
    var publicKey = ecdsa2.toPublicKey();
    var signatureAddress = Address$2.fromPublicKey(publicKey, bitcoinAddress.network);
    if (bitcoinAddress.toString() !== signatureAddress.toString()) {
      this.error = "The signature did not match the message digest";
      return false;
    }
    return this._verify(publicKey, signature2);
  };
  Message.prototype.recoverPublicKey = function recoverPublicKey(bitcoinAddress, signatureString) {
    $.checkArgument(bitcoinAddress);
    $.checkArgument(signatureString && _$1.isString(signatureString));
    if (_$1.isString(bitcoinAddress)) {
      bitcoinAddress = Address$2.fromString(bitcoinAddress);
    }
    var signature2 = Signature.fromCompact(buffer$2.Buffer.from(signatureString, "base64"));
    var ecdsa2 = new ECDSA();
    ecdsa2.hashbuf = this.magicHash();
    ecdsa2.sig = signature2;
    var publicKey = ecdsa2.toPublicKey();
    var signatureAddress = Address$2.fromPublicKey(publicKey, bitcoinAddress.network);
    if (bitcoinAddress.toString() !== signatureAddress.toString()) {
      this.error = "The signature did not match the message digest";
    }
    return publicKey.toString();
  };
  Message.fromString = function(str) {
    return new Message(str);
  };
  Message.fromJSON = function fromJSON(json) {
    if (JSUtil.isValidJSON(json)) {
      json = JSON.parse(json);
    }
    return new Message(json.message);
  };
  Message.prototype.toObject = function toObject2() {
    return {
      message: this.message
    };
  };
  Message.prototype.toJSON = function toJSON() {
    return JSON.stringify(this.toObject());
  };
  Message.prototype.toString = function() {
    return this.message;
  };
  Message.prototype.inspect = function() {
    return "<Message: " + this.toString() + ">";
  };
  var message = Message;
  requireScript();
  var _ = lodashExports;
  var URL = require$$1$1;
  var Address$1 = requireAddress();
  var Unit = unit;
  var URI = function(data2, knownParams) {
    if (!(this instanceof URI)) {
      return new URI(data2, knownParams);
    }
    this.extras = {};
    this.knownParams = knownParams || [];
    this.address = this.network = this.amount = this.message = null;
    if (typeof data2 === "string") {
      var params = URI.parse(data2);
      if (params.amount) {
        params.amount = this._parseAmount(params.amount);
      }
      this._fromObject(params);
    } else if (typeof data2 === "object") {
      this._fromObject(data2);
    } else {
      throw new TypeError("Unrecognized data format.");
    }
  };
  URI.fromString = function fromString(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return new URI(str);
  };
  URI.fromObject = function fromObject(json) {
    return new URI(json);
  };
  URI.isValid = function(arg, knownParams) {
    try {
      new URI(arg, knownParams);
    } catch (err) {
      return false;
    }
    return true;
  };
  URI.parse = function(uri2) {
    var info = URL.parse(uri2, true);
    if (info.protocol !== "bitcoin:") {
      throw new TypeError("Invalid bitcoin URI");
    }
    var group = /[^:]*:\/?\/?([^?]*)/.exec(uri2);
    info.query.address = group && group[1] || void 0;
    return info.query;
  };
  URI.Members = ["address", "amount", "message", "label", "r"];
  URI.prototype._fromObject = function(obj) {
    if (!Address$1.isValid(obj.address)) {
      throw new TypeError("Invalid bitcoin address");
    }
    this.address = new Address$1(obj.address);
    this.network = this.address.network;
    this.amount = obj.amount;
    for (var key2 in obj) {
      if (key2 === "address" || key2 === "amount") {
        continue;
      }
      if (/^req-/.exec(key2) && this.knownParams.indexOf(key2) === -1) {
        throw Error("Unknown required argument " + key2);
      }
      var destination = URI.Members.indexOf(key2) > -1 ? this : this.extras;
      destination[key2] = obj[key2];
    }
  };
  URI.prototype._parseAmount = function(amount) {
    amount = Number(amount);
    if (isNaN(amount)) {
      throw new TypeError("Invalid amount");
    }
    return Unit.fromBTC(amount).toSatoshis();
  };
  URI.prototype.toObject = URI.prototype.toJSON = function toObject2() {
    var json = {};
    for (var i2 = 0; i2 < URI.Members.length; i2++) {
      var m = URI.Members[i2];
      if (this.hasOwnProperty(m) && typeof this[m] !== "undefined") {
        json[m] = this[m].toString();
      }
    }
    _.extend(json, this.extras);
    return json;
  };
  URI.prototype.toString = function() {
    var query = {};
    if (this.amount) {
      query.amount = Unit.fromSatoshis(this.amount).toBTC();
    }
    if (this.message) {
      query.message = this.message;
    }
    if (this.label) {
      query.label = this.label;
    }
    if (this.r) {
      query.r = this.r;
    }
    _.extend(query, this.extras);
    return URL.format({
      protocol: "bitcoin:",
      host: this.address,
      query
    });
  };
  URI.prototype.inspect = function() {
    return "<URI: " + this.toString() + ">";
  };
  var uri = URI;
  (function(module2) {
    var bitcore2 = module2.exports;
    bitcore2.version = "v" + require$$0$2.version;
    bitcore2.versionGuard = function(version2) {
      if (version2 !== void 0) {
        var message2 = "More than one instance of bitcore-lib found. Please make sure to require bitcore-lib and check that submodules do not also include their own bitcore-lib dependency.";
        throw new Error(message2);
      }
    };
    bitcore2.versionGuard(commonjsGlobal._bitcore);
    commonjsGlobal._bitcore = bitcore2.version;
    bitcore2.crypto = {};
    bitcore2.crypto.BN = bn$2;
    bitcore2.crypto.ECDSA = requireEcdsa();
    bitcore2.crypto.Hash = hashExports;
    bitcore2.crypto.Random = random$1;
    bitcore2.crypto.Point = point$1;
    bitcore2.crypto.Signature = signature$2;
    bitcore2.encoding = {};
    bitcore2.encoding.Base58 = base58;
    bitcore2.encoding.Base58Check = base58check;
    bitcore2.encoding.BufferReader = bufferreader;
    bitcore2.encoding.BufferWriter = bufferwriter;
    bitcore2.encoding.Varint = varint;
    bitcore2.util = {};
    bitcore2.util.buffer = bufferExports;
    bitcore2.util.js = js$1;
    bitcore2.util.preconditions = preconditions;
    bitcore2.errors = errorsExports;
    bitcore2.Address = requireAddress();
    bitcore2.Block = blockExports;
    bitcore2.MerkleBlock = merkleblock;
    bitcore2.BlockHeader = blockheader;
    bitcore2.HDPrivateKey = requireHdprivatekey();
    bitcore2.HDPublicKey = requireHdpublickey();
    bitcore2.Message = message;
    bitcore2.Networks = networks_1;
    bitcore2.Opcode = opcode;
    bitcore2.PrivateKey = requirePrivatekey();
    bitcore2.PublicKey = requirePublickey();
    bitcore2.Script = requireScript();
    bitcore2.Transaction = requireTransaction();
    bitcore2.URI = uri;
    bitcore2.Unit = unit;
    bitcore2.deps = {};
    bitcore2.deps.bnjs = bnExports$2;
    bitcore2.deps.bs58 = bs58$1;
    bitcore2.deps.Buffer = buffer$2.Buffer;
    bitcore2.deps.elliptic = elliptic$2;
    bitcore2.deps._ = lodashExports;
    bitcore2.Transaction.sighash = requireSighash();
  })(bitcoreLib);
  var bitcoreLibExports = bitcoreLib.exports;
  var dist_browser$1 = {};
  var constants = {};
  var externals = {};
  var bn = { exports: {} };
  bn.exports;
  (function(module2) {
    (function(module3, exports2) {
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number2, base2, endian) {
        if (BN2.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number2 || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require$$1$1.Buffer;
        }
      } catch (e) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init(number2, base2, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base2, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base2 === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number2, base2, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initArray = function _initArray(number2, base2, endian) {
        assert2(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i2 = number2.length - 1, j = 0; i2 >= 0; i2 -= 3) {
            w = number2[i2] | number2[i2 - 1] << 8 | number2[i2 - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i2 = 0, j = 0; i2 < number2.length; i2 += 3) {
            w = number2[i2] | number2[i2 + 1] << 8 | number2[i2 + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert2(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r2 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r2;
      }
      BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i2 = number2.length - 1; i2 >= start; i2 -= 2) {
            w = parseHexByte(number2, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number2.length; i2 += 2) {
            w = parseHexByte(number2, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r2 = 0;
        var b = 0;
        var len2 = Math.min(str.length, end);
        for (var i2 = start; i2 < len2; i2++) {
          var c = str.charCodeAt(i2) - 48;
          r2 *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert2(c >= 0 && b < mul, "Invalid character");
          r2 += b;
        }
        return r2;
      }
      BN2.prototype._parseBase = function _parseBase(number2, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number2.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i2 = start; i2 < end; i2 += limbLen) {
          word = parseBase(number2, i2, i2 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow3 = 1;
          word = parseBase(number2, i2, number2.length, base2);
          for (i2 = 0; i2 < mod2; i2++) {
            pow3 *= base2;
          }
          this.imuln(pow3);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          dest.words[i2] = this.words[i2];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src2) {
        dest.words = src2.words;
        dest.length = src2.length;
        dest.negative = src2.negative;
        dest.red = src2.red;
      }
      BN2.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN2.prototype.clone = function clone() {
        var r2 = new BN2(null);
        this.copy(r2);
        return r2;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN2.prototype.inspect = inspect;
        }
      } else {
        BN2.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w = this.words[i2];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i2--;
            }
            if (carry !== 0 || i2 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r2 = c.modrn(groupBase).toString(base2);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN2.prototype.toBuffer = function toBuffer2(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength2 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength2);
        assert2(byteLength2 <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength2);
        return res;
      };
      BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
        var position = 0;
        var carry = 0;
        for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
        var position = res.length - 1;
        var carry = 0;
        for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w) {
          var t = w;
          var r2 = 0;
          if (t >= 4096) {
            r2 += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r2 += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r2 += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r2 += 2;
            t >>>= 2;
          }
          return r2 + t;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r2 = 0;
        if ((t & 8191) === 0) {
          r2 += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r2 += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r2 += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r2 += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r2 = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          r2 += b;
          if (b !== 26)
            break;
        }
        return r2;
      };
      BN2.prototype.byteLength = function byteLength2() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i2 = 0; i2 < num.length; i2++) {
          this.words[i2] = this.words[i2] | num.words[i2];
        }
        return this._strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = this.words[i2] & num.words[i2];
        }
        this.length = b.length;
        return this._strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = a.words[i2] ^ b.words[i2];
        }
        if (this !== a) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i2 = 0; i2 < bytesNeeded; i2++) {
          this.words[i2] = ~this.words[i2] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r2 = (a.words[i2] | 0) + (b.words[i2] | 0) + carry;
          this.words[i2] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i2 < a.length; i2++) {
          r2 = (a.words[i2] | 0) + carry;
          this.words[i2] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r2 = (a.words[i2] | 0) - (b.words[i2] | 0) + carry;
          carry = r2 >> 26;
          this.words[i2] = r2 & 67108863;
        }
        for (; carry !== 0 && i2 < a.length; i2++) {
          r2 = (a.words[i2] | 0) + carry;
          carry = r2 >> 26;
          this.words[i2] = r2 & 67108863;
        }
        if (carry === 0 && i2 < a.length && a !== this) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        this.length = Math.max(this.length, i2);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2;
        len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r2 = a * b;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k2 = 1; k2 < len2; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
            var i2 = k2 - j | 0;
            a = self2.words[i2] | 0;
            b = num.words[j] | 0;
            r2 = a * b + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
            var i2 = k2 - j;
            var a = self2.words[i2] | 0;
            var b = num.words[j] | 0;
            var r2 = a * b;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len2 < 63) {
          res = smallMulTo(this, num, out);
        } else if (len2 < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i2] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow3(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN2(1);
        var res = this;
        for (var i2 = 0; i2 < w.length; i2++, res = res.sqr()) {
          if (w[i2] !== 0)
            break;
        }
        if (++i2 < w.length) {
          for (var q = res.sqr(); i2 < w.length; i2++, q = q.sqr()) {
            if (w[i2] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i2;
        if (r2 !== 0) {
          var carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask;
            var c = (this.words[i2] | 0) - newCarry << r2;
            this.words[i2] = c | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i2] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i2 = this.length - 1; i2 >= 0; i2--) {
            this.words[i2 + s2] = this.words[i2];
          }
          for (i2 = 0; i2 < s2; i2++) {
            this.words[i2] = 0;
          }
          this.length += s2;
        }
        return this._strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r2 = bits % 26;
        var s2 = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h -= s2;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i2 = 0; i2 < s2; i2++) {
            maskedWords.words[i2] = this.words[i2];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0)
          ;
        else if (this.length > s2) {
          this.length -= s2;
          for (i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = this.words[i2 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s2)
          return false;
        var w = this.words[s2];
        return !!(w & q);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r2 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
          this.words[i2] -= 67108864;
          if (i2 === this.length - 1) {
            this.words[i2 + 1] = 1;
          } else {
            this.words[i2 + 1]++;
          }
        }
        this.length = Math.max(this.length, i2 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
            this.words[i2] += 67108864;
            this.words[i2 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift;
        var i2;
        this._expand(len2);
        var w;
        var carry = 0;
        for (i2 = 0; i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i2 + shift] = w & 67108863;
        }
        for (; i2 < this.length - shift; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i2 + shift] = w & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert2(carry === -1);
        carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          w = -(this.words[i2] | 0) + carry;
          carry = w >> 26;
          this.words[i2] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN2(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i2 = 0; i2 < q.length; i2++) {
            q.words[i2] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(num <= 67108863);
        var p2 = (1 << 26) % num;
        var acc = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          acc = (p2 * acc + (this.words[i2] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN2.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN2.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p2) {
        assert2(p2.negative === 0);
        assert2(!p2.isZero());
        var x = this;
        var y = p2.clone();
        if (x.negative !== 0) {
          x = x.umod(p2);
        } else {
          x = x.clone();
        }
        var A = new BN2(1);
        var B = new BN2(0);
        var C = new BN2(0);
        var D = new BN2(1);
        var g2 = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g2;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i2 = 0, im = 1; (x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x.iushrn(i2);
            while (i2-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g2)
        };
      };
      BN2.prototype._invmp = function _invmp(p2) {
        assert2(p2.negative === 0);
        assert2(!p2.isZero());
        var a = this;
        var b = p2.clone();
        if (a.negative !== 0) {
          a = a.umod(p2);
        } else {
          a = a.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1; (a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p2);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r2 = a.cmp(b);
          if (r2 < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r2 === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven2() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q;
          return this;
        }
        var carry = q;
        for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i2] = w;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var a = this.words[i2] | 0;
          var b = num.words[i2] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p2) {
        this.name = name2;
        this.p = new BN2(p2, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      };
      MPrime.prototype.split = function split2(input2, out) {
        input2.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split2(input2, output2) {
        var mask = 4194303;
        var outLen = Math.min(input2.length, 9);
        for (var i2 = 0; i2 < outLen; i2++) {
          output2.words[i2] = input2.words[i2];
        }
        output2.length = outLen;
        if (input2.length <= 9) {
          input2.words[0] = 0;
          input2.length = 1;
          return;
        }
        var prev = input2.words[9];
        output2.words[output2.length++] = prev & mask;
        for (i2 = 10; i2 < input2.length; i2++) {
          var next = input2.words[i2] | 0;
          input2.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input2.words[i2 - 10] = prev;
        if (prev === 0 && input2.length > 10) {
          input2.length -= 10;
        } else {
          input2.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977;
          num.words[i2] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i2] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN2._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert2(a.negative === 0, "red works only with positives");
        assert2(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert2((a.negative | b.negative) === 0, "red works only with positives");
        assert2(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow3 = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a, pow3);
        }
        var q = this.m.subn(1);
        var s2 = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s2++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one2 = new BN2(1).toRed(this);
        var nOne = one2.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN2(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r2 = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s2;
        while (t.cmp(one2) !== 0) {
          var tmp = t;
          for (var i2 = 0; tmp.cmp(one2) !== 0; i2++) {
            tmp = tmp.redSqr();
          }
          assert2(i2 < m);
          var b = this.pow(c, new BN2(1).iushln(m - i2 - 1));
          r2 = r2.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i2;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow3(a, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a;
        for (var i2 = 2; i2 < wnd.length; i2++) {
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i2 = num.length - 1; i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i2 !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont2(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN2(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(module2, commonjsGlobal);
  })(bn);
  var bnExports = bn.exports;
  var dist_browser = {};
  var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(dist_browser, "__esModule", { value: true });
  dist_browser.getLength = dist_browser.decode = dist_browser.encode = void 0;
  var bn_js_1$1 = __importDefault$3(bnExports);
  function encode(input2) {
    if (Array.isArray(input2)) {
      var output2 = [];
      for (var i2 = 0; i2 < input2.length; i2++) {
        output2.push(encode(input2[i2]));
      }
      var buf = buffer$2.Buffer.concat(output2);
      return buffer$2.Buffer.concat([encodeLength(buf.length, 192), buf]);
    } else {
      var inputBuf = toBuffer(input2);
      return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : buffer$2.Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);
    }
  }
  dist_browser.encode = encode;
  function safeParseInt(v, base2) {
    if (v[0] === "0" && v[1] === "0") {
      throw new Error("invalid RLP: extra zeros");
    }
    return parseInt(v, base2);
  }
  function encodeLength(len2, offset) {
    if (len2 < 56) {
      return buffer$2.Buffer.from([len2 + offset]);
    } else {
      var hexLength = intToHex(len2);
      var lLength = hexLength.length / 2;
      var firstByte = intToHex(offset + 55 + lLength);
      return buffer$2.Buffer.from(firstByte + hexLength, "hex");
    }
  }
  function decode(input2, stream) {
    if (stream === void 0) {
      stream = false;
    }
    if (!input2 || input2.length === 0) {
      return buffer$2.Buffer.from([]);
    }
    var inputBuffer = toBuffer(input2);
    var decoded = _decode(inputBuffer);
    if (stream) {
      return decoded;
    }
    if (decoded.remainder.length !== 0) {
      throw new Error("invalid remainder");
    }
    return decoded.data;
  }
  dist_browser.decode = decode;
  function getLength(input2) {
    if (!input2 || input2.length === 0) {
      return buffer$2.Buffer.from([]);
    }
    var inputBuffer = toBuffer(input2);
    var firstByte = inputBuffer[0];
    if (firstByte <= 127) {
      return inputBuffer.length;
    } else if (firstByte <= 183) {
      return firstByte - 127;
    } else if (firstByte <= 191) {
      return firstByte - 182;
    } else if (firstByte <= 247) {
      return firstByte - 191;
    } else {
      var llength = firstByte - 246;
      var length_1 = safeParseInt(inputBuffer.slice(1, llength).toString("hex"), 16);
      return llength + length_1;
    }
  }
  dist_browser.getLength = getLength;
  function _decode(input2) {
    var length, llength, data2, innerRemainder, d;
    var decoded = [];
    var firstByte = input2[0];
    if (firstByte <= 127) {
      return {
        data: input2.slice(0, 1),
        remainder: input2.slice(1)
      };
    } else if (firstByte <= 183) {
      length = firstByte - 127;
      if (firstByte === 128) {
        data2 = buffer$2.Buffer.from([]);
      } else {
        data2 = input2.slice(1, length);
      }
      if (length === 2 && data2[0] < 128) {
        throw new Error("invalid rlp encoding: byte must be less 0x80");
      }
      return {
        data: data2,
        remainder: input2.slice(length)
      };
    } else if (firstByte <= 191) {
      llength = firstByte - 182;
      if (input2.length - 1 < llength) {
        throw new Error("invalid RLP: not enough bytes for string length");
      }
      length = safeParseInt(input2.slice(1, llength).toString("hex"), 16);
      if (length <= 55) {
        throw new Error("invalid RLP: expected string length to be greater than 55");
      }
      data2 = input2.slice(llength, length + llength);
      if (data2.length < length) {
        throw new Error("invalid RLP: not enough bytes for string");
      }
      return {
        data: data2,
        remainder: input2.slice(length + llength)
      };
    } else if (firstByte <= 247) {
      length = firstByte - 191;
      innerRemainder = input2.slice(1, length);
      while (innerRemainder.length) {
        d = _decode(innerRemainder);
        decoded.push(d.data);
        innerRemainder = d.remainder;
      }
      return {
        data: decoded,
        remainder: input2.slice(length)
      };
    } else {
      llength = firstByte - 246;
      length = safeParseInt(input2.slice(1, llength).toString("hex"), 16);
      var totalLength = llength + length;
      if (totalLength > input2.length) {
        throw new Error("invalid rlp: total length is larger than the data");
      }
      innerRemainder = input2.slice(llength, totalLength);
      if (innerRemainder.length === 0) {
        throw new Error("invalid rlp, List has a invalid length");
      }
      while (innerRemainder.length) {
        d = _decode(innerRemainder);
        decoded.push(d.data);
        innerRemainder = d.remainder;
      }
      return {
        data: decoded,
        remainder: input2.slice(totalLength)
      };
    }
  }
  function isHexPrefixed$1(str) {
    return str.slice(0, 2) === "0x";
  }
  function stripHexPrefix$1(str) {
    if (typeof str !== "string") {
      return str;
    }
    return isHexPrefixed$1(str) ? str.slice(2) : str;
  }
  function intToHex(integer) {
    if (integer < 0) {
      throw new Error("Invalid integer as argument, must be unsigned!");
    }
    var hex = integer.toString(16);
    return hex.length % 2 ? "0" + hex : hex;
  }
  function padToEven$1(a) {
    return a.length % 2 ? "0" + a : a;
  }
  function intToBuffer(integer) {
    var hex = intToHex(integer);
    return buffer$2.Buffer.from(hex, "hex");
  }
  function toBuffer(v) {
    if (!buffer$2.Buffer.isBuffer(v)) {
      if (typeof v === "string") {
        if (isHexPrefixed$1(v)) {
          return buffer$2.Buffer.from(padToEven$1(stripHexPrefix$1(v)), "hex");
        } else {
          return buffer$2.Buffer.from(v);
        }
      } else if (typeof v === "number" || typeof v === "bigint") {
        if (!v) {
          return buffer$2.Buffer.from([]);
        } else {
          return intToBuffer(v);
        }
      } else if (v === null || v === void 0) {
        return buffer$2.Buffer.from([]);
      } else if (v instanceof Uint8Array) {
        return buffer$2.Buffer.from(v);
      } else if (bn_js_1$1.default.isBN(v)) {
        return buffer$2.Buffer.from(v.toArray());
      } else {
        throw new Error("invalid type");
      }
    }
    return v;
  }
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k2 in mod2)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
          __createBinding(result, mod2, k2);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(externals, "__esModule", { value: true });
  externals.rlp = externals.BN = void 0;
  var bn_js_1 = __importDefault$2(bnExports);
  externals.BN = bn_js_1.default;
  var rlp = __importStar(dist_browser);
  externals.rlp = rlp;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KECCAK256_RLP = exports2.KECCAK256_RLP_S = exports2.KECCAK256_RLP_ARRAY = exports2.KECCAK256_RLP_ARRAY_S = exports2.KECCAK256_NULL = exports2.KECCAK256_NULL_S = exports2.TWO_POW256 = exports2.MAX_INTEGER = exports2.MAX_UINT64 = void 0;
    var buffer_1 = buffer$2;
    var externals_12 = externals;
    exports2.MAX_UINT64 = new externals_12.BN("ffffffffffffffff", 16);
    exports2.MAX_INTEGER = new externals_12.BN("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports2.TWO_POW256 = new externals_12.BN("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports2.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports2.KECCAK256_NULL = buffer_1.Buffer.from(exports2.KECCAK256_NULL_S, "hex");
    exports2.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports2.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports2.KECCAK256_RLP_ARRAY_S, "hex");
    exports2.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports2.KECCAK256_RLP = buffer_1.Buffer.from(exports2.KECCAK256_RLP_S, "hex");
  })(constants);
  var account = {};
  var secp256k1 = {};
  const errors = {
    IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
    TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
    TWEAK_MUL: "The tweak was out of range or equal to zero",
    CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
    SECKEY_INVALID: "Private Key is invalid",
    PUBKEY_PARSE: "Public Key could not be parsed",
    PUBKEY_SERIALIZE: "Public Key serialization error",
    PUBKEY_COMBINE: "The sum of the public keys is not valid",
    SIG_PARSE: "Signature could not be parsed",
    SIGN: "The nonce generation function failed, or the private key was invalid",
    RECOVER: "Public key could not be recover",
    ECDH: "Scalar was invalid (zero or overflow)"
  };
  function assert(cond, msg) {
    if (!cond)
      throw new Error(msg);
  }
  function isUint8Array(name2, value, length) {
    assert(value instanceof Uint8Array, `Expected ${name2} to be an Uint8Array`);
    if (length !== void 0) {
      if (Array.isArray(length)) {
        const numbers = length.join(", ");
        const msg = `Expected ${name2} to be an Uint8Array with length [${numbers}]`;
        assert(length.includes(value.length), msg);
      } else {
        const msg = `Expected ${name2} to be an Uint8Array with length ${length}`;
        assert(value.length === length, msg);
      }
    }
  }
  function isCompressed(value) {
    assert(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
  }
  function getAssertedOutput(output2 = (len2) => new Uint8Array(len2), length) {
    if (typeof output2 === "function")
      output2 = output2(length);
    isUint8Array("output", output2, length);
    return output2;
  }
  function toTypeString(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  }
  var lib = (secp256k12) => {
    return {
      contextRandomize(seed) {
        assert(
          seed === null || seed instanceof Uint8Array,
          "Expected seed to be an Uint8Array or null"
        );
        if (seed !== null)
          isUint8Array("seed", seed, 32);
        switch (secp256k12.contextRandomize(seed)) {
          case 1:
            throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);
        }
      },
      privateKeyVerify(seckey) {
        isUint8Array("private key", seckey, 32);
        return secp256k12.privateKeyVerify(seckey) === 0;
      },
      privateKeyNegate(seckey) {
        isUint8Array("private key", seckey, 32);
        switch (secp256k12.privateKeyNegate(seckey)) {
          case 0:
            return seckey;
          case 1:
            throw new Error(errors.IMPOSSIBLE_CASE);
        }
      },
      privateKeyTweakAdd(seckey, tweak) {
        isUint8Array("private key", seckey, 32);
        isUint8Array("tweak", tweak, 32);
        switch (secp256k12.privateKeyTweakAdd(seckey, tweak)) {
          case 0:
            return seckey;
          case 1:
            throw new Error(errors.TWEAK_ADD);
        }
      },
      privateKeyTweakMul(seckey, tweak) {
        isUint8Array("private key", seckey, 32);
        isUint8Array("tweak", tweak, 32);
        switch (secp256k12.privateKeyTweakMul(seckey, tweak)) {
          case 0:
            return seckey;
          case 1:
            throw new Error(errors.TWEAK_MUL);
        }
      },
      publicKeyVerify(pubkey) {
        isUint8Array("public key", pubkey, [33, 65]);
        return secp256k12.publicKeyVerify(pubkey) === 0;
      },
      publicKeyCreate(seckey, compressed = true, output2) {
        isUint8Array("private key", seckey, 32);
        isCompressed(compressed);
        output2 = getAssertedOutput(output2, compressed ? 33 : 65);
        switch (secp256k12.publicKeyCreate(output2, seckey)) {
          case 0:
            return output2;
          case 1:
            throw new Error(errors.SECKEY_INVALID);
          case 2:
            throw new Error(errors.PUBKEY_SERIALIZE);
        }
      },
      publicKeyConvert(pubkey, compressed = true, output2) {
        isUint8Array("public key", pubkey, [33, 65]);
        isCompressed(compressed);
        output2 = getAssertedOutput(output2, compressed ? 33 : 65);
        switch (secp256k12.publicKeyConvert(output2, pubkey)) {
          case 0:
            return output2;
          case 1:
            throw new Error(errors.PUBKEY_PARSE);
          case 2:
            throw new Error(errors.PUBKEY_SERIALIZE);
        }
      },
      publicKeyNegate(pubkey, compressed = true, output2) {
        isUint8Array("public key", pubkey, [33, 65]);
        isCompressed(compressed);
        output2 = getAssertedOutput(output2, compressed ? 33 : 65);
        switch (secp256k12.publicKeyNegate(output2, pubkey)) {
          case 0:
            return output2;
          case 1:
            throw new Error(errors.PUBKEY_PARSE);
          case 2:
            throw new Error(errors.IMPOSSIBLE_CASE);
          case 3:
            throw new Error(errors.PUBKEY_SERIALIZE);
        }
      },
      publicKeyCombine(pubkeys, compressed = true, output2) {
        assert(Array.isArray(pubkeys), "Expected public keys to be an Array");
        assert(pubkeys.length > 0, "Expected public keys array will have more than zero items");
        for (const pubkey of pubkeys) {
          isUint8Array("public key", pubkey, [33, 65]);
        }
        isCompressed(compressed);
        output2 = getAssertedOutput(output2, compressed ? 33 : 65);
        switch (secp256k12.publicKeyCombine(output2, pubkeys)) {
          case 0:
            return output2;
          case 1:
            throw new Error(errors.PUBKEY_PARSE);
          case 2:
            throw new Error(errors.PUBKEY_COMBINE);
          case 3:
            throw new Error(errors.PUBKEY_SERIALIZE);
        }
      },
      publicKeyTweakAdd(pubkey, tweak, compressed = true, output2) {
        isUint8Array("public key", pubkey, [33, 65]);
        isUint8Array("tweak", tweak, 32);
        isCompressed(compressed);
        output2 = getAssertedOutput(output2, compressed ? 33 : 65);
        switch (secp256k12.publicKeyTweakAdd(output2, pubkey, tweak)) {
          case 0:
            return output2;
          case 1:
            throw new Error(errors.PUBKEY_PARSE);
          case 2:
            throw new Error(errors.TWEAK_ADD);
        }
      },
      publicKeyTweakMul(pubkey, tweak, compressed = true, output2) {
        isUint8Array("public key", pubkey, [33, 65]);
        isUint8Array("tweak", tweak, 32);
        isCompressed(compressed);
        output2 = getAssertedOutput(output2, compressed ? 33 : 65);
        switch (secp256k12.publicKeyTweakMul(output2, pubkey, tweak)) {
          case 0:
            return output2;
          case 1:
            throw new Error(errors.PUBKEY_PARSE);
          case 2:
            throw new Error(errors.TWEAK_MUL);
        }
      },
      signatureNormalize(sig) {
        isUint8Array("signature", sig, 64);
        switch (secp256k12.signatureNormalize(sig)) {
          case 0:
            return sig;
          case 1:
            throw new Error(errors.SIG_PARSE);
        }
      },
      signatureExport(sig, output2) {
        isUint8Array("signature", sig, 64);
        output2 = getAssertedOutput(output2, 72);
        const obj = { output: output2, outputlen: 72 };
        switch (secp256k12.signatureExport(obj, sig)) {
          case 0:
            return output2.slice(0, obj.outputlen);
          case 1:
            throw new Error(errors.SIG_PARSE);
          case 2:
            throw new Error(errors.IMPOSSIBLE_CASE);
        }
      },
      signatureImport(sig, output2) {
        isUint8Array("signature", sig);
        output2 = getAssertedOutput(output2, 64);
        switch (secp256k12.signatureImport(output2, sig)) {
          case 0:
            return output2;
          case 1:
            throw new Error(errors.SIG_PARSE);
          case 2:
            throw new Error(errors.IMPOSSIBLE_CASE);
        }
      },
      ecdsaSign(msg32, seckey, options = {}, output2) {
        isUint8Array("message", msg32, 32);
        isUint8Array("private key", seckey, 32);
        assert(toTypeString(options) === "Object", "Expected options to be an Object");
        if (options.data !== void 0)
          isUint8Array("options.data", options.data);
        if (options.noncefn !== void 0)
          assert(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
        output2 = getAssertedOutput(output2, 64);
        const obj = { signature: output2, recid: null };
        switch (secp256k12.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
          case 0:
            return obj;
          case 1:
            throw new Error(errors.SIGN);
          case 2:
            throw new Error(errors.IMPOSSIBLE_CASE);
        }
      },
      ecdsaVerify(sig, msg32, pubkey) {
        isUint8Array("signature", sig, 64);
        isUint8Array("message", msg32, 32);
        isUint8Array("public key", pubkey, [33, 65]);
        switch (secp256k12.ecdsaVerify(sig, msg32, pubkey)) {
          case 0:
            return true;
          case 3:
            return false;
          case 1:
            throw new Error(errors.SIG_PARSE);
          case 2:
            throw new Error(errors.PUBKEY_PARSE);
        }
      },
      ecdsaRecover(sig, recid, msg32, compressed = true, output2) {
        isUint8Array("signature", sig, 64);
        assert(
          toTypeString(recid) === "Number" && recid >= 0 && recid <= 3,
          "Expected recovery id to be a Number within interval [0, 3]"
        );
        isUint8Array("message", msg32, 32);
        isCompressed(compressed);
        output2 = getAssertedOutput(output2, compressed ? 33 : 65);
        switch (secp256k12.ecdsaRecover(output2, sig, recid, msg32)) {
          case 0:
            return output2;
          case 1:
            throw new Error(errors.SIG_PARSE);
          case 2:
            throw new Error(errors.RECOVER);
          case 3:
            throw new Error(errors.IMPOSSIBLE_CASE);
        }
      },
      ecdh(pubkey, seckey, options = {}, output2) {
        isUint8Array("public key", pubkey, [33, 65]);
        isUint8Array("private key", seckey, 32);
        assert(toTypeString(options) === "Object", "Expected options to be an Object");
        if (options.data !== void 0)
          isUint8Array("options.data", options.data);
        if (options.hashfn !== void 0) {
          assert(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
          if (options.xbuf !== void 0)
            isUint8Array("options.xbuf", options.xbuf, 32);
          if (options.ybuf !== void 0)
            isUint8Array("options.ybuf", options.ybuf, 32);
          isUint8Array("output", output2);
        } else {
          output2 = getAssertedOutput(output2, 32);
        }
        switch (secp256k12.ecdh(output2, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
          case 0:
            return output2;
          case 1:
            throw new Error(errors.PUBKEY_PARSE);
          case 2:
            throw new Error(errors.ECDH);
        }
      }
    };
  };
  const EC = elliptic$2.ec;
  const ec = new EC("secp256k1");
  const ecparams = ec.curve;
  const BN = ecparams.n.constructor;
  function loadCompressedPublicKey(first, xbuf) {
    let x = new BN(xbuf);
    if (x.cmp(ecparams.p) >= 0)
      return null;
    x = x.toRed(ecparams.red);
    let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
    if (first === 3 !== y.isOdd())
      y = y.redNeg();
    return ec.keyPair({ pub: { x, y } });
  }
  function loadUncompressedPublicKey(first, xbuf, ybuf) {
    let x = new BN(xbuf);
    let y = new BN(ybuf);
    if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0)
      return null;
    x = x.toRed(ecparams.red);
    y = y.toRed(ecparams.red);
    if ((first === 6 || first === 7) && y.isOdd() !== (first === 7))
      return null;
    const x3 = x.redSqr().redIMul(x);
    if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero())
      return null;
    return ec.keyPair({ pub: { x, y } });
  }
  function loadPublicKey(pubkey) {
    const first = pubkey[0];
    switch (first) {
      case 2:
      case 3:
        if (pubkey.length !== 33)
          return null;
        return loadCompressedPublicKey(first, pubkey.subarray(1, 33));
      case 4:
      case 6:
      case 7:
        if (pubkey.length !== 65)
          return null;
        return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
      default:
        return null;
    }
  }
  function savePublicKey(output2, point2) {
    const pubkey = point2.encode(null, output2.length === 33);
    for (let i2 = 0; i2 < output2.length; ++i2)
      output2[i2] = pubkey[i2];
  }
  var elliptic$1 = {
    contextRandomize() {
      return 0;
    },
    privateKeyVerify(seckey) {
      const bn2 = new BN(seckey);
      return bn2.cmp(ecparams.n) < 0 && !bn2.isZero() ? 0 : 1;
    },
    privateKeyNegate(seckey) {
      const bn2 = new BN(seckey);
      const negate = ecparams.n.sub(bn2).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
      seckey.set(negate);
      return 0;
    },
    privateKeyTweakAdd(seckey, tweak) {
      const bn2 = new BN(tweak);
      if (bn2.cmp(ecparams.n) >= 0)
        return 1;
      bn2.iadd(new BN(seckey));
      if (bn2.cmp(ecparams.n) >= 0)
        bn2.isub(ecparams.n);
      if (bn2.isZero())
        return 1;
      const tweaked = bn2.toArrayLike(Uint8Array, "be", 32);
      seckey.set(tweaked);
      return 0;
    },
    privateKeyTweakMul(seckey, tweak) {
      let bn2 = new BN(tweak);
      if (bn2.cmp(ecparams.n) >= 0 || bn2.isZero())
        return 1;
      bn2.imul(new BN(seckey));
      if (bn2.cmp(ecparams.n) >= 0)
        bn2 = bn2.umod(ecparams.n);
      const tweaked = bn2.toArrayLike(Uint8Array, "be", 32);
      seckey.set(tweaked);
      return 0;
    },
    publicKeyVerify(pubkey) {
      const pair = loadPublicKey(pubkey);
      return pair === null ? 1 : 0;
    },
    publicKeyCreate(output2, seckey) {
      const bn2 = new BN(seckey);
      if (bn2.cmp(ecparams.n) >= 0 || bn2.isZero())
        return 1;
      const point2 = ec.keyFromPrivate(seckey).getPublic();
      savePublicKey(output2, point2);
      return 0;
    },
    publicKeyConvert(output2, pubkey) {
      const pair = loadPublicKey(pubkey);
      if (pair === null)
        return 1;
      const point2 = pair.getPublic();
      savePublicKey(output2, point2);
      return 0;
    },
    publicKeyNegate(output2, pubkey) {
      const pair = loadPublicKey(pubkey);
      if (pair === null)
        return 1;
      const point2 = pair.getPublic();
      point2.y = point2.y.redNeg();
      savePublicKey(output2, point2);
      return 0;
    },
    publicKeyCombine(output2, pubkeys) {
      const pairs = new Array(pubkeys.length);
      for (let i2 = 0; i2 < pubkeys.length; ++i2) {
        pairs[i2] = loadPublicKey(pubkeys[i2]);
        if (pairs[i2] === null)
          return 1;
      }
      let point2 = pairs[0].getPublic();
      for (let i2 = 1; i2 < pairs.length; ++i2)
        point2 = point2.add(pairs[i2].pub);
      if (point2.isInfinity())
        return 2;
      savePublicKey(output2, point2);
      return 0;
    },
    publicKeyTweakAdd(output2, pubkey, tweak) {
      const pair = loadPublicKey(pubkey);
      if (pair === null)
        return 1;
      tweak = new BN(tweak);
      if (tweak.cmp(ecparams.n) >= 0)
        return 2;
      const point2 = pair.getPublic().add(ecparams.g.mul(tweak));
      if (point2.isInfinity())
        return 2;
      savePublicKey(output2, point2);
      return 0;
    },
    publicKeyTweakMul(output2, pubkey, tweak) {
      const pair = loadPublicKey(pubkey);
      if (pair === null)
        return 1;
      tweak = new BN(tweak);
      if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero())
        return 2;
      const point2 = pair.getPublic().mul(tweak);
      savePublicKey(output2, point2);
      return 0;
    },
    signatureNormalize(sig) {
      const r2 = new BN(sig.subarray(0, 32));
      const s2 = new BN(sig.subarray(32, 64));
      if (r2.cmp(ecparams.n) >= 0 || s2.cmp(ecparams.n) >= 0)
        return 1;
      if (s2.cmp(ec.nh) === 1) {
        sig.set(ecparams.n.sub(s2).toArrayLike(Uint8Array, "be", 32), 32);
      }
      return 0;
    },
    // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
    // Adapted for Uint8Array instead Buffer
    signatureExport(obj, sig) {
      const sigR = sig.subarray(0, 32);
      const sigS = sig.subarray(32, 64);
      if (new BN(sigR).cmp(ecparams.n) >= 0)
        return 1;
      if (new BN(sigS).cmp(ecparams.n) >= 0)
        return 1;
      const { output: output2 } = obj;
      let r2 = output2.subarray(4, 4 + 33);
      r2[0] = 0;
      r2.set(sigR, 1);
      let lenR = 33;
      let posR = 0;
      for (; lenR > 1 && r2[posR] === 0 && !(r2[posR + 1] & 128); --lenR, ++posR)
        ;
      r2 = r2.subarray(posR);
      if (r2[0] & 128)
        return 1;
      if (lenR > 1 && r2[0] === 0 && !(r2[1] & 128))
        return 1;
      let s2 = output2.subarray(6 + 33, 6 + 33 + 33);
      s2[0] = 0;
      s2.set(sigS, 1);
      let lenS = 33;
      let posS = 0;
      for (; lenS > 1 && s2[posS] === 0 && !(s2[posS + 1] & 128); --lenS, ++posS)
        ;
      s2 = s2.subarray(posS);
      if (s2[0] & 128)
        return 1;
      if (lenS > 1 && s2[0] === 0 && !(s2[1] & 128))
        return 1;
      obj.outputlen = 6 + lenR + lenS;
      output2[0] = 48;
      output2[1] = obj.outputlen - 2;
      output2[2] = 2;
      output2[3] = r2.length;
      output2.set(r2, 4);
      output2[4 + lenR] = 2;
      output2[5 + lenR] = s2.length;
      output2.set(s2, 6 + lenR);
      return 0;
    },
    // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
    // Adapted for Uint8Array instead Buffer
    signatureImport(output2, sig) {
      if (sig.length < 8)
        return 1;
      if (sig.length > 72)
        return 1;
      if (sig[0] !== 48)
        return 1;
      if (sig[1] !== sig.length - 2)
        return 1;
      if (sig[2] !== 2)
        return 1;
      const lenR = sig[3];
      if (lenR === 0)
        return 1;
      if (5 + lenR >= sig.length)
        return 1;
      if (sig[4 + lenR] !== 2)
        return 1;
      const lenS = sig[5 + lenR];
      if (lenS === 0)
        return 1;
      if (6 + lenR + lenS !== sig.length)
        return 1;
      if (sig[4] & 128)
        return 1;
      if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128))
        return 1;
      if (sig[lenR + 6] & 128)
        return 1;
      if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128))
        return 1;
      let sigR = sig.subarray(4, 4 + lenR);
      if (sigR.length === 33 && sigR[0] === 0)
        sigR = sigR.subarray(1);
      if (sigR.length > 32)
        return 1;
      let sigS = sig.subarray(6 + lenR);
      if (sigS.length === 33 && sigS[0] === 0)
        sigS = sigS.slice(1);
      if (sigS.length > 32)
        throw new Error("S length is too long");
      let r2 = new BN(sigR);
      if (r2.cmp(ecparams.n) >= 0)
        r2 = new BN(0);
      let s2 = new BN(sig.subarray(6 + lenR));
      if (s2.cmp(ecparams.n) >= 0)
        s2 = new BN(0);
      output2.set(r2.toArrayLike(Uint8Array, "be", 32), 0);
      output2.set(s2.toArrayLike(Uint8Array, "be", 32), 32);
      return 0;
    },
    ecdsaSign(obj, message2, seckey, data2, noncefn) {
      if (noncefn) {
        const _noncefn = noncefn;
        noncefn = (counter) => {
          const nonce = _noncefn(message2, seckey, null, data2, counter);
          const isValid = nonce instanceof Uint8Array && nonce.length === 32;
          if (!isValid)
            throw new Error("This is the way");
          return new BN(nonce);
        };
      }
      const d = new BN(seckey);
      if (d.cmp(ecparams.n) >= 0 || d.isZero())
        return 1;
      let sig;
      try {
        sig = ec.sign(message2, seckey, { canonical: true, k: noncefn, pers: data2 });
      } catch (err) {
        return 1;
      }
      obj.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
      obj.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
      obj.recid = sig.recoveryParam;
      return 0;
    },
    ecdsaVerify(sig, msg32, pubkey) {
      const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
      const sigr = new BN(sigObj.r);
      const sigs = new BN(sigObj.s);
      if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
        return 1;
      if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero())
        return 3;
      const pair = loadPublicKey(pubkey);
      if (pair === null)
        return 2;
      const point2 = pair.getPublic();
      const isValid = ec.verify(msg32, sigObj, point2);
      return isValid ? 0 : 3;
    },
    ecdsaRecover(output2, sig, recid, msg32) {
      const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
      const sigr = new BN(sigObj.r);
      const sigs = new BN(sigObj.s);
      if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
        return 1;
      if (sigr.isZero() || sigs.isZero())
        return 2;
      let point2;
      try {
        point2 = ec.recoverPubKey(msg32, sigObj, recid);
      } catch (err) {
        return 2;
      }
      savePublicKey(output2, point2);
      return 0;
    },
    ecdh(output2, pubkey, seckey, data2, hashfn, xbuf, ybuf) {
      const pair = loadPublicKey(pubkey);
      if (pair === null)
        return 1;
      const scalar = new BN(seckey);
      if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero())
        return 2;
      const point2 = pair.getPublic().mul(scalar);
      if (hashfn === void 0) {
        const data3 = point2.encode(null, true);
        const sha2562 = ec.hash().update(data3).digest();
        for (let i2 = 0; i2 < 32; ++i2)
          output2[i2] = sha2562[i2];
      } else {
        if (!xbuf)
          xbuf = new Uint8Array(32);
        const x = point2.getX().toArray("be", 32);
        for (let i2 = 0; i2 < 32; ++i2)
          xbuf[i2] = x[i2];
        if (!ybuf)
          ybuf = new Uint8Array(32);
        const y = point2.getY().toArray("be", 32);
        for (let i2 = 0; i2 < 32; ++i2)
          ybuf[i2] = y[i2];
        const hash2 = hashfn(xbuf, ybuf, data2);
        const isValid = hash2 instanceof Uint8Array && hash2.length === output2.length;
        if (!isValid)
          return 2;
        output2.set(hash2);
      }
      return 0;
    }
  };
  var elliptic = lib(elliptic$1);
  var random = {};
  Object.defineProperty(random, "__esModule", { value: true });
  var randombytes = browserExports;
  function getRandomBytes(bytes2) {
    return new Promise(function(resolve, reject) {
      randombytes(bytes2, function(err, resp) {
        if (err) {
          reject(err);
          return;
        }
        resolve(resp);
      });
    });
  }
  random.getRandomBytes = getRandomBytes;
  function getRandomBytesSync(bytes2) {
    return randombytes(bytes2);
  }
  random.getRandomBytesSync = getRandomBytesSync;
  (function(exports2) {
    var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n2) {
        return function(v) {
          return step([n2, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t[1]) {
                  _2.label = t[1];
                  t = op;
                  break;
                }
                if (t && _2.label < t[2]) {
                  _2.label = t[2];
                  _2.ops.push(op);
                  break;
                }
                if (t[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    function __export(m) {
      for (var p2 in m)
        if (!exports2.hasOwnProperty(p2))
          exports2[p2] = m[p2];
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    var secp256k1_12 = elliptic;
    var random_1 = random;
    var SECP256K1_PRIVATE_KEY_SIZE = 32;
    function createPrivateKey() {
      return __awaiter(this, void 0, void 0, function() {
        var pk;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, random_1.getRandomBytes(SECP256K1_PRIVATE_KEY_SIZE)];
            case 1:
              pk = _a2.sent();
              if (secp256k1_12.privateKeyVerify(pk)) {
                return [2, pk];
              }
              return [3, 0];
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    exports2.createPrivateKey = createPrivateKey;
    function createPrivateKeySync() {
      while (true) {
        var pk = random_1.getRandomBytesSync(SECP256K1_PRIVATE_KEY_SIZE);
        if (secp256k1_12.privateKeyVerify(pk)) {
          return pk;
        }
      }
    }
    exports2.createPrivateKeySync = createPrivateKeySync;
    __export(elliptic);
  })(secp256k1);
  var internal = {};
  Object.defineProperty(internal, "__esModule", { value: true });
  internal.isHexString = internal.getKeys = internal.fromAscii = internal.fromUtf8 = internal.toAscii = internal.arrayContainsArray = internal.getBinarySize = internal.padToEven = internal.stripHexPrefix = internal.isHexPrefixed = void 0;
  function isHexPrefixed(str) {
    if (typeof str !== "string") {
      throw new Error("[isHexPrefixed] input must be type 'string', received type ".concat(typeof str));
    }
    return str[0] === "0" && str[1] === "x";
  }
  internal.isHexPrefixed = isHexPrefixed;
  var stripHexPrefix = function(str) {
    if (typeof str !== "string")
      throw new Error("[stripHexPrefix] input must be type 'string', received ".concat(typeof str));
    return isHexPrefixed(str) ? str.slice(2) : str;
  };
  internal.stripHexPrefix = stripHexPrefix;
  function padToEven(value) {
    var a = value;
    if (typeof a !== "string") {
      throw new Error("[padToEven] value must be type 'string', received ".concat(typeof a));
    }
    if (a.length % 2)
      a = "0".concat(a);
    return a;
  }
  internal.padToEven = padToEven;
  function getBinarySize(str) {
    if (typeof str !== "string") {
      throw new Error("[getBinarySize] method requires input type 'string', recieved ".concat(typeof str));
    }
    return buffer$2.Buffer.byteLength(str, "utf8");
  }
  internal.getBinarySize = getBinarySize;
  function arrayContainsArray(superset, subset, some) {
    if (Array.isArray(superset) !== true) {
      throw new Error("[arrayContainsArray] method requires input 'superset' to be an array, got type '".concat(typeof superset, "'"));
    }
    if (Array.isArray(subset) !== true) {
      throw new Error("[arrayContainsArray] method requires input 'subset' to be an array, got type '".concat(typeof subset, "'"));
    }
    return subset[some ? "some" : "every"](function(value) {
      return superset.indexOf(value) >= 0;
    });
  }
  internal.arrayContainsArray = arrayContainsArray;
  function toAscii(hex) {
    var str = "";
    var i2 = 0;
    var l = hex.length;
    if (hex.substring(0, 2) === "0x")
      i2 = 2;
    for (; i2 < l; i2 += 2) {
      var code2 = parseInt(hex.substr(i2, 2), 16);
      str += String.fromCharCode(code2);
    }
    return str;
  }
  internal.toAscii = toAscii;
  function fromUtf8(stringValue) {
    var str = buffer$2.Buffer.from(stringValue, "utf8");
    return "0x".concat(padToEven(str.toString("hex")).replace(/^0+|0+$/g, ""));
  }
  internal.fromUtf8 = fromUtf8;
  function fromAscii(stringValue) {
    var hex = "";
    for (var i2 = 0; i2 < stringValue.length; i2++) {
      var code2 = stringValue.charCodeAt(i2);
      var n2 = code2.toString(16);
      hex += n2.length < 2 ? "0".concat(n2) : n2;
    }
    return "0x".concat(hex);
  }
  internal.fromAscii = fromAscii;
  function getKeys(params, key2, allowEmpty) {
    if (!Array.isArray(params)) {
      throw new Error("[getKeys] method expects input 'params' to be an array, got ".concat(typeof params));
    }
    if (typeof key2 !== "string") {
      throw new Error("[getKeys] method expects input 'key' to be type 'string', got ".concat(typeof params));
    }
    var result = [];
    for (var i2 = 0; i2 < params.length; i2++) {
      var value = params[i2][key2];
      if (allowEmpty && !value) {
        value = "";
      } else if (typeof value !== "string") {
        throw new Error("invalid abi - expected type 'string', received ".concat(typeof value));
      }
      result.push(value);
    }
    return result;
  }
  internal.getKeys = getKeys;
  function isHexString(value, length) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/))
      return false;
    if (length && value.length !== 2 + 2 * length)
      return false;
    return true;
  }
  internal.isHexString = isHexString;
  var bytes = {};
  var helpers = {};
  Object.defineProperty(helpers, "__esModule", { value: true });
  helpers.assertIsString = helpers.assertIsArray = helpers.assertIsBuffer = helpers.assertIsHexString = void 0;
  var internal_1$1 = internal;
  var assertIsHexString = function(input2) {
    if (!(0, internal_1$1.isHexString)(input2)) {
      var msg = "This method only supports 0x-prefixed hex strings but input was: ".concat(input2);
      throw new Error(msg);
    }
  };
  helpers.assertIsHexString = assertIsHexString;
  var assertIsBuffer = function(input2) {
    if (!buffer$2.Buffer.isBuffer(input2)) {
      var msg = "This method only supports Buffer but input was: ".concat(input2);
      throw new Error(msg);
    }
  };
  helpers.assertIsBuffer = assertIsBuffer;
  var assertIsArray = function(input2) {
    if (!Array.isArray(input2)) {
      var msg = "This method only supports number arrays but input was: ".concat(input2);
      throw new Error(msg);
    }
  };
  helpers.assertIsArray = assertIsArray;
  var assertIsString = function(input2) {
    if (typeof input2 !== "string") {
      var msg = "This method only supports strings but input was: ".concat(input2);
      throw new Error(msg);
    }
  };
  helpers.assertIsString = assertIsString;
  (function(exports2) {
    var __values = commonjsGlobal && commonjsGlobal.__values || function(o) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i2 = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i2 >= o.length)
              o = void 0;
            return { value: o && o[i2++], done: !o };
          }
        };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i2 = m.call(o), r2, ar = [], e;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
          ar.push(r2.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m = i2["return"]))
            m.call(i2);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufArrToArr = exports2.arrToBufArr = exports2.validateNoLeadingZeroes = exports2.baToJSON = exports2.toUtf8 = exports2.addHexPrefix = exports2.toUnsigned = exports2.fromSigned = exports2.bufferToHex = exports2.bufferToInt = exports2.toBuffer = exports2.unpadHexString = exports2.unpadArray = exports2.unpadBuffer = exports2.setLengthRight = exports2.setLengthLeft = exports2.zeros = exports2.intToBuffer = exports2.intToHex = void 0;
    var externals_12 = externals;
    var internal_12 = internal;
    var helpers_12 = helpers;
    var intToHex2 = function(i2) {
      if (!Number.isSafeInteger(i2) || i2 < 0) {
        throw new Error("Received an invalid integer type: ".concat(i2));
      }
      return "0x".concat(i2.toString(16));
    };
    exports2.intToHex = intToHex2;
    var intToBuffer2 = function(i2) {
      var hex = (0, exports2.intToHex)(i2);
      return buffer$2.Buffer.from((0, internal_12.padToEven)(hex.slice(2)), "hex");
    };
    exports2.intToBuffer = intToBuffer2;
    var zeros = function(bytes2) {
      return buffer$2.Buffer.allocUnsafe(bytes2).fill(0);
    };
    exports2.zeros = zeros;
    var setLength = function(msg, length, right) {
      var buf = (0, exports2.zeros)(length);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    var setLengthLeft = function(msg, length) {
      (0, helpers_12.assertIsBuffer)(msg);
      return setLength(msg, length, false);
    };
    exports2.setLengthLeft = setLengthLeft;
    var setLengthRight = function(msg, length) {
      (0, helpers_12.assertIsBuffer)(msg);
      return setLength(msg, length, true);
    };
    exports2.setLengthRight = setLengthRight;
    var stripZeros = function(a) {
      var first = a[0];
      while (a.length > 0 && first.toString() === "0") {
        a = a.slice(1);
        first = a[0];
      }
      return a;
    };
    var unpadBuffer = function(a) {
      (0, helpers_12.assertIsBuffer)(a);
      return stripZeros(a);
    };
    exports2.unpadBuffer = unpadBuffer;
    var unpadArray = function(a) {
      (0, helpers_12.assertIsArray)(a);
      return stripZeros(a);
    };
    exports2.unpadArray = unpadArray;
    var unpadHexString = function(a) {
      (0, helpers_12.assertIsHexString)(a);
      a = (0, internal_12.stripHexPrefix)(a);
      return stripZeros(a);
    };
    exports2.unpadHexString = unpadHexString;
    var toBuffer2 = function(v) {
      if (v === null || v === void 0) {
        return buffer$2.Buffer.allocUnsafe(0);
      }
      if (buffer$2.Buffer.isBuffer(v)) {
        return buffer$2.Buffer.from(v);
      }
      if (Array.isArray(v) || v instanceof Uint8Array) {
        return buffer$2.Buffer.from(v);
      }
      if (typeof v === "string") {
        if (!(0, internal_12.isHexString)(v)) {
          throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ".concat(v));
        }
        return buffer$2.Buffer.from((0, internal_12.padToEven)((0, internal_12.stripHexPrefix)(v)), "hex");
      }
      if (typeof v === "number") {
        return (0, exports2.intToBuffer)(v);
      }
      if (externals_12.BN.isBN(v)) {
        if (v.isNeg()) {
          throw new Error("Cannot convert negative BN to buffer. Given: ".concat(v));
        }
        return v.toArrayLike(buffer$2.Buffer);
      }
      if (v.toArray) {
        return buffer$2.Buffer.from(v.toArray());
      }
      if (v.toBuffer) {
        return buffer$2.Buffer.from(v.toBuffer());
      }
      throw new Error("invalid type");
    };
    exports2.toBuffer = toBuffer2;
    var bufferToInt2 = function(buf) {
      return new externals_12.BN((0, exports2.toBuffer)(buf)).toNumber();
    };
    exports2.bufferToInt = bufferToInt2;
    var bufferToHex = function(buf) {
      buf = (0, exports2.toBuffer)(buf);
      return "0x" + buf.toString("hex");
    };
    exports2.bufferToHex = bufferToHex;
    var fromSigned = function(num) {
      return new externals_12.BN(num).fromTwos(256);
    };
    exports2.fromSigned = fromSigned;
    var toUnsigned = function(num) {
      return buffer$2.Buffer.from(num.toTwos(256).toArray());
    };
    exports2.toUnsigned = toUnsigned;
    var addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return (0, internal_12.isHexPrefixed)(str) ? str : "0x" + str;
    };
    exports2.addHexPrefix = addHexPrefix;
    var toUtf8 = function(hex) {
      var zerosRegexp = /^(00)+|(00)+$/g;
      hex = (0, internal_12.stripHexPrefix)(hex);
      if (hex.length % 2 !== 0) {
        throw new Error("Invalid non-even hex string input for toUtf8() provided");
      }
      var bufferVal = buffer$2.Buffer.from(hex.replace(zerosRegexp, ""), "hex");
      return bufferVal.toString("utf8");
    };
    exports2.toUtf8 = toUtf8;
    var baToJSON = function(ba) {
      if (buffer$2.Buffer.isBuffer(ba)) {
        return "0x".concat(ba.toString("hex"));
      } else if (ba instanceof Array) {
        var array = [];
        for (var i2 = 0; i2 < ba.length; i2++) {
          array.push((0, exports2.baToJSON)(ba[i2]));
        }
        return array;
      }
    };
    exports2.baToJSON = baToJSON;
    var validateNoLeadingZeroes = function(values) {
      var e_1, _a2;
      try {
        for (var _b = __values(Object.entries(values)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read(_c.value, 2), k2 = _d[0], v = _d[1];
          if (v !== void 0 && v.length > 0 && v[0] === 0) {
            throw new Error("".concat(k2, " cannot have leading zeroes, received: ").concat(v.toString("hex")));
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    exports2.validateNoLeadingZeroes = validateNoLeadingZeroes;
    function arrToBufArr(arr) {
      if (!Array.isArray(arr)) {
        return buffer$2.Buffer.from(arr);
      }
      return arr.map(function(a) {
        return arrToBufArr(a);
      });
    }
    exports2.arrToBufArr = arrToBufArr;
    function bufArrToArr(arr) {
      if (!Array.isArray(arr)) {
        return Uint8Array.from(arr !== null && arr !== void 0 ? arr : []);
      }
      return arr.map(function(a) {
        return bufArrToArr(a);
      });
    }
    exports2.bufArrToArr = bufArrToArr;
  })(bytes);
  var hash$1 = {};
  var keccak$2 = {};
  var hashUtils = {};
  Object.defineProperty(hashUtils, "__esModule", { value: true });
  function createHashFunction(hashConstructor) {
    return function(msg) {
      var hash2 = hashConstructor();
      hash2.update(msg);
      return buffer$2.Buffer.from(hash2.digest());
    };
  }
  hashUtils.createHashFunction = createHashFunction;
  var readableBrowser = { exports: {} };
  var streamBrowser = require$$1$1.EventEmitter;
  var buffer_list;
  var hasRequiredBuffer_list;
  function requireBuffer_list() {
    if (hasRequiredBuffer_list)
      return buffer_list;
    hasRequiredBuffer_list = 1;
    function ownKeys(object2, enumerableOnly) {
      var keys = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
          _defineProperty(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _defineProperty(obj, key2, value) {
      key2 = _toPropertyKey(key2);
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key2 = _toPrimitive(arg, "string");
      return typeof key2 === "symbol" ? key2 : String(key2);
    }
    function _toPrimitive(input2, hint) {
      if (typeof input2 !== "object" || input2 === null)
        return input2;
      var prim = input2[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input2, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input2);
    }
    var _require = buffer$2, Buffer2 = _require.Buffer;
    var _require2 = require$$1$1, inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src2, target, offset) {
      Buffer2.prototype.copy.call(src2, target, offset);
    }
    buffer_list = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s2) {
          if (this.length === 0)
            return "";
          var p2 = this.head;
          var ret = "" + p2.data;
          while (p2 = p2.next)
            ret += s2 + p2.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat2(n2) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n2 >>> 0);
          var p2 = this.head;
          var i2 = 0;
          while (p2) {
            copyBuffer(p2.data, ret, i2);
            i2 += p2.data.length;
            p2 = p2.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n2, hasStrings) {
          var ret;
          if (n2 < this.head.data.length) {
            ret = this.head.data.slice(0, n2);
            this.head.data = this.head.data.slice(n2);
          } else if (n2 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n2) : this._getBuffer(n2);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n2) {
          var p2 = this.head;
          var c = 1;
          var ret = p2.data;
          n2 -= ret.length;
          while (p2 = p2.next) {
            var str = p2.data;
            var nb = n2 > str.length ? str.length : n2;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n2);
            n2 -= nb;
            if (n2 === 0) {
              if (nb === str.length) {
                ++c;
                if (p2.next)
                  this.head = p2.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p2;
                p2.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n2) {
          var ret = Buffer2.allocUnsafe(n2);
          var p2 = this.head;
          var c = 1;
          p2.data.copy(ret);
          n2 -= p2.data.length;
          while (p2 = p2.next) {
            var buf = p2.data;
            var nb = n2 > buf.length ? buf.length : n2;
            buf.copy(ret, ret.length - n2, 0, nb);
            n2 -= nb;
            if (n2 === 0) {
              if (nb === buf.length) {
                ++c;
                if (p2.next)
                  this.head = p2.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p2;
                p2.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_2, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
    return buffer_list;
  }
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream.destroy(err);
    else
      stream.emit("error", err);
  }
  var destroy_1 = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  var errorsBrowser = {};
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var codes = {};
  function createErrorType(code2, message2, Base2) {
    if (!Base2) {
      Base2 = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message2 === "string") {
        return message2;
      } else {
        return message2(arg1, arg2, arg3);
      }
    }
    var NodeError = /* @__PURE__ */ function(_Base) {
      _inheritsLoose(NodeError2, _Base);
      function NodeError2(arg1, arg2, arg3) {
        return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
      }
      return NodeError2;
    }(Base2);
    NodeError.prototype.name = Base2.name;
    NodeError.prototype.code = code2;
    codes[code2] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      var len2 = expected.length;
      expected = expected.map(function(i2) {
        return String(i2);
      });
      if (len2 > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len2 - 1).join(", "), ", or ") + expected[len2 - 1];
      } else if (len2 === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
    return 'The value "' + value + '" is invalid for option "' + name2 + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    var msg;
    if (endsWith(name2, " argument")) {
      msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } else {
      var type2 = includes(name2, ".") ? "property" : "argument";
      msg = 'The "'.concat(name2, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
    return "The " + name2 + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name2) {
    return "Cannot call " + name2 + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  errorsBrowser.codes = codes;
  var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state2, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name2 = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name2, hwm);
      }
      return Math.floor(hwm);
    }
    return state2.objectMode ? 16 : 16 * 1024;
  }
  var state = {
    getHighWaterMark
  };
  var browser$1 = deprecate;
  function deprecate(fn, msg) {
    if (config("noDeprecation")) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config("throwDeprecation")) {
          throw new Error(msg);
        } else if (config("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  function config(name2) {
    try {
      if (!commonjsGlobal.localStorage)
        return false;
    } catch (_2) {
      return false;
    }
    var val = commonjsGlobal.localStorage[name2];
    if (null == val)
      return false;
    return String(val).toLowerCase() === "true";
  }
  var _stream_writable;
  var hasRequired_stream_writable;
  function require_stream_writable() {
    if (hasRequired_stream_writable)
      return _stream_writable;
    hasRequired_stream_writable = 1;
    _stream_writable = Writable;
    function CorkedRequest(state2) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state2);
      };
    }
    var Duplex2;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: browser$1
    };
    var Stream = streamBrowser;
    var Buffer2 = buffer$2.Buffer;
    var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = destroy_1;
    var _require = state, getHighWaterMark2 = _require.getHighWaterMark;
    var _require$codes2 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED2 = _require$codes2.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK2 = _require$codes2.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes2.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED2 = _require$codes2.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes2.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes2.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes2.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy2 = destroyImpl.errorOrDestroy;
    inherits_browserExports$1(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex2 = Duplex2 || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark2(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object2) {
          if (realHasInstance.call(this, object2))
            return true;
          if (this !== Writable)
            return false;
          return object2 && object2._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object2) {
        return object2 instanceof this;
      };
    }
    function Writable(options) {
      Duplex2 = Duplex2 || require_stream_duplex();
      var isDuplex = this instanceof Duplex2;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy2(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state2, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state2.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy2(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state2 = this._writableState;
      var ret = false;
      var isBuf = !state2.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state2.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state2.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state2, chunk, cb)) {
        state2.pendingcb++;
        ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state2 = this._writableState;
      if (state2.corked) {
        state2.corked--;
        if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
          clearBuffer(this, state2);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state2, chunk, encoding) {
      if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state2, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len2 = state2.objectMode ? 1 : chunk.length;
      state2.length += len2;
      var ret = state2.length < state2.highWaterMark;
      if (!ret)
        state2.needDrain = true;
      if (state2.writing || state2.corked) {
        var last = state2.lastBufferedRequest;
        state2.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state2.lastBufferedRequest;
        } else {
          state2.bufferedRequest = state2.lastBufferedRequest;
        }
        state2.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state2, false, len2, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state2, writev, len2, chunk, encoding, cb) {
      state2.writelen = len2;
      state2.writecb = cb;
      state2.writing = true;
      state2.sync = true;
      if (state2.destroyed)
        state2.onwrite(new ERR_STREAM_DESTROYED2("write"));
      else if (writev)
        stream._writev(chunk, state2.onwrite);
      else
        stream._write(chunk, encoding, state2.onwrite);
      state2.sync = false;
    }
    function onwriteError(stream, state2, sync, er, cb) {
      --state2.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state2);
        stream._writableState.errorEmitted = true;
        errorOrDestroy2(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy2(stream, er);
        finishMaybe(stream, state2);
      }
    }
    function onwriteStateUpdate(state2) {
      state2.writing = false;
      state2.writecb = null;
      state2.length -= state2.writelen;
      state2.writelen = 0;
    }
    function onwrite(stream, er) {
      var state2 = stream._writableState;
      var sync = state2.sync;
      var cb = state2.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK2();
      onwriteStateUpdate(state2);
      if (er)
        onwriteError(stream, state2, sync, er, cb);
      else {
        var finished = needFinish(state2) || stream.destroyed;
        if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
          clearBuffer(stream, state2);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state2, finished, cb);
        } else {
          afterWrite(stream, state2, finished, cb);
        }
      }
    }
    function afterWrite(stream, state2, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state2);
      state2.pendingcb--;
      cb();
      finishMaybe(stream, state2);
    }
    function onwriteDrain(stream, state2) {
      if (state2.length === 0 && state2.needDrain) {
        state2.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state2) {
      state2.bufferProcessing = true;
      var entry = state2.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state2.bufferedRequestCount;
        var buffer2 = new Array(l);
        var holder = state2.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
        state2.pendingcb++;
        state2.lastBufferedRequest = null;
        if (holder.next) {
          state2.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state2.corkedRequestsFree = new CorkedRequest(state2);
        }
        state2.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len2 = state2.objectMode ? 1 : chunk.length;
          doWrite(stream, state2, false, len2, chunk, encoding, cb);
          entry = entry.next;
          state2.bufferedRequestCount--;
          if (state2.writing) {
            break;
          }
        }
        if (entry === null)
          state2.lastBufferedRequest = null;
      }
      state2.bufferedRequest = entry;
      state2.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED2("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state2 = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state2.corked) {
        state2.corked = 1;
        this.uncork();
      }
      if (!state2.ending)
        endWritable(this, state2, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState.length;
      }
    });
    function needFinish(state2) {
      return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
    }
    function callFinal(stream, state2) {
      stream._final(function(err) {
        state2.pendingcb--;
        if (err) {
          errorOrDestroy2(stream, err);
        }
        state2.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state2);
      });
    }
    function prefinish2(stream, state2) {
      if (!state2.prefinished && !state2.finalCalled) {
        if (typeof stream._final === "function" && !state2.destroyed) {
          state2.pendingcb++;
          state2.finalCalled = true;
          process.nextTick(callFinal, stream, state2);
        } else {
          state2.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state2) {
      var need = needFinish(state2);
      if (need) {
        prefinish2(stream, state2);
        if (state2.pendingcb === 0) {
          state2.finished = true;
          stream.emit("finish");
          if (state2.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state2, cb) {
      state2.ending = true;
      finishMaybe(stream, state2);
      if (cb) {
        if (state2.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state2.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state2, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state2.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state2.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    return _stream_writable;
  }
  var _stream_duplex;
  var hasRequired_stream_duplex;
  function require_stream_duplex() {
    if (hasRequired_stream_duplex)
      return _stream_duplex;
    hasRequired_stream_duplex = 1;
    var objectKeys2 = Object.keys || function(obj) {
      var keys2 = [];
      for (var key2 in obj)
        keys2.push(key2);
      return keys2;
    };
    _stream_duplex = Duplex2;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    inherits_browserExports$1(Duplex2, Readable);
    {
      var keys = objectKeys2(Writable.prototype);
      for (var v = 0; v < keys.length; v++) {
        var method2 = keys[v];
        if (!Duplex2.prototype[method2])
          Duplex2.prototype[method2] = Writable.prototype[method2];
      }
    }
    function Duplex2(options) {
      if (!(this instanceof Duplex2))
        return new Duplex2(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    return _stream_duplex;
  }
  var string_decoder = {};
  var Buffer$b = safeBufferExports.Buffer;
  var isEncoding = Buffer$b.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer$b.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder$1;
  function StringDecoder$1(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer$b.allocUnsafe(nb);
  }
  StringDecoder$1.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r2;
    var i2;
    if (this.lastNeed) {
      r2 = this.fillLast(buf);
      if (r2 === void 0)
        return "";
      i2 = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i2 = 0;
    }
    if (i2 < buf.length)
      return r2 ? r2 + this.text(buf, i2) : this.text(buf, i2);
    return r2 || "";
  };
  StringDecoder$1.prototype.end = utf8End;
  StringDecoder$1.prototype.text = utf8Text;
  StringDecoder$1.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i2) {
    var j = buf.length - 1;
    if (j < i2)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i2 || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i2 || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p2) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p2 = this.lastTotal - this.lastNeed;
    var r2 = utf8CheckExtraBytes(this, buf);
    if (r2 !== void 0)
      return r2;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p2, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p2, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i2) {
    var total = utf8CheckIncomplete(this, buf, i2);
    if (!this.lastNeed)
      return buf.toString("utf8", i2);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i2, end);
  }
  function utf8End(buf) {
    var r2 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r2 + "�";
    return r2;
  }
  function utf16Text(buf, i2) {
    if ((buf.length - i2) % 2 === 0) {
      var r2 = buf.toString("utf16le", i2);
      if (r2) {
        var c = r2.charCodeAt(r2.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r2.slice(0, -1);
        }
      }
      return r2;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i2, buf.length - 1);
  }
  function utf16End(buf) {
    var r2 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r2 + this.lastChar.toString("utf16le", 0, end);
    }
    return r2;
  }
  function base64Text(buf, i2) {
    var n2 = (buf.length - i2) % 3;
    if (n2 === 0)
      return buf.toString("base64", i2);
    this.lastNeed = 3 - n2;
    this.lastTotal = 3;
    if (n2 === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i2, buf.length - n2);
  }
  function base64End(buf) {
    var r2 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r2;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
  function once$1(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop$1() {
  }
  function isRequest$1(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos$1(stream, opts, callback) {
    if (typeof opts === "function")
      return eos$1(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once$1(callback || noop$1);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable)
        onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest$1(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  var endOfStream = eos$1;
  var async_iterator;
  var hasRequiredAsync_iterator;
  function requireAsync_iterator() {
    if (hasRequiredAsync_iterator)
      return async_iterator;
    hasRequiredAsync_iterator = 1;
    var _Object$setPrototypeO;
    function _defineProperty(obj, key2, value) {
      key2 = _toPropertyKey(key2);
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key2 = _toPrimitive(arg, "string");
      return typeof key2 === "symbol" ? key2 : String(key2);
    }
    function _toPrimitive(input2, hint) {
      if (typeof input2 !== "object" || input2 === null)
        return input2;
      var prim = input2[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input2, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input2);
    }
    var finished = endOfStream;
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done2) {
      return {
        value,
        done: done2
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data2 = iter[kStream].read();
        if (data2 !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data2, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data2 = this[kStream].read();
          if (data2 !== null) {
            return Promise.resolve(createIterResult(data2, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data2 = iterator[kStream].read();
          if (data2) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data2, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    async_iterator = createReadableStreamAsyncIterator;
    return async_iterator;
  }
  var fromBrowser;
  var hasRequiredFromBrowser;
  function requireFromBrowser() {
    if (hasRequiredFromBrowser)
      return fromBrowser;
    hasRequiredFromBrowser = 1;
    fromBrowser = function() {
      throw new Error("Readable.from is not available in the browser");
    };
    return fromBrowser;
  }
  var _stream_readable;
  var hasRequired_stream_readable;
  function require_stream_readable() {
    if (hasRequired_stream_readable)
      return _stream_readable;
    hasRequired_stream_readable = 1;
    _stream_readable = Readable;
    var Duplex2;
    Readable.ReadableState = ReadableState;
    require$$1$1.EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type2) {
      return emitter.listeners(type2).length;
    };
    var Stream = streamBrowser;
    var Buffer2 = buffer$2.Buffer;
    var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require$$1$1;
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = requireBuffer_list();
    var destroyImpl = destroy_1;
    var _require = state, getHighWaterMark2 = _require.getHighWaterMark;
    var _require$codes2 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes2.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED2 = _require$codes2.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder2;
    var createReadableStreamAsyncIterator;
    var from;
    inherits_browserExports$1(Readable, Stream);
    var errorOrDestroy2 = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex2 = Duplex2 || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark2(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder2)
          StringDecoder2 = string_decoder.StringDecoder;
        this.decoder = new StringDecoder2(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex2 = Duplex2 || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex2;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state2 = this._readableState;
      var skipChunkCheck;
      if (!state2.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state2.defaultEncoding;
          if (encoding !== state2.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state2 = stream._readableState;
      if (chunk === null) {
        state2.reading = false;
        onEofChunk(stream, state2);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state2, chunk);
        if (er) {
          errorOrDestroy2(stream, er);
        } else if (state2.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state2.endEmitted)
              errorOrDestroy2(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state2, chunk, true);
          } else if (state2.ended) {
            errorOrDestroy2(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state2.destroyed) {
            return false;
          } else {
            state2.reading = false;
            if (state2.decoder && !encoding) {
              chunk = state2.decoder.write(chunk);
              if (state2.objectMode || chunk.length !== 0)
                addChunk(stream, state2, chunk, false);
              else
                maybeReadMore(stream, state2);
            } else {
              addChunk(stream, state2, chunk, false);
            }
          }
        } else if (!addToFront) {
          state2.reading = false;
          maybeReadMore(stream, state2);
        }
      }
      return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
    }
    function addChunk(stream, state2, chunk, addToFront) {
      if (state2.flowing && state2.length === 0 && !state2.sync) {
        state2.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state2.length += state2.objectMode ? 1 : chunk.length;
        if (addToFront)
          state2.buffer.unshift(chunk);
        else
          state2.buffer.push(chunk);
        if (state2.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state2);
    }
    function chunkInvalid(state2, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder2)
        StringDecoder2 = string_decoder.StringDecoder;
      var decoder = new StringDecoder2(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p2 = this._readableState.buffer.head;
      var content = "";
      while (p2 !== null) {
        content += decoder.write(p2.data);
        p2 = p2.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n2) {
      if (n2 >= MAX_HWM) {
        n2 = MAX_HWM;
      } else {
        n2--;
        n2 |= n2 >>> 1;
        n2 |= n2 >>> 2;
        n2 |= n2 >>> 4;
        n2 |= n2 >>> 8;
        n2 |= n2 >>> 16;
        n2++;
      }
      return n2;
    }
    function howMuchToRead(n2, state2) {
      if (n2 <= 0 || state2.length === 0 && state2.ended)
        return 0;
      if (state2.objectMode)
        return 1;
      if (n2 !== n2) {
        if (state2.flowing && state2.length)
          return state2.buffer.head.data.length;
        else
          return state2.length;
      }
      if (n2 > state2.highWaterMark)
        state2.highWaterMark = computeNewHighWaterMark(n2);
      if (n2 <= state2.length)
        return n2;
      if (!state2.ended) {
        state2.needReadable = true;
        return 0;
      }
      return state2.length;
    }
    Readable.prototype.read = function(n2) {
      debug("read", n2);
      n2 = parseInt(n2, 10);
      var state2 = this._readableState;
      var nOrig = n2;
      if (n2 !== 0)
        state2.emittedReadable = false;
      if (n2 === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
        debug("read: emitReadable", state2.length, state2.ended);
        if (state2.length === 0 && state2.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n2 = howMuchToRead(n2, state2);
      if (n2 === 0 && state2.ended) {
        if (state2.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state2.needReadable;
      debug("need readable", doRead);
      if (state2.length === 0 || state2.length - n2 < state2.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state2.ended || state2.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state2.reading = true;
        state2.sync = true;
        if (state2.length === 0)
          state2.needReadable = true;
        this._read(state2.highWaterMark);
        state2.sync = false;
        if (!state2.reading)
          n2 = howMuchToRead(nOrig, state2);
      }
      var ret;
      if (n2 > 0)
        ret = fromList(n2, state2);
      else
        ret = null;
      if (ret === null) {
        state2.needReadable = state2.length <= state2.highWaterMark;
        n2 = 0;
      } else {
        state2.length -= n2;
        state2.awaitDrain = 0;
      }
      if (state2.length === 0) {
        if (!state2.ended)
          state2.needReadable = true;
        if (nOrig !== n2 && state2.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state2) {
      debug("onEofChunk");
      if (state2.ended)
        return;
      if (state2.decoder) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) {
          state2.buffer.push(chunk);
          state2.length += state2.objectMode ? 1 : chunk.length;
        }
      }
      state2.ended = true;
      if (state2.sync) {
        emitReadable(stream);
      } else {
        state2.needReadable = false;
        if (!state2.emittedReadable) {
          state2.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state2 = stream._readableState;
      debug("emitReadable", state2.needReadable, state2.emittedReadable);
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        debug("emitReadable", state2.flowing);
        state2.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state2 = stream._readableState;
      debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
      if (!state2.destroyed && (state2.length || state2.ended)) {
        stream.emit("readable");
        state2.emittedReadable = false;
      }
      state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state2) {
      if (!state2.readingMore) {
        state2.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state2);
      }
    }
    function maybeReadMore_(stream, state2) {
      while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
        var len2 = state2.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len2 === state2.length)
          break;
      }
      state2.readingMore = false;
    }
    Readable.prototype._read = function(n2) {
      errorOrDestroy2(this, new ERR_METHOD_NOT_IMPLEMENTED2("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src2 = this;
      var state2 = this._readableState;
      switch (state2.pipesCount) {
        case 0:
          state2.pipes = dest;
          break;
        case 1:
          state2.pipes = [state2.pipes, dest];
          break;
        default:
          state2.pipes.push(dest);
          break;
      }
      state2.pipesCount += 1;
      debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state2.endEmitted)
        process.nextTick(endFn);
      else
        src2.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src2) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src2);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src2.removeListener("end", onend);
        src2.removeListener("end", unpipe);
        src2.removeListener("data", ondata);
        cleanedUp = true;
        if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src2.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state2.awaitDrain);
            state2.awaitDrain++;
          }
          src2.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy2(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src2.unpipe(dest);
      }
      dest.emit("pipe", src2);
      if (!state2.flowing) {
        debug("pipe resume");
        src2.resume();
      }
      return dest;
    };
    function pipeOnDrain(src2) {
      return function pipeOnDrainFunctionResult() {
        var state2 = src2._readableState;
        debug("pipeOnDrain", state2.awaitDrain);
        if (state2.awaitDrain)
          state2.awaitDrain--;
        if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
          state2.flowing = true;
          flow(src2);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state2 = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state2.pipesCount === 0)
        return this;
      if (state2.pipesCount === 1) {
        if (dest && dest !== state2.pipes)
          return this;
        if (!dest)
          dest = state2.pipes;
        state2.pipes = null;
        state2.pipesCount = 0;
        state2.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state2.pipes;
        var len2 = state2.pipesCount;
        state2.pipes = null;
        state2.pipesCount = 0;
        state2.flowing = false;
        for (var i2 = 0; i2 < len2; i2++)
          dests[i2].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state2.pipes, dest);
      if (index === -1)
        return this;
      state2.pipes.splice(index, 1);
      state2.pipesCount -= 1;
      if (state2.pipesCount === 1)
        state2.pipes = state2.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state2 = this._readableState;
      if (ev === "data") {
        state2.readableListening = this.listenerCount("readable") > 0;
        if (state2.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state2.endEmitted && !state2.readableListening) {
          state2.readableListening = state2.needReadable = true;
          state2.flowing = false;
          state2.emittedReadable = false;
          debug("on readable", state2.length, state2.reading);
          if (state2.length) {
            emitReadable(this);
          } else if (!state2.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state2 = self2._readableState;
      state2.readableListening = self2.listenerCount("readable") > 0;
      if (state2.resumeScheduled && !state2.paused) {
        state2.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state2 = this._readableState;
      if (!state2.flowing) {
        debug("resume");
        state2.flowing = !state2.readableListening;
        resume(this, state2);
      }
      state2.paused = false;
      return this;
    };
    function resume(stream, state2) {
      if (!state2.resumeScheduled) {
        state2.resumeScheduled = true;
        process.nextTick(resume_, stream, state2);
      }
    }
    function resume_(stream, state2) {
      debug("resume", state2.reading);
      if (!state2.reading) {
        stream.read(0);
      }
      state2.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state2.flowing && !state2.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state2 = stream._readableState;
      debug("flow", state2.flowing);
      while (state2.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state2 = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state2.decoder && !state2.ended) {
          var chunk = state2.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state2.decoder)
          chunk = state2.decoder.write(chunk);
        if (state2.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state2.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i2 in stream) {
        if (this[i2] === void 0 && typeof stream[i2] === "function") {
          this[i2] = /* @__PURE__ */ function methodWrap(method2) {
            return function methodWrapReturnFunction() {
              return stream[method2].apply(stream, arguments);
            };
          }(i2);
        }
      }
      for (var n2 = 0; n2 < kProxyEvents.length; n2++) {
        stream.on(kProxyEvents[n2], this.emit.bind(this, kProxyEvents[n2]));
      }
      this._read = function(n3) {
        debug("wrapped _read", n3);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = requireAsync_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._readableState.flowing;
      },
      set: function set(state2) {
        if (this._readableState) {
          this._readableState.flowing = state2;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._readableState.length;
      }
    });
    function fromList(n2, state2) {
      if (state2.length === 0)
        return null;
      var ret;
      if (state2.objectMode)
        ret = state2.buffer.shift();
      else if (!n2 || n2 >= state2.length) {
        if (state2.decoder)
          ret = state2.buffer.join("");
        else if (state2.buffer.length === 1)
          ret = state2.buffer.first();
        else
          ret = state2.buffer.concat(state2.length);
        state2.buffer.clear();
      } else {
        ret = state2.buffer.consume(n2, state2.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state2 = stream._readableState;
      debug("endReadable", state2.endEmitted);
      if (!state2.endEmitted) {
        state2.ended = true;
        process.nextTick(endReadableNT, state2, stream);
      }
    }
    function endReadableNT(state2, stream) {
      debug("endReadableNT", state2.endEmitted, state2.length);
      if (!state2.endEmitted && state2.length === 0) {
        state2.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state2.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = requireFromBrowser();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i2 = 0, l = xs.length; i2 < l; i2++) {
        if (xs[i2] === x)
          return i2;
      }
      return -1;
    }
    return _stream_readable;
  }
  var _stream_transform = Transform$5;
  var _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex();
  inherits_browserExports$1(Transform$5, Duplex);
  function afterTransform(er, data2) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data2 != null)
      this.push(data2);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform$5(options) {
    if (!(this instanceof Transform$5))
      return new Transform$5(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data2) {
        done(_this, er, data2);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform$5.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform$5.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform$5.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform$5.prototype._read = function(n2) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform$5.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data2) {
    if (er)
      return stream.emit("error", er);
    if (data2 != null)
      stream.push(data2);
    if (stream._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
  var _stream_passthrough = PassThrough;
  var Transform$4 = _stream_transform;
  inherits_browserExports$1(PassThrough, Transform$4);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform$4.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop(err) {
    if (err)
      throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0)
      eos = endOfStream;
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream))
        return stream.abort();
      if (typeof stream.destroy === "function")
        return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop;
    if (typeof streams[streams.length - 1] !== "function")
      return noop;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i2) {
      var reading = i2 < streams.length - 1;
      var writing = i2 > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  var pipeline_1 = pipeline;
  (function(module2, exports2) {
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = _stream_transform;
    exports2.PassThrough = _stream_passthrough;
    exports2.finished = endOfStream;
    exports2.pipeline = pipeline_1;
  })(readableBrowser, readableBrowser.exports);
  var readableBrowserExports = readableBrowser.exports;
  const { Transform: Transform$3 } = readableBrowserExports;
  var keccak$1 = (KeccakState) => class Keccak2 extends Transform$3 {
    constructor(rate, capacity, delimitedSuffix, hashBitLength, options) {
      super(options);
      this._rate = rate;
      this._capacity = capacity;
      this._delimitedSuffix = delimitedSuffix;
      this._hashBitLength = hashBitLength;
      this._options = options;
      this._state = new KeccakState();
      this._state.initialize(rate, capacity);
      this._finalized = false;
    }
    _transform(chunk, encoding, callback) {
      let error = null;
      try {
        this.update(chunk, encoding);
      } catch (err) {
        error = err;
      }
      callback(error);
    }
    _flush(callback) {
      let error = null;
      try {
        this.push(this.digest());
      } catch (err) {
        error = err;
      }
      callback(error);
    }
    update(data2, encoding) {
      if (!buffer$2.Buffer.isBuffer(data2) && typeof data2 !== "string")
        throw new TypeError("Data must be a string or a buffer");
      if (this._finalized)
        throw new Error("Digest already called");
      if (!buffer$2.Buffer.isBuffer(data2))
        data2 = buffer$2.Buffer.from(data2, encoding);
      this._state.absorb(data2);
      return this;
    }
    digest(encoding) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      if (this._delimitedSuffix)
        this._state.absorbLastFewBits(this._delimitedSuffix);
      let digest = this._state.squeeze(this._hashBitLength / 8);
      if (encoding !== void 0)
        digest = digest.toString(encoding);
      this._resetState();
      return digest;
    }
    // remove result from memory
    _resetState() {
      this._state.initialize(this._rate, this._capacity);
      return this;
    }
    // because sometimes we need hash right now and little later
    _clone() {
      const clone = new Keccak2(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
      this._state.copy(clone._state);
      clone._finalized = this._finalized;
      return clone;
    }
  };
  const { Transform: Transform$2 } = readableBrowserExports;
  var shake = (KeccakState) => class Shake extends Transform$2 {
    constructor(rate, capacity, delimitedSuffix, options) {
      super(options);
      this._rate = rate;
      this._capacity = capacity;
      this._delimitedSuffix = delimitedSuffix;
      this._options = options;
      this._state = new KeccakState();
      this._state.initialize(rate, capacity);
      this._finalized = false;
    }
    _transform(chunk, encoding, callback) {
      let error = null;
      try {
        this.update(chunk, encoding);
      } catch (err) {
        error = err;
      }
      callback(error);
    }
    _flush() {
    }
    _read(size) {
      this.push(this.squeeze(size));
    }
    update(data2, encoding) {
      if (!buffer$2.Buffer.isBuffer(data2) && typeof data2 !== "string")
        throw new TypeError("Data must be a string or a buffer");
      if (this._finalized)
        throw new Error("Squeeze already called");
      if (!buffer$2.Buffer.isBuffer(data2))
        data2 = buffer$2.Buffer.from(data2, encoding);
      this._state.absorb(data2);
      return this;
    }
    squeeze(dataByteLength, encoding) {
      if (!this._finalized) {
        this._finalized = true;
        this._state.absorbLastFewBits(this._delimitedSuffix);
      }
      let data2 = this._state.squeeze(dataByteLength);
      if (encoding !== void 0)
        data2 = data2.toString(encoding);
      return data2;
    }
    _resetState() {
      this._state.initialize(this._rate, this._capacity);
      return this;
    }
    _clone() {
      const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
      this._state.copy(clone._state);
      clone._finalized = this._finalized;
      return clone;
    }
  };
  const createKeccak = keccak$1;
  const createShake = shake;
  var api = function(KeccakState) {
    const Keccak2 = createKeccak(KeccakState);
    const Shake = createShake(KeccakState);
    return function(algorithm2, options) {
      const hash2 = typeof algorithm2 === "string" ? algorithm2.toLowerCase() : algorithm2;
      switch (hash2) {
        case "keccak224":
          return new Keccak2(1152, 448, null, 224, options);
        case "keccak256":
          return new Keccak2(1088, 512, null, 256, options);
        case "keccak384":
          return new Keccak2(832, 768, null, 384, options);
        case "keccak512":
          return new Keccak2(576, 1024, null, 512, options);
        case "sha3-224":
          return new Keccak2(1152, 448, 6, 224, options);
        case "sha3-256":
          return new Keccak2(1088, 512, 6, 256, options);
        case "sha3-384":
          return new Keccak2(832, 768, 6, 384, options);
        case "sha3-512":
          return new Keccak2(576, 1024, 6, 512, options);
        case "shake128":
          return new Shake(1344, 256, 31, options);
        case "shake256":
          return new Shake(1088, 512, 31, options);
        default:
          throw new Error("Invald algorithm: " + algorithm2);
      }
    };
  };
  var keccakStateUnroll = {};
  const P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  keccakStateUnroll.p1600 = function(s2) {
    for (let round = 0; round < 24; ++round) {
      const lo0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
      const hi0 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
      const lo1 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
      const hi1 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
      const lo2 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
      const hi2 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
      const lo3 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
      const hi3 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
      const lo4 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
      const hi4 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
      let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
      let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
      const t1slo0 = s2[0] ^ lo;
      const t1shi0 = s2[1] ^ hi;
      const t1slo5 = s2[10] ^ lo;
      const t1shi5 = s2[11] ^ hi;
      const t1slo10 = s2[20] ^ lo;
      const t1shi10 = s2[21] ^ hi;
      const t1slo15 = s2[30] ^ lo;
      const t1shi15 = s2[31] ^ hi;
      const t1slo20 = s2[40] ^ lo;
      const t1shi20 = s2[41] ^ hi;
      lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
      hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
      const t1slo1 = s2[2] ^ lo;
      const t1shi1 = s2[3] ^ hi;
      const t1slo6 = s2[12] ^ lo;
      const t1shi6 = s2[13] ^ hi;
      const t1slo11 = s2[22] ^ lo;
      const t1shi11 = s2[23] ^ hi;
      const t1slo16 = s2[32] ^ lo;
      const t1shi16 = s2[33] ^ hi;
      const t1slo21 = s2[42] ^ lo;
      const t1shi21 = s2[43] ^ hi;
      lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
      hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
      const t1slo2 = s2[4] ^ lo;
      const t1shi2 = s2[5] ^ hi;
      const t1slo7 = s2[14] ^ lo;
      const t1shi7 = s2[15] ^ hi;
      const t1slo12 = s2[24] ^ lo;
      const t1shi12 = s2[25] ^ hi;
      const t1slo17 = s2[34] ^ lo;
      const t1shi17 = s2[35] ^ hi;
      const t1slo22 = s2[44] ^ lo;
      const t1shi22 = s2[45] ^ hi;
      lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
      hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
      const t1slo3 = s2[6] ^ lo;
      const t1shi3 = s2[7] ^ hi;
      const t1slo8 = s2[16] ^ lo;
      const t1shi8 = s2[17] ^ hi;
      const t1slo13 = s2[26] ^ lo;
      const t1shi13 = s2[27] ^ hi;
      const t1slo18 = s2[36] ^ lo;
      const t1shi18 = s2[37] ^ hi;
      const t1slo23 = s2[46] ^ lo;
      const t1shi23 = s2[47] ^ hi;
      lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
      hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
      const t1slo4 = s2[8] ^ lo;
      const t1shi4 = s2[9] ^ hi;
      const t1slo9 = s2[18] ^ lo;
      const t1shi9 = s2[19] ^ hi;
      const t1slo14 = s2[28] ^ lo;
      const t1shi14 = s2[29] ^ hi;
      const t1slo19 = s2[38] ^ lo;
      const t1shi19 = s2[39] ^ hi;
      const t1slo24 = s2[48] ^ lo;
      const t1shi24 = s2[49] ^ hi;
      const t2slo0 = t1slo0;
      const t2shi0 = t1shi0;
      const t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
      const t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
      const t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
      const t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
      const t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
      const t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
      const t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
      const t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
      const t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
      const t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
      const t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
      const t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
      const t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
      const t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
      const t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
      const t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
      const t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
      const t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
      const t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
      const t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
      const t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
      const t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
      const t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
      const t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
      const t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
      const t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
      const t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
      const t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
      const t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
      const t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
      const t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
      const t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
      const t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
      const t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
      const t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
      const t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
      const t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
      const t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
      const t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
      const t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
      const t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
      const t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
      const t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
      const t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
      const t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
      const t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
      const t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
      const t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;
      s2[0] = t2slo0 ^ ~t2slo1 & t2slo2;
      s2[1] = t2shi0 ^ ~t2shi1 & t2shi2;
      s2[10] = t2slo5 ^ ~t2slo6 & t2slo7;
      s2[11] = t2shi5 ^ ~t2shi6 & t2shi7;
      s2[20] = t2slo10 ^ ~t2slo11 & t2slo12;
      s2[21] = t2shi10 ^ ~t2shi11 & t2shi12;
      s2[30] = t2slo15 ^ ~t2slo16 & t2slo17;
      s2[31] = t2shi15 ^ ~t2shi16 & t2shi17;
      s2[40] = t2slo20 ^ ~t2slo21 & t2slo22;
      s2[41] = t2shi20 ^ ~t2shi21 & t2shi22;
      s2[2] = t2slo1 ^ ~t2slo2 & t2slo3;
      s2[3] = t2shi1 ^ ~t2shi2 & t2shi3;
      s2[12] = t2slo6 ^ ~t2slo7 & t2slo8;
      s2[13] = t2shi6 ^ ~t2shi7 & t2shi8;
      s2[22] = t2slo11 ^ ~t2slo12 & t2slo13;
      s2[23] = t2shi11 ^ ~t2shi12 & t2shi13;
      s2[32] = t2slo16 ^ ~t2slo17 & t2slo18;
      s2[33] = t2shi16 ^ ~t2shi17 & t2shi18;
      s2[42] = t2slo21 ^ ~t2slo22 & t2slo23;
      s2[43] = t2shi21 ^ ~t2shi22 & t2shi23;
      s2[4] = t2slo2 ^ ~t2slo3 & t2slo4;
      s2[5] = t2shi2 ^ ~t2shi3 & t2shi4;
      s2[14] = t2slo7 ^ ~t2slo8 & t2slo9;
      s2[15] = t2shi7 ^ ~t2shi8 & t2shi9;
      s2[24] = t2slo12 ^ ~t2slo13 & t2slo14;
      s2[25] = t2shi12 ^ ~t2shi13 & t2shi14;
      s2[34] = t2slo17 ^ ~t2slo18 & t2slo19;
      s2[35] = t2shi17 ^ ~t2shi18 & t2shi19;
      s2[44] = t2slo22 ^ ~t2slo23 & t2slo24;
      s2[45] = t2shi22 ^ ~t2shi23 & t2shi24;
      s2[6] = t2slo3 ^ ~t2slo4 & t2slo0;
      s2[7] = t2shi3 ^ ~t2shi4 & t2shi0;
      s2[16] = t2slo8 ^ ~t2slo9 & t2slo5;
      s2[17] = t2shi8 ^ ~t2shi9 & t2shi5;
      s2[26] = t2slo13 ^ ~t2slo14 & t2slo10;
      s2[27] = t2shi13 ^ ~t2shi14 & t2shi10;
      s2[36] = t2slo18 ^ ~t2slo19 & t2slo15;
      s2[37] = t2shi18 ^ ~t2shi19 & t2shi15;
      s2[46] = t2slo23 ^ ~t2slo24 & t2slo20;
      s2[47] = t2shi23 ^ ~t2shi24 & t2shi20;
      s2[8] = t2slo4 ^ ~t2slo0 & t2slo1;
      s2[9] = t2shi4 ^ ~t2shi0 & t2shi1;
      s2[18] = t2slo9 ^ ~t2slo5 & t2slo6;
      s2[19] = t2shi9 ^ ~t2shi5 & t2shi6;
      s2[28] = t2slo14 ^ ~t2slo10 & t2slo11;
      s2[29] = t2shi14 ^ ~t2shi10 & t2shi11;
      s2[38] = t2slo19 ^ ~t2slo15 & t2slo16;
      s2[39] = t2shi19 ^ ~t2shi15 & t2shi16;
      s2[48] = t2slo24 ^ ~t2slo20 & t2slo21;
      s2[49] = t2shi24 ^ ~t2shi20 & t2shi21;
      s2[0] ^= P1600_ROUND_CONSTANTS[round * 2];
      s2[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
    }
  };
  const keccakState = keccakStateUnroll;
  function Keccak() {
    this.state = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    this.blockSize = null;
    this.count = 0;
    this.squeezing = false;
  }
  Keccak.prototype.initialize = function(rate, capacity) {
    for (let i2 = 0; i2 < 50; ++i2)
      this.state[i2] = 0;
    this.blockSize = rate / 8;
    this.count = 0;
    this.squeezing = false;
  };
  Keccak.prototype.absorb = function(data2) {
    for (let i2 = 0; i2 < data2.length; ++i2) {
      this.state[~~(this.count / 4)] ^= data2[i2] << 8 * (this.count % 4);
      this.count += 1;
      if (this.count === this.blockSize) {
        keccakState.p1600(this.state);
        this.count = 0;
      }
    }
  };
  Keccak.prototype.absorbLastFewBits = function(bits) {
    this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
    if ((bits & 128) !== 0 && this.count === this.blockSize - 1)
      keccakState.p1600(this.state);
    this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4);
    keccakState.p1600(this.state);
    this.count = 0;
    this.squeezing = true;
  };
  Keccak.prototype.squeeze = function(length) {
    if (!this.squeezing)
      this.absorbLastFewBits(1);
    const output2 = buffer$2.Buffer.alloc(length);
    for (let i2 = 0; i2 < length; ++i2) {
      output2[i2] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255;
      this.count += 1;
      if (this.count === this.blockSize) {
        keccakState.p1600(this.state);
        this.count = 0;
      }
    }
    return output2;
  };
  Keccak.prototype.copy = function(dest) {
    for (let i2 = 0; i2 < 50; ++i2)
      dest.state[i2] = this.state[i2];
    dest.blockSize = this.blockSize;
    dest.count = this.count;
    dest.squeezing = this.squeezing;
  };
  var keccak = Keccak;
  var js = api(keccak);
  Object.defineProperty(keccak$2, "__esModule", { value: true });
  var hash_utils_1 = hashUtils;
  var createKeccakHash = js;
  keccak$2.keccak224 = hash_utils_1.createHashFunction(function() {
    return createKeccakHash("keccak224");
  });
  keccak$2.keccak256 = hash_utils_1.createHashFunction(function() {
    return createKeccakHash("keccak256");
  });
  keccak$2.keccak384 = hash_utils_1.createHashFunction(function() {
    return createKeccakHash("keccak384");
  });
  keccak$2.keccak512 = hash_utils_1.createHashFunction(function() {
    return createKeccakHash("keccak512");
  });
  var Buffer$a = safeBufferExports.Buffer;
  var Transform$1 = readableBrowserExports.Transform;
  var inherits$a = inherits_browserExports$1;
  function throwIfNotStringOrBuffer(val, prefix) {
    if (!Buffer$a.isBuffer(val) && typeof val !== "string") {
      throw new TypeError(prefix + " must be a string or a buffer");
    }
  }
  function HashBase$2(blockSize) {
    Transform$1.call(this);
    this._block = Buffer$a.allocUnsafe(blockSize);
    this._blockSize = blockSize;
    this._blockOffset = 0;
    this._length = [0, 0, 0, 0];
    this._finalized = false;
  }
  inherits$a(HashBase$2, Transform$1);
  HashBase$2.prototype._transform = function(chunk, encoding, callback) {
    var error = null;
    try {
      this.update(chunk, encoding);
    } catch (err) {
      error = err;
    }
    callback(error);
  };
  HashBase$2.prototype._flush = function(callback) {
    var error = null;
    try {
      this.push(this.digest());
    } catch (err) {
      error = err;
    }
    callback(error);
  };
  HashBase$2.prototype.update = function(data2, encoding) {
    throwIfNotStringOrBuffer(data2, "Data");
    if (this._finalized)
      throw new Error("Digest already called");
    if (!Buffer$a.isBuffer(data2))
      data2 = Buffer$a.from(data2, encoding);
    var block2 = this._block;
    var offset = 0;
    while (this._blockOffset + data2.length - offset >= this._blockSize) {
      for (var i2 = this._blockOffset; i2 < this._blockSize; )
        block2[i2++] = data2[offset++];
      this._update();
      this._blockOffset = 0;
    }
    while (offset < data2.length)
      block2[this._blockOffset++] = data2[offset++];
    for (var j = 0, carry = data2.length * 8; carry > 0; ++j) {
      this._length[j] += carry;
      carry = this._length[j] / 4294967296 | 0;
      if (carry > 0)
        this._length[j] -= 4294967296 * carry;
    }
    return this;
  };
  HashBase$2.prototype._update = function() {
    throw new Error("_update is not implemented");
  };
  HashBase$2.prototype.digest = function(encoding) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = true;
    var digest = this._digest();
    if (encoding !== void 0)
      digest = digest.toString(encoding);
    this._block.fill(0);
    this._blockOffset = 0;
    for (var i2 = 0; i2 < 4; ++i2)
      this._length[i2] = 0;
    return digest;
  };
  HashBase$2.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  };
  var hashBase = HashBase$2;
  var inherits$9 = inherits_browserExports$1;
  var HashBase$1 = hashBase;
  var Buffer$9 = safeBufferExports.Buffer;
  var ARRAY16$1 = new Array(16);
  function MD5$1() {
    HashBase$1.call(this, 64);
    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
  }
  inherits$9(MD5$1, HashBase$1);
  MD5$1.prototype._update = function() {
    var M = ARRAY16$1;
    for (var i2 = 0; i2 < 16; ++i2)
      M[i2] = this._block.readInt32LE(i2 * 4);
    var a = this._a;
    var b = this._b;
    var c = this._c;
    var d = this._d;
    a = fnF(a, b, c, d, M[0], 3614090360, 7);
    d = fnF(d, a, b, c, M[1], 3905402710, 12);
    c = fnF(c, d, a, b, M[2], 606105819, 17);
    b = fnF(b, c, d, a, M[3], 3250441966, 22);
    a = fnF(a, b, c, d, M[4], 4118548399, 7);
    d = fnF(d, a, b, c, M[5], 1200080426, 12);
    c = fnF(c, d, a, b, M[6], 2821735955, 17);
    b = fnF(b, c, d, a, M[7], 4249261313, 22);
    a = fnF(a, b, c, d, M[8], 1770035416, 7);
    d = fnF(d, a, b, c, M[9], 2336552879, 12);
    c = fnF(c, d, a, b, M[10], 4294925233, 17);
    b = fnF(b, c, d, a, M[11], 2304563134, 22);
    a = fnF(a, b, c, d, M[12], 1804603682, 7);
    d = fnF(d, a, b, c, M[13], 4254626195, 12);
    c = fnF(c, d, a, b, M[14], 2792965006, 17);
    b = fnF(b, c, d, a, M[15], 1236535329, 22);
    a = fnG(a, b, c, d, M[1], 4129170786, 5);
    d = fnG(d, a, b, c, M[6], 3225465664, 9);
    c = fnG(c, d, a, b, M[11], 643717713, 14);
    b = fnG(b, c, d, a, M[0], 3921069994, 20);
    a = fnG(a, b, c, d, M[5], 3593408605, 5);
    d = fnG(d, a, b, c, M[10], 38016083, 9);
    c = fnG(c, d, a, b, M[15], 3634488961, 14);
    b = fnG(b, c, d, a, M[4], 3889429448, 20);
    a = fnG(a, b, c, d, M[9], 568446438, 5);
    d = fnG(d, a, b, c, M[14], 3275163606, 9);
    c = fnG(c, d, a, b, M[3], 4107603335, 14);
    b = fnG(b, c, d, a, M[8], 1163531501, 20);
    a = fnG(a, b, c, d, M[13], 2850285829, 5);
    d = fnG(d, a, b, c, M[2], 4243563512, 9);
    c = fnG(c, d, a, b, M[7], 1735328473, 14);
    b = fnG(b, c, d, a, M[12], 2368359562, 20);
    a = fnH(a, b, c, d, M[5], 4294588738, 4);
    d = fnH(d, a, b, c, M[8], 2272392833, 11);
    c = fnH(c, d, a, b, M[11], 1839030562, 16);
    b = fnH(b, c, d, a, M[14], 4259657740, 23);
    a = fnH(a, b, c, d, M[1], 2763975236, 4);
    d = fnH(d, a, b, c, M[4], 1272893353, 11);
    c = fnH(c, d, a, b, M[7], 4139469664, 16);
    b = fnH(b, c, d, a, M[10], 3200236656, 23);
    a = fnH(a, b, c, d, M[13], 681279174, 4);
    d = fnH(d, a, b, c, M[0], 3936430074, 11);
    c = fnH(c, d, a, b, M[3], 3572445317, 16);
    b = fnH(b, c, d, a, M[6], 76029189, 23);
    a = fnH(a, b, c, d, M[9], 3654602809, 4);
    d = fnH(d, a, b, c, M[12], 3873151461, 11);
    c = fnH(c, d, a, b, M[15], 530742520, 16);
    b = fnH(b, c, d, a, M[2], 3299628645, 23);
    a = fnI(a, b, c, d, M[0], 4096336452, 6);
    d = fnI(d, a, b, c, M[7], 1126891415, 10);
    c = fnI(c, d, a, b, M[14], 2878612391, 15);
    b = fnI(b, c, d, a, M[5], 4237533241, 21);
    a = fnI(a, b, c, d, M[12], 1700485571, 6);
    d = fnI(d, a, b, c, M[3], 2399980690, 10);
    c = fnI(c, d, a, b, M[10], 4293915773, 15);
    b = fnI(b, c, d, a, M[1], 2240044497, 21);
    a = fnI(a, b, c, d, M[8], 1873313359, 6);
    d = fnI(d, a, b, c, M[15], 4264355552, 10);
    c = fnI(c, d, a, b, M[6], 2734768916, 15);
    b = fnI(b, c, d, a, M[13], 1309151649, 21);
    a = fnI(a, b, c, d, M[4], 4149444226, 6);
    d = fnI(d, a, b, c, M[11], 3174756917, 10);
    c = fnI(c, d, a, b, M[2], 718787259, 15);
    b = fnI(b, c, d, a, M[9], 3951481745, 21);
    this._a = this._a + a | 0;
    this._b = this._b + b | 0;
    this._c = this._c + c | 0;
    this._d = this._d + d | 0;
  };
  MD5$1.prototype._digest = function() {
    this._block[this._blockOffset++] = 128;
    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64);
      this._update();
      this._blockOffset = 0;
    }
    this._block.fill(0, this._blockOffset, 56);
    this._block.writeUInt32LE(this._length[0], 56);
    this._block.writeUInt32LE(this._length[1], 60);
    this._update();
    var buffer2 = Buffer$9.allocUnsafe(16);
    buffer2.writeInt32LE(this._a, 0);
    buffer2.writeInt32LE(this._b, 4);
    buffer2.writeInt32LE(this._c, 8);
    buffer2.writeInt32LE(this._d, 12);
    return buffer2;
  };
  function rotl$1(x, n2) {
    return x << n2 | x >>> 32 - n2;
  }
  function fnF(a, b, c, d, m, k2, s2) {
    return rotl$1(a + (b & c | ~b & d) + m + k2 | 0, s2) + b | 0;
  }
  function fnG(a, b, c, d, m, k2, s2) {
    return rotl$1(a + (b & d | c & ~d) + m + k2 | 0, s2) + b | 0;
  }
  function fnH(a, b, c, d, m, k2, s2) {
    return rotl$1(a + (b ^ c ^ d) + m + k2 | 0, s2) + b | 0;
  }
  function fnI(a, b, c, d, m, k2, s2) {
    return rotl$1(a + (c ^ (b | ~d)) + m + k2 | 0, s2) + b | 0;
  }
  var md5_js = MD5$1;
  var Buffer$8 = buffer$2.Buffer;
  var inherits$8 = inherits_browserExports$1;
  var HashBase = hashBase;
  var ARRAY16 = new Array(16);
  var zl = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ];
  var zr = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ];
  var sl = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ];
  var sr = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
  var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function RIPEMD160$1() {
    HashBase.call(this, 64);
    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
    this._e = 3285377520;
  }
  inherits$8(RIPEMD160$1, HashBase);
  RIPEMD160$1.prototype._update = function() {
    var words = ARRAY16;
    for (var j = 0; j < 16; ++j)
      words[j] = this._block.readInt32LE(j * 4);
    var al = this._a | 0;
    var bl = this._b | 0;
    var cl = this._c | 0;
    var dl = this._d | 0;
    var el = this._e | 0;
    var ar = this._a | 0;
    var br = this._b | 0;
    var cr = this._c | 0;
    var dr = this._d | 0;
    var er = this._e | 0;
    for (var i2 = 0; i2 < 80; i2 += 1) {
      var tl;
      var tr;
      if (i2 < 16) {
        tl = fn1(al, bl, cl, dl, el, words[zl[i2]], hl[0], sl[i2]);
        tr = fn5(ar, br, cr, dr, er, words[zr[i2]], hr[0], sr[i2]);
      } else if (i2 < 32) {
        tl = fn2(al, bl, cl, dl, el, words[zl[i2]], hl[1], sl[i2]);
        tr = fn4(ar, br, cr, dr, er, words[zr[i2]], hr[1], sr[i2]);
      } else if (i2 < 48) {
        tl = fn3(al, bl, cl, dl, el, words[zl[i2]], hl[2], sl[i2]);
        tr = fn3(ar, br, cr, dr, er, words[zr[i2]], hr[2], sr[i2]);
      } else if (i2 < 64) {
        tl = fn4(al, bl, cl, dl, el, words[zl[i2]], hl[3], sl[i2]);
        tr = fn2(ar, br, cr, dr, er, words[zr[i2]], hr[3], sr[i2]);
      } else {
        tl = fn5(al, bl, cl, dl, el, words[zl[i2]], hl[4], sl[i2]);
        tr = fn1(ar, br, cr, dr, er, words[zr[i2]], hr[4], sr[i2]);
      }
      al = el;
      el = dl;
      dl = rotl(cl, 10);
      cl = bl;
      bl = tl;
      ar = er;
      er = dr;
      dr = rotl(cr, 10);
      cr = br;
      br = tr;
    }
    var t = this._b + cl + dr | 0;
    this._b = this._c + dl + er | 0;
    this._c = this._d + el + ar | 0;
    this._d = this._e + al + br | 0;
    this._e = this._a + bl + cr | 0;
    this._a = t;
  };
  RIPEMD160$1.prototype._digest = function() {
    this._block[this._blockOffset++] = 128;
    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64);
      this._update();
      this._blockOffset = 0;
    }
    this._block.fill(0, this._blockOffset, 56);
    this._block.writeUInt32LE(this._length[0], 56);
    this._block.writeUInt32LE(this._length[1], 60);
    this._update();
    var buffer2 = Buffer$8.alloc ? Buffer$8.alloc(20) : new Buffer$8(20);
    buffer2.writeInt32LE(this._a, 0);
    buffer2.writeInt32LE(this._b, 4);
    buffer2.writeInt32LE(this._c, 8);
    buffer2.writeInt32LE(this._d, 12);
    buffer2.writeInt32LE(this._e, 16);
    return buffer2;
  };
  function rotl(x, n2) {
    return x << n2 | x >>> 32 - n2;
  }
  function fn1(a, b, c, d, e, m, k2, s2) {
    return rotl(a + (b ^ c ^ d) + m + k2 | 0, s2) + e | 0;
  }
  function fn2(a, b, c, d, e, m, k2, s2) {
    return rotl(a + (b & c | ~b & d) + m + k2 | 0, s2) + e | 0;
  }
  function fn3(a, b, c, d, e, m, k2, s2) {
    return rotl(a + ((b | ~c) ^ d) + m + k2 | 0, s2) + e | 0;
  }
  function fn4(a, b, c, d, e, m, k2, s2) {
    return rotl(a + (b & d | c & ~d) + m + k2 | 0, s2) + e | 0;
  }
  function fn5(a, b, c, d, e, m, k2, s2) {
    return rotl(a + (b ^ (c | ~d)) + m + k2 | 0, s2) + e | 0;
  }
  var ripemd160 = RIPEMD160$1;
  var sha_js = { exports: {} };
  var Buffer$7 = safeBufferExports.Buffer;
  function Hash$7(blockSize, finalSize) {
    this._block = Buffer$7.alloc(blockSize);
    this._finalSize = finalSize;
    this._blockSize = blockSize;
    this._len = 0;
  }
  Hash$7.prototype.update = function(data2, enc) {
    if (typeof data2 === "string") {
      enc = enc || "utf8";
      data2 = Buffer$7.from(data2, enc);
    }
    var block2 = this._block;
    var blockSize = this._blockSize;
    var length = data2.length;
    var accum = this._len;
    for (var offset = 0; offset < length; ) {
      var assigned = accum % blockSize;
      var remainder = Math.min(length - offset, blockSize - assigned);
      for (var i2 = 0; i2 < remainder; i2++) {
        block2[assigned + i2] = data2[offset + i2];
      }
      accum += remainder;
      offset += remainder;
      if (accum % blockSize === 0) {
        this._update(block2);
      }
    }
    this._len += length;
    return this;
  };
  Hash$7.prototype.digest = function(enc) {
    var rem = this._len % this._blockSize;
    this._block[rem] = 128;
    this._block.fill(0, rem + 1);
    if (rem >= this._finalSize) {
      this._update(this._block);
      this._block.fill(0);
    }
    var bits = this._len * 8;
    if (bits <= 4294967295) {
      this._block.writeUInt32BE(bits, this._blockSize - 4);
    } else {
      var lowBits = (bits & 4294967295) >>> 0;
      var highBits = (bits - lowBits) / 4294967296;
      this._block.writeUInt32BE(highBits, this._blockSize - 8);
      this._block.writeUInt32BE(lowBits, this._blockSize - 4);
    }
    this._update(this._block);
    var hash2 = this._hash();
    return enc ? hash2.toString(enc) : hash2;
  };
  Hash$7.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  };
  var hash = Hash$7;
  var inherits$7 = inherits_browserExports$1;
  var Hash$6 = hash;
  var Buffer$6 = safeBufferExports.Buffer;
  var K$3 = [
    1518500249,
    1859775393,
    2400959708 | 0,
    3395469782 | 0
  ];
  var W$5 = new Array(80);
  function Sha() {
    this.init();
    this._w = W$5;
    Hash$6.call(this, 64, 56);
  }
  inherits$7(Sha, Hash$6);
  Sha.prototype.init = function() {
    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
    this._e = 3285377520;
    return this;
  };
  function rotl5$1(num) {
    return num << 5 | num >>> 27;
  }
  function rotl30$1(num) {
    return num << 30 | num >>> 2;
  }
  function ft$1(s2, b, c, d) {
    if (s2 === 0)
      return b & c | ~b & d;
    if (s2 === 2)
      return b & c | b & d | c & d;
    return b ^ c ^ d;
  }
  Sha.prototype._update = function(M) {
    var W2 = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    for (var i2 = 0; i2 < 16; ++i2)
      W2[i2] = M.readInt32BE(i2 * 4);
    for (; i2 < 80; ++i2)
      W2[i2] = W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16];
    for (var j = 0; j < 80; ++j) {
      var s2 = ~~(j / 20);
      var t = rotl5$1(a) + ft$1(s2, b, c, d) + e + W2[j] + K$3[s2] | 0;
      e = d;
      d = c;
      c = rotl30$1(b);
      b = a;
      a = t;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
  };
  Sha.prototype._hash = function() {
    var H = Buffer$6.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
  };
  var sha$1 = Sha;
  var inherits$6 = inherits_browserExports$1;
  var Hash$5 = hash;
  var Buffer$5 = safeBufferExports.Buffer;
  var K$2 = [
    1518500249,
    1859775393,
    2400959708 | 0,
    3395469782 | 0
  ];
  var W$4 = new Array(80);
  function Sha1() {
    this.init();
    this._w = W$4;
    Hash$5.call(this, 64, 56);
  }
  inherits$6(Sha1, Hash$5);
  Sha1.prototype.init = function() {
    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
    this._e = 3285377520;
    return this;
  };
  function rotl1(num) {
    return num << 1 | num >>> 31;
  }
  function rotl5(num) {
    return num << 5 | num >>> 27;
  }
  function rotl30(num) {
    return num << 30 | num >>> 2;
  }
  function ft(s2, b, c, d) {
    if (s2 === 0)
      return b & c | ~b & d;
    if (s2 === 2)
      return b & c | b & d | c & d;
    return b ^ c ^ d;
  }
  Sha1.prototype._update = function(M) {
    var W2 = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    for (var i2 = 0; i2 < 16; ++i2)
      W2[i2] = M.readInt32BE(i2 * 4);
    for (; i2 < 80; ++i2)
      W2[i2] = rotl1(W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16]);
    for (var j = 0; j < 80; ++j) {
      var s2 = ~~(j / 20);
      var t = rotl5(a) + ft(s2, b, c, d) + e + W2[j] + K$2[s2] | 0;
      e = d;
      d = c;
      c = rotl30(b);
      b = a;
      a = t;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
  };
  Sha1.prototype._hash = function() {
    var H = Buffer$5.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
  };
  var sha1 = Sha1;
  var inherits$5 = inherits_browserExports$1;
  var Hash$4 = hash;
  var Buffer$4 = safeBufferExports.Buffer;
  var K$1 = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  var W$3 = new Array(64);
  function Sha256$1() {
    this.init();
    this._w = W$3;
    Hash$4.call(this, 64, 56);
  }
  inherits$5(Sha256$1, Hash$4);
  Sha256$1.prototype.init = function() {
    this._a = 1779033703;
    this._b = 3144134277;
    this._c = 1013904242;
    this._d = 2773480762;
    this._e = 1359893119;
    this._f = 2600822924;
    this._g = 528734635;
    this._h = 1541459225;
    return this;
  };
  function ch(x, y, z) {
    return z ^ x & (y ^ z);
  }
  function maj$1(x, y, z) {
    return x & y | z & (x | y);
  }
  function sigma0$1(x) {
    return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
  }
  function sigma1$1(x) {
    return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
  }
  function gamma0(x) {
    return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
  }
  function gamma1(x) {
    return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
  }
  Sha256$1.prototype._update = function(M) {
    var W2 = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    var f2 = this._f | 0;
    var g2 = this._g | 0;
    var h = this._h | 0;
    for (var i2 = 0; i2 < 16; ++i2)
      W2[i2] = M.readInt32BE(i2 * 4);
    for (; i2 < 64; ++i2)
      W2[i2] = gamma1(W2[i2 - 2]) + W2[i2 - 7] + gamma0(W2[i2 - 15]) + W2[i2 - 16] | 0;
    for (var j = 0; j < 64; ++j) {
      var T1 = h + sigma1$1(e) + ch(e, f2, g2) + K$1[j] + W2[j] | 0;
      var T2 = sigma0$1(a) + maj$1(a, b, c) | 0;
      h = g2;
      g2 = f2;
      f2 = e;
      e = d + T1 | 0;
      d = c;
      c = b;
      b = a;
      a = T1 + T2 | 0;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
    this._f = f2 + this._f | 0;
    this._g = g2 + this._g | 0;
    this._h = h + this._h | 0;
  };
  Sha256$1.prototype._hash = function() {
    var H = Buffer$4.allocUnsafe(32);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    H.writeInt32BE(this._h, 28);
    return H;
  };
  var sha256 = Sha256$1;
  var inherits$4 = inherits_browserExports$1;
  var Sha256 = sha256;
  var Hash$3 = hash;
  var Buffer$3 = safeBufferExports.Buffer;
  var W$2 = new Array(64);
  function Sha224() {
    this.init();
    this._w = W$2;
    Hash$3.call(this, 64, 56);
  }
  inherits$4(Sha224, Sha256);
  Sha224.prototype.init = function() {
    this._a = 3238371032;
    this._b = 914150663;
    this._c = 812702999;
    this._d = 4144912697;
    this._e = 4290775857;
    this._f = 1750603025;
    this._g = 1694076839;
    this._h = 3204075428;
    return this;
  };
  Sha224.prototype._hash = function() {
    var H = Buffer$3.allocUnsafe(28);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    return H;
  };
  var sha224 = Sha224;
  var inherits$3 = inherits_browserExports$1;
  var Hash$2 = hash;
  var Buffer$2 = safeBufferExports.Buffer;
  var K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  var W$1 = new Array(160);
  function Sha512() {
    this.init();
    this._w = W$1;
    Hash$2.call(this, 128, 112);
  }
  inherits$3(Sha512, Hash$2);
  Sha512.prototype.init = function() {
    this._ah = 1779033703;
    this._bh = 3144134277;
    this._ch = 1013904242;
    this._dh = 2773480762;
    this._eh = 1359893119;
    this._fh = 2600822924;
    this._gh = 528734635;
    this._hh = 1541459225;
    this._al = 4089235720;
    this._bl = 2227873595;
    this._cl = 4271175723;
    this._dl = 1595750129;
    this._el = 2917565137;
    this._fl = 725511199;
    this._gl = 4215389547;
    this._hl = 327033209;
    return this;
  };
  function Ch(x, y, z) {
    return z ^ x & (y ^ z);
  }
  function maj(x, y, z) {
    return x & y | z & (x | y);
  }
  function sigma0(x, xl) {
    return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
  }
  function sigma1(x, xl) {
    return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
  }
  function Gamma0(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
  }
  function Gamma0l(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
  }
  function Gamma1(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
  }
  function Gamma1l(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
  }
  function getCarry(a, b) {
    return a >>> 0 < b >>> 0 ? 1 : 0;
  }
  Sha512.prototype._update = function(M) {
    var W2 = this._w;
    var ah = this._ah | 0;
    var bh = this._bh | 0;
    var ch2 = this._ch | 0;
    var dh = this._dh | 0;
    var eh = this._eh | 0;
    var fh = this._fh | 0;
    var gh = this._gh | 0;
    var hh = this._hh | 0;
    var al = this._al | 0;
    var bl = this._bl | 0;
    var cl = this._cl | 0;
    var dl = this._dl | 0;
    var el = this._el | 0;
    var fl = this._fl | 0;
    var gl = this._gl | 0;
    var hl2 = this._hl | 0;
    for (var i2 = 0; i2 < 32; i2 += 2) {
      W2[i2] = M.readInt32BE(i2 * 4);
      W2[i2 + 1] = M.readInt32BE(i2 * 4 + 4);
    }
    for (; i2 < 160; i2 += 2) {
      var xh = W2[i2 - 15 * 2];
      var xl = W2[i2 - 15 * 2 + 1];
      var gamma02 = Gamma0(xh, xl);
      var gamma0l = Gamma0l(xl, xh);
      xh = W2[i2 - 2 * 2];
      xl = W2[i2 - 2 * 2 + 1];
      var gamma12 = Gamma1(xh, xl);
      var gamma1l = Gamma1l(xl, xh);
      var Wi7h = W2[i2 - 7 * 2];
      var Wi7l = W2[i2 - 7 * 2 + 1];
      var Wi16h = W2[i2 - 16 * 2];
      var Wi16l = W2[i2 - 16 * 2 + 1];
      var Wil = gamma0l + Wi7l | 0;
      var Wih = gamma02 + Wi7h + getCarry(Wil, gamma0l) | 0;
      Wil = Wil + gamma1l | 0;
      Wih = Wih + gamma12 + getCarry(Wil, gamma1l) | 0;
      Wil = Wil + Wi16l | 0;
      Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
      W2[i2] = Wih;
      W2[i2 + 1] = Wil;
    }
    for (var j = 0; j < 160; j += 2) {
      Wih = W2[j];
      Wil = W2[j + 1];
      var majh = maj(ah, bh, ch2);
      var majl = maj(al, bl, cl);
      var sigma0h = sigma0(ah, al);
      var sigma0l = sigma0(al, ah);
      var sigma1h = sigma1(eh, el);
      var sigma1l = sigma1(el, eh);
      var Kih = K[j];
      var Kil = K[j + 1];
      var chh = Ch(eh, fh, gh);
      var chl = Ch(el, fl, gl);
      var t1l = hl2 + sigma1l | 0;
      var t1h = hh + sigma1h + getCarry(t1l, hl2) | 0;
      t1l = t1l + chl | 0;
      t1h = t1h + chh + getCarry(t1l, chl) | 0;
      t1l = t1l + Kil | 0;
      t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
      t1l = t1l + Wil | 0;
      t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
      var t2l = sigma0l + majl | 0;
      var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
      hh = gh;
      hl2 = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      el = dl + t1l | 0;
      eh = dh + t1h + getCarry(el, dl) | 0;
      dh = ch2;
      dl = cl;
      ch2 = bh;
      cl = bl;
      bh = ah;
      bl = al;
      al = t1l + t2l | 0;
      ah = t1h + t2h + getCarry(al, t1l) | 0;
    }
    this._al = this._al + al | 0;
    this._bl = this._bl + bl | 0;
    this._cl = this._cl + cl | 0;
    this._dl = this._dl + dl | 0;
    this._el = this._el + el | 0;
    this._fl = this._fl + fl | 0;
    this._gl = this._gl + gl | 0;
    this._hl = this._hl + hl2 | 0;
    this._ah = this._ah + ah + getCarry(this._al, al) | 0;
    this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
    this._ch = this._ch + ch2 + getCarry(this._cl, cl) | 0;
    this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
    this._eh = this._eh + eh + getCarry(this._el, el) | 0;
    this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
    this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
    this._hh = this._hh + hh + getCarry(this._hl, hl2) | 0;
  };
  Sha512.prototype._hash = function() {
    var H = Buffer$2.allocUnsafe(64);
    function writeInt64BE(h, l, offset) {
      H.writeInt32BE(h, offset);
      H.writeInt32BE(l, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    writeInt64BE(this._gh, this._gl, 48);
    writeInt64BE(this._hh, this._hl, 56);
    return H;
  };
  var sha512 = Sha512;
  var inherits$2 = inherits_browserExports$1;
  var SHA512 = sha512;
  var Hash$1 = hash;
  var Buffer$1 = safeBufferExports.Buffer;
  var W = new Array(160);
  function Sha384() {
    this.init();
    this._w = W;
    Hash$1.call(this, 128, 112);
  }
  inherits$2(Sha384, SHA512);
  Sha384.prototype.init = function() {
    this._ah = 3418070365;
    this._bh = 1654270250;
    this._ch = 2438529370;
    this._dh = 355462360;
    this._eh = 1731405415;
    this._fh = 2394180231;
    this._gh = 3675008525;
    this._hh = 1203062813;
    this._al = 3238371032;
    this._bl = 914150663;
    this._cl = 812702999;
    this._dl = 4144912697;
    this._el = 4290775857;
    this._fl = 1750603025;
    this._gl = 1694076839;
    this._hl = 3204075428;
    return this;
  };
  Sha384.prototype._hash = function() {
    var H = Buffer$1.allocUnsafe(48);
    function writeInt64BE(h, l, offset) {
      H.writeInt32BE(h, offset);
      H.writeInt32BE(l, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    return H;
  };
  var sha384 = Sha384;
  var exports$1 = sha_js.exports = function SHA(algorithm2) {
    algorithm2 = algorithm2.toLowerCase();
    var Algorithm = exports$1[algorithm2];
    if (!Algorithm)
      throw new Error(algorithm2 + " is not supported (we accept pull requests)");
    return new Algorithm();
  };
  exports$1.sha = sha$1;
  exports$1.sha1 = sha1;
  exports$1.sha224 = sha224;
  exports$1.sha256 = sha256;
  exports$1.sha384 = sha384;
  exports$1.sha512 = sha512;
  var sha_jsExports = sha_js.exports;
  var Buffer = safeBufferExports.Buffer;
  var Transform = require$$1$1.Transform;
  var StringDecoder = string_decoder.StringDecoder;
  var inherits$1 = inherits_browserExports$1;
  function CipherBase(hashMode) {
    Transform.call(this);
    this.hashMode = typeof hashMode === "string";
    if (this.hashMode) {
      this[hashMode] = this._finalOrDigest;
    } else {
      this.final = this._finalOrDigest;
    }
    if (this._final) {
      this.__final = this._final;
      this._final = null;
    }
    this._decoder = null;
    this._encoding = null;
  }
  inherits$1(CipherBase, Transform);
  CipherBase.prototype.update = function(data2, inputEnc, outputEnc) {
    if (typeof data2 === "string") {
      data2 = Buffer.from(data2, inputEnc);
    }
    var outData = this._update(data2);
    if (this.hashMode)
      return this;
    if (outputEnc) {
      outData = this._toString(outData, outputEnc);
    }
    return outData;
  };
  CipherBase.prototype.setAutoPadding = function() {
  };
  CipherBase.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  };
  CipherBase.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  };
  CipherBase.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  };
  CipherBase.prototype._transform = function(data2, _2, next) {
    var err;
    try {
      if (this.hashMode) {
        this._update(data2);
      } else {
        this.push(this._update(data2));
      }
    } catch (e) {
      err = e;
    } finally {
      next(err);
    }
  };
  CipherBase.prototype._flush = function(done2) {
    var err;
    try {
      this.push(this.__final());
    } catch (e) {
      err = e;
    }
    done2(err);
  };
  CipherBase.prototype._finalOrDigest = function(outputEnc) {
    var outData = this.__final() || Buffer.alloc(0);
    if (outputEnc) {
      outData = this._toString(outData, outputEnc, true);
    }
    return outData;
  };
  CipherBase.prototype._toString = function(value, enc, fin) {
    if (!this._decoder) {
      this._decoder = new StringDecoder(enc);
      this._encoding = enc;
    }
    if (this._encoding !== enc)
      throw new Error("can't switch encodings");
    var out = this._decoder.write(value);
    if (fin) {
      out += this._decoder.end();
    }
    return out;
  };
  var cipherBase = CipherBase;
  var inherits = inherits_browserExports$1;
  var MD5 = md5_js;
  var RIPEMD160 = ripemd160;
  var sha = sha_jsExports;
  var Base = cipherBase;
  function Hash(hash2) {
    Base.call(this, "digest");
    this._hash = hash2;
  }
  inherits(Hash, Base);
  Hash.prototype._update = function(data2) {
    this._hash.update(data2);
  };
  Hash.prototype._final = function() {
    return this._hash.digest();
  };
  var browser = function createHash(alg) {
    alg = alg.toLowerCase();
    if (alg === "md5")
      return new MD5();
    if (alg === "rmd160" || alg === "ripemd160")
      return new RIPEMD160();
    return new Hash(sha(alg));
  };
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rlphash = exports2.ripemd160FromArray = exports2.ripemd160FromString = exports2.ripemd160 = exports2.sha256FromArray = exports2.sha256FromString = exports2.sha256 = exports2.keccakFromArray = exports2.keccakFromHexString = exports2.keccakFromString = exports2.keccak256 = exports2.keccak = void 0;
    var keccak_1 = keccak$2;
    var createHash = browser;
    var externals_12 = externals;
    var bytes_12 = bytes;
    var helpers_12 = helpers;
    var keccak2 = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      (0, helpers_12.assertIsBuffer)(a);
      switch (bits) {
        case 224: {
          return (0, keccak_1.keccak224)(a);
        }
        case 256: {
          return (0, keccak_1.keccak256)(a);
        }
        case 384: {
          return (0, keccak_1.keccak384)(a);
        }
        case 512: {
          return (0, keccak_1.keccak512)(a);
        }
        default: {
          throw new Error("Invald algorithm: keccak".concat(bits));
        }
      }
    };
    exports2.keccak = keccak2;
    var keccak2562 = function(a) {
      return (0, exports2.keccak)(a);
    };
    exports2.keccak256 = keccak2562;
    var keccakFromString = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      (0, helpers_12.assertIsString)(a);
      var buf = buffer$2.Buffer.from(a, "utf8");
      return (0, exports2.keccak)(buf, bits);
    };
    exports2.keccakFromString = keccakFromString;
    var keccakFromHexString = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      (0, helpers_12.assertIsHexString)(a);
      return (0, exports2.keccak)((0, bytes_12.toBuffer)(a), bits);
    };
    exports2.keccakFromHexString = keccakFromHexString;
    var keccakFromArray = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      (0, helpers_12.assertIsArray)(a);
      return (0, exports2.keccak)((0, bytes_12.toBuffer)(a), bits);
    };
    exports2.keccakFromArray = keccakFromArray;
    var _sha256 = function(a) {
      a = (0, bytes_12.toBuffer)(a);
      return createHash("sha256").update(a).digest();
    };
    var sha2562 = function(a) {
      (0, helpers_12.assertIsBuffer)(a);
      return _sha256(a);
    };
    exports2.sha256 = sha2562;
    var sha256FromString = function(a) {
      (0, helpers_12.assertIsString)(a);
      return _sha256(a);
    };
    exports2.sha256FromString = sha256FromString;
    var sha256FromArray = function(a) {
      (0, helpers_12.assertIsArray)(a);
      return _sha256(a);
    };
    exports2.sha256FromArray = sha256FromArray;
    var _ripemd160 = function(a, padded) {
      a = (0, bytes_12.toBuffer)(a);
      var hash2 = createHash("rmd160").update(a).digest();
      if (padded === true) {
        return (0, bytes_12.setLengthLeft)(hash2, 32);
      } else {
        return hash2;
      }
    };
    var ripemd1602 = function(a, padded) {
      (0, helpers_12.assertIsBuffer)(a);
      return _ripemd160(a, padded);
    };
    exports2.ripemd160 = ripemd1602;
    var ripemd160FromString = function(a, padded) {
      (0, helpers_12.assertIsString)(a);
      return _ripemd160(a, padded);
    };
    exports2.ripemd160FromString = ripemd160FromString;
    var ripemd160FromArray = function(a, padded) {
      (0, helpers_12.assertIsArray)(a);
      return _ripemd160(a, padded);
    };
    exports2.ripemd160FromArray = ripemd160FromArray;
    var rlphash = function(a) {
      return (0, exports2.keccak)(externals_12.rlp.encode(a));
    };
    exports2.rlphash = rlphash;
  })(hash$1);
  var types = {};
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toType = exports2.TypeOutput = exports2.bnToRlp = exports2.bnToUnpaddedBuffer = exports2.bnToHex = void 0;
    var externals_12 = externals;
    var internal_12 = internal;
    var bytes_12 = bytes;
    function bnToHex(value) {
      return "0x".concat(value.toString(16));
    }
    exports2.bnToHex = bnToHex;
    function bnToUnpaddedBuffer(value) {
      return (0, bytes_12.unpadBuffer)(value.toArrayLike(buffer$2.Buffer));
    }
    exports2.bnToUnpaddedBuffer = bnToUnpaddedBuffer;
    function bnToRlp(value) {
      return bnToUnpaddedBuffer(value);
    }
    exports2.bnToRlp = bnToRlp;
    var TypeOutput;
    (function(TypeOutput2) {
      TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
      TypeOutput2[TypeOutput2["BN"] = 1] = "BN";
      TypeOutput2[TypeOutput2["Buffer"] = 2] = "Buffer";
      TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
    })(TypeOutput = exports2.TypeOutput || (exports2.TypeOutput = {}));
    function toType(input2, outputType) {
      if (input2 === null) {
        return null;
      }
      if (input2 === void 0) {
        return void 0;
      }
      if (typeof input2 === "string" && !(0, internal_12.isHexString)(input2)) {
        throw new Error("A string must be provided with a 0x-prefix, given: ".concat(input2));
      } else if (typeof input2 === "number" && !Number.isSafeInteger(input2)) {
        throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
      }
      var output2 = (0, bytes_12.toBuffer)(input2);
      if (outputType === TypeOutput.Buffer) {
        return output2;
      } else if (outputType === TypeOutput.BN) {
        return new externals_12.BN(output2);
      } else if (outputType === TypeOutput.Number) {
        var bn2 = new externals_12.BN(output2);
        var max2 = new externals_12.BN(Number.MAX_SAFE_INTEGER.toString());
        if (bn2.gt(max2)) {
          throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
        }
        return bn2.toNumber();
      } else {
        return "0x".concat(output2.toString("hex"));
      }
    }
    exports2.toType = toType;
  })(types);
  (function(exports2) {
    var __read = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i2 = m.call(o), r2, ar = [], e;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
          ar.push(r2.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m = i2["return"]))
            m.call(i2);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isZeroAddress = exports2.zeroAddress = exports2.importPublic = exports2.privateToAddress = exports2.privateToPublic = exports2.publicToAddress = exports2.pubToAddress = exports2.isValidPublic = exports2.isValidPrivate = exports2.generateAddress2 = exports2.generateAddress = exports2.isValidChecksumAddress = exports2.toChecksumAddress = exports2.isValidAddress = exports2.Account = void 0;
    var assert_12 = __importDefault2(requireAssert());
    var externals_12 = externals;
    var secp256k1_12 = secp256k1;
    var internal_12 = internal;
    var constants_1 = constants;
    var bytes_12 = bytes;
    var hash_12 = hash$1;
    var helpers_12 = helpers;
    var types_12 = types;
    var Account = (
      /** @class */
      function() {
        function Account2(nonce, balance, stateRoot, codeHash) {
          if (nonce === void 0) {
            nonce = new externals_12.BN(0);
          }
          if (balance === void 0) {
            balance = new externals_12.BN(0);
          }
          if (stateRoot === void 0) {
            stateRoot = constants_1.KECCAK256_RLP;
          }
          if (codeHash === void 0) {
            codeHash = constants_1.KECCAK256_NULL;
          }
          this.nonce = nonce;
          this.balance = balance;
          this.stateRoot = stateRoot;
          this.codeHash = codeHash;
          this._validate();
        }
        Account2.fromAccountData = function(accountData) {
          var nonce = accountData.nonce, balance = accountData.balance, stateRoot = accountData.stateRoot, codeHash = accountData.codeHash;
          return new Account2(nonce ? new externals_12.BN((0, bytes_12.toBuffer)(nonce)) : void 0, balance ? new externals_12.BN((0, bytes_12.toBuffer)(balance)) : void 0, stateRoot ? (0, bytes_12.toBuffer)(stateRoot) : void 0, codeHash ? (0, bytes_12.toBuffer)(codeHash) : void 0);
        };
        Account2.fromRlpSerializedAccount = function(serialized) {
          var values = externals_12.rlp.decode(serialized);
          if (!Array.isArray(values)) {
            throw new Error("Invalid serialized account input. Must be array");
          }
          return this.fromValuesArray(values);
        };
        Account2.fromValuesArray = function(values) {
          var _a2 = __read(values, 4), nonce = _a2[0], balance = _a2[1], stateRoot = _a2[2], codeHash = _a2[3];
          return new Account2(new externals_12.BN(nonce), new externals_12.BN(balance), stateRoot, codeHash);
        };
        Account2.prototype._validate = function() {
          if (this.nonce.lt(new externals_12.BN(0))) {
            throw new Error("nonce must be greater than zero");
          }
          if (this.balance.lt(new externals_12.BN(0))) {
            throw new Error("balance must be greater than zero");
          }
          if (this.stateRoot.length !== 32) {
            throw new Error("stateRoot must have a length of 32");
          }
          if (this.codeHash.length !== 32) {
            throw new Error("codeHash must have a length of 32");
          }
        };
        Account2.prototype.raw = function() {
          return [
            (0, types_12.bnToUnpaddedBuffer)(this.nonce),
            (0, types_12.bnToUnpaddedBuffer)(this.balance),
            this.stateRoot,
            this.codeHash
          ];
        };
        Account2.prototype.serialize = function() {
          return externals_12.rlp.encode(this.raw());
        };
        Account2.prototype.isContract = function() {
          return !this.codeHash.equals(constants_1.KECCAK256_NULL);
        };
        Account2.prototype.isEmpty = function() {
          return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);
        };
        return Account2;
      }()
    );
    exports2.Account = Account;
    var isValidAddress = function(hexAddress) {
      try {
        (0, helpers_12.assertIsString)(hexAddress);
      } catch (e) {
        return false;
      }
      return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
    };
    exports2.isValidAddress = isValidAddress;
    var toChecksumAddress = function(hexAddress, eip1191ChainId) {
      (0, helpers_12.assertIsHexString)(hexAddress);
      var address2 = (0, internal_12.stripHexPrefix)(hexAddress).toLowerCase();
      var prefix = "";
      if (eip1191ChainId) {
        var chainId = (0, types_12.toType)(eip1191ChainId, types_12.TypeOutput.BN);
        prefix = chainId.toString() + "0x";
      }
      var hash2 = (0, hash_12.keccakFromString)(prefix + address2).toString("hex");
      var ret = "0x";
      for (var i2 = 0; i2 < address2.length; i2++) {
        if (parseInt(hash2[i2], 16) >= 8) {
          ret += address2[i2].toUpperCase();
        } else {
          ret += address2[i2];
        }
      }
      return ret;
    };
    exports2.toChecksumAddress = toChecksumAddress;
    var isValidChecksumAddress = function(hexAddress, eip1191ChainId) {
      return (0, exports2.isValidAddress)(hexAddress) && (0, exports2.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;
    };
    exports2.isValidChecksumAddress = isValidChecksumAddress;
    var generateAddress = function(from, nonce) {
      (0, helpers_12.assertIsBuffer)(from);
      (0, helpers_12.assertIsBuffer)(nonce);
      var nonceBN = new externals_12.BN(nonce);
      if (nonceBN.isZero()) {
        return (0, hash_12.rlphash)([from, null]).slice(-20);
      }
      return (0, hash_12.rlphash)([from, buffer$2.Buffer.from(nonceBN.toArray())]).slice(-20);
    };
    exports2.generateAddress = generateAddress;
    var generateAddress2 = function(from, salt, initCode) {
      (0, helpers_12.assertIsBuffer)(from);
      (0, helpers_12.assertIsBuffer)(salt);
      (0, helpers_12.assertIsBuffer)(initCode);
      (0, assert_12.default)(from.length === 20);
      (0, assert_12.default)(salt.length === 32);
      var address2 = (0, hash_12.keccak256)(buffer$2.Buffer.concat([buffer$2.Buffer.from("ff", "hex"), from, salt, (0, hash_12.keccak256)(initCode)]));
      return address2.slice(-20);
    };
    exports2.generateAddress2 = generateAddress2;
    var isValidPrivate = function(privateKey) {
      return (0, secp256k1_12.privateKeyVerify)(privateKey);
    };
    exports2.isValidPrivate = isValidPrivate;
    var isValidPublic = function(publicKey, sanitize) {
      if (sanitize === void 0) {
        sanitize = false;
      }
      (0, helpers_12.assertIsBuffer)(publicKey);
      if (publicKey.length === 64) {
        return (0, secp256k1_12.publicKeyVerify)(buffer$2.Buffer.concat([buffer$2.Buffer.from([4]), publicKey]));
      }
      if (!sanitize) {
        return false;
      }
      return (0, secp256k1_12.publicKeyVerify)(publicKey);
    };
    exports2.isValidPublic = isValidPublic;
    var pubToAddress = function(pubKey, sanitize) {
      if (sanitize === void 0) {
        sanitize = false;
      }
      (0, helpers_12.assertIsBuffer)(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = buffer$2.Buffer.from((0, secp256k1_12.publicKeyConvert)(pubKey, false).slice(1));
      }
      (0, assert_12.default)(pubKey.length === 64);
      return (0, hash_12.keccak)(pubKey).slice(-20);
    };
    exports2.pubToAddress = pubToAddress;
    exports2.publicToAddress = exports2.pubToAddress;
    var privateToPublic = function(privateKey) {
      (0, helpers_12.assertIsBuffer)(privateKey);
      return buffer$2.Buffer.from((0, secp256k1_12.publicKeyCreate)(privateKey, false)).slice(1);
    };
    exports2.privateToPublic = privateToPublic;
    var privateToAddress = function(privateKey) {
      return (0, exports2.publicToAddress)((0, exports2.privateToPublic)(privateKey));
    };
    exports2.privateToAddress = privateToAddress;
    var importPublic = function(publicKey) {
      (0, helpers_12.assertIsBuffer)(publicKey);
      if (publicKey.length !== 64) {
        publicKey = buffer$2.Buffer.from((0, secp256k1_12.publicKeyConvert)(publicKey, false).slice(1));
      }
      return publicKey;
    };
    exports2.importPublic = importPublic;
    var zeroAddress = function() {
      var addressLength = 20;
      var addr = (0, bytes_12.zeros)(addressLength);
      return (0, bytes_12.bufferToHex)(addr);
    };
    exports2.zeroAddress = zeroAddress;
    var isZeroAddress = function(hexAddress) {
      try {
        (0, helpers_12.assertIsString)(hexAddress);
      } catch (e) {
        return false;
      }
      var zeroAddr = (0, exports2.zeroAddress)();
      return zeroAddr === hexAddress;
    };
    exports2.isZeroAddress = isZeroAddress;
  })(account);
  var address = {};
  var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(address, "__esModule", { value: true });
  address.Address = void 0;
  var assert_1$1 = __importDefault$1(requireAssert());
  var externals_1$2 = externals;
  var bytes_1$2 = bytes;
  var account_1 = account;
  var Address = (
    /** @class */
    function() {
      function Address2(buf) {
        (0, assert_1$1.default)(buf.length === 20, "Invalid address length");
        this.buf = buf;
      }
      Address2.zero = function() {
        return new Address2((0, bytes_1$2.zeros)(20));
      };
      Address2.fromString = function(str) {
        (0, assert_1$1.default)((0, account_1.isValidAddress)(str), "Invalid address");
        return new Address2((0, bytes_1$2.toBuffer)(str));
      };
      Address2.fromPublicKey = function(pubKey) {
        (0, assert_1$1.default)(buffer$2.Buffer.isBuffer(pubKey), "Public key should be Buffer");
        var buf = (0, account_1.pubToAddress)(pubKey);
        return new Address2(buf);
      };
      Address2.fromPrivateKey = function(privateKey) {
        (0, assert_1$1.default)(buffer$2.Buffer.isBuffer(privateKey), "Private key should be Buffer");
        var buf = (0, account_1.privateToAddress)(privateKey);
        return new Address2(buf);
      };
      Address2.generate = function(from, nonce) {
        (0, assert_1$1.default)(externals_1$2.BN.isBN(nonce));
        return new Address2((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(buffer$2.Buffer)));
      };
      Address2.generate2 = function(from, salt, initCode) {
        (0, assert_1$1.default)(buffer$2.Buffer.isBuffer(salt));
        (0, assert_1$1.default)(buffer$2.Buffer.isBuffer(initCode));
        return new Address2((0, account_1.generateAddress2)(from.buf, salt, initCode));
      };
      Address2.prototype.equals = function(address2) {
        return this.buf.equals(address2.buf);
      };
      Address2.prototype.isZero = function() {
        return this.equals(Address2.zero());
      };
      Address2.prototype.isPrecompileOrSystemAddress = function() {
        var addressBN = new externals_1$2.BN(this.buf);
        var rangeMin = new externals_1$2.BN(0);
        var rangeMax = new externals_1$2.BN("ffff", "hex");
        return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);
      };
      Address2.prototype.toString = function() {
        return "0x" + this.buf.toString("hex");
      };
      Address2.prototype.toBuffer = function() {
        return buffer$2.Buffer.from(this.buf);
      };
      return Address2;
    }()
  );
  address.Address = Address;
  var signature = {};
  Object.defineProperty(signature, "__esModule", { value: true });
  signature.hashPersonalMessage = signature.isValidSignature = signature.fromRpcSig = signature.toCompactSig = signature.toRpcSig = signature.ecrecover = signature.ecsign = void 0;
  var secp256k1_1 = secp256k1;
  var externals_1$1 = externals;
  var bytes_1$1 = bytes;
  var hash_1 = hash$1;
  var helpers_1 = helpers;
  var types_1 = types;
  function ecsign(msgHash, privateKey, chainId) {
    var _a2 = (0, secp256k1_1.ecdsaSign)(msgHash, privateKey), signature2 = _a2.signature, recovery = _a2.recid;
    var r2 = buffer$2.Buffer.from(signature2.slice(0, 32));
    var s2 = buffer$2.Buffer.from(signature2.slice(32, 64));
    if (!chainId || typeof chainId === "number") {
      if (chainId && !Number.isSafeInteger(chainId)) {
        throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
      }
      var v_1 = chainId ? recovery + (chainId * 2 + 35) : recovery + 27;
      return { r: r2, s: s2, v: v_1 };
    }
    var chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);
    var v = chainIdBN.muln(2).addn(35).addn(recovery).toArrayLike(buffer$2.Buffer);
    return { r: r2, s: s2, v };
  }
  signature.ecsign = ecsign;
  function calculateSigRecovery(v, chainId) {
    var vBN = (0, types_1.toType)(v, types_1.TypeOutput.BN);
    if (vBN.eqn(0) || vBN.eqn(1))
      return (0, types_1.toType)(v, types_1.TypeOutput.BN);
    if (!chainId) {
      return vBN.subn(27);
    }
    var chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);
    return vBN.sub(chainIdBN.muln(2).addn(35));
  }
  function isValidSigRecovery(recovery) {
    var rec = new externals_1$1.BN(recovery);
    return rec.eqn(0) || rec.eqn(1);
  }
  var ecrecover = function(msgHash, v, r2, s2, chainId) {
    var signature2 = buffer$2.Buffer.concat([(0, bytes_1$1.setLengthLeft)(r2, 32), (0, bytes_1$1.setLengthLeft)(s2, 32)], 64);
    var recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
      throw new Error("Invalid signature v value");
    }
    var senderPubKey = (0, secp256k1_1.ecdsaRecover)(signature2, recovery.toNumber(), msgHash);
    return buffer$2.Buffer.from((0, secp256k1_1.publicKeyConvert)(senderPubKey, false).slice(1));
  };
  signature.ecrecover = ecrecover;
  var toRpcSig = function(v, r2, s2, chainId) {
    var recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
      throw new Error("Invalid signature v value");
    }
    return (0, bytes_1$1.bufferToHex)(buffer$2.Buffer.concat([(0, bytes_1$1.setLengthLeft)(r2, 32), (0, bytes_1$1.setLengthLeft)(s2, 32), (0, bytes_1$1.toBuffer)(v)]));
  };
  signature.toRpcSig = toRpcSig;
  var toCompactSig = function(v, r2, s2, chainId) {
    var recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
      throw new Error("Invalid signature v value");
    }
    var vn = (0, types_1.toType)(v, types_1.TypeOutput.Number);
    var ss = s2;
    if (vn > 28 && vn % 2 === 1 || vn === 1 || vn === 28) {
      ss = buffer$2.Buffer.from(s2);
      ss[0] |= 128;
    }
    return (0, bytes_1$1.bufferToHex)(buffer$2.Buffer.concat([(0, bytes_1$1.setLengthLeft)(r2, 32), (0, bytes_1$1.setLengthLeft)(ss, 32)]));
  };
  signature.toCompactSig = toCompactSig;
  var fromRpcSig = function(sig) {
    var buf = (0, bytes_1$1.toBuffer)(sig);
    var r2;
    var s2;
    var v;
    if (buf.length >= 65) {
      r2 = buf.slice(0, 32);
      s2 = buf.slice(32, 64);
      v = (0, bytes_1$1.bufferToInt)(buf.slice(64));
    } else if (buf.length === 64) {
      r2 = buf.slice(0, 32);
      s2 = buf.slice(32, 64);
      v = (0, bytes_1$1.bufferToInt)(buf.slice(32, 33)) >> 7;
      s2[0] &= 127;
    } else {
      throw new Error("Invalid signature length");
    }
    if (v < 27) {
      v += 27;
    }
    return {
      v,
      r: r2,
      s: s2
    };
  };
  signature.fromRpcSig = fromRpcSig;
  var isValidSignature = function(v, r2, s2, homesteadOrLater, chainId) {
    if (homesteadOrLater === void 0) {
      homesteadOrLater = true;
    }
    var SECP256K1_N_DIV_2 = new externals_1$1.BN("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
    var SECP256K1_N = new externals_1$1.BN("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
    if (r2.length !== 32 || s2.length !== 32) {
      return false;
    }
    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
      return false;
    }
    var rBN = new externals_1$1.BN(r2);
    var sBN = new externals_1$1.BN(s2);
    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
      return false;
    }
    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
      return false;
    }
    return true;
  };
  signature.isValidSignature = isValidSignature;
  var hashPersonalMessage = function(message2) {
    (0, helpers_1.assertIsBuffer)(message2);
    var prefix = buffer$2.Buffer.from("Ethereum Signed Message:\n".concat(message2.length), "utf-8");
    return (0, hash_1.keccak)(buffer$2.Buffer.concat([prefix, message2]));
  };
  signature.hashPersonalMessage = hashPersonalMessage;
  var object = {};
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(object, "__esModule", { value: true });
  object.defineProperties = void 0;
  var assert_1 = __importDefault(requireAssert());
  var internal_1 = internal;
  var externals_1 = externals;
  var bytes_1 = bytes;
  var defineProperties = function(self2, fields, data2) {
    self2.raw = [];
    self2._fields = [];
    self2.toJSON = function(label) {
      if (label === void 0) {
        label = false;
      }
      if (label) {
        var obj_1 = {};
        self2._fields.forEach(function(field) {
          obj_1[field] = "0x".concat(self2[field].toString("hex"));
        });
        return obj_1;
      }
      return (0, bytes_1.baToJSON)(self2.raw);
    };
    self2.serialize = function serialize() {
      return externals_1.rlp.encode(self2.raw);
    };
    fields.forEach(function(field, i2) {
      self2._fields.push(field.name);
      function getter() {
        return self2.raw[i2];
      }
      function setter(v) {
        v = (0, bytes_1.toBuffer)(v);
        if (v.toString("hex") === "00" && !field.allowZero) {
          v = buffer$2.Buffer.allocUnsafe(0);
        }
        if (field.allowLess && field.length) {
          v = (0, bytes_1.unpadBuffer)(v);
          (0, assert_1.default)(field.length >= v.length, "The field ".concat(field.name, " must not have more ").concat(field.length, " bytes"));
        } else if (!(field.allowZero && v.length === 0) && field.length) {
          (0, assert_1.default)(field.length === v.length, "The field ".concat(field.name, " must have byte length of ").concat(field.length));
        }
        self2.raw[i2] = v;
      }
      Object.defineProperty(self2, field.name, {
        enumerable: true,
        configurable: true,
        get: getter,
        set: setter
      });
      if (field.default) {
        self2[field.name] = field.default;
      }
      if (field.alias) {
        Object.defineProperty(self2, field.alias, {
          enumerable: false,
          configurable: true,
          set: setter,
          get: getter
        });
      }
    });
    if (data2) {
      if (typeof data2 === "string") {
        data2 = buffer$2.Buffer.from((0, internal_1.stripHexPrefix)(data2), "hex");
      }
      if (buffer$2.Buffer.isBuffer(data2)) {
        data2 = externals_1.rlp.decode(data2);
      }
      if (Array.isArray(data2)) {
        if (data2.length > self2._fields.length) {
          throw new Error("wrong number of fields in data");
        }
        data2.forEach(function(d, i2) {
          self2[self2._fields[i2]] = (0, bytes_1.toBuffer)(d);
        });
      } else if (typeof data2 === "object") {
        var keys_1 = Object.keys(data2);
        fields.forEach(function(field) {
          if (keys_1.indexOf(field.name) !== -1)
            self2[field.name] = data2[field.name];
          if (keys_1.indexOf(field.alias) !== -1)
            self2[field.alias] = data2[field.alias];
        });
      } else {
        throw new Error("invalid data");
      }
    }
  };
  object.defineProperties = defineProperties;
  (function(exports2) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m[k2];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding2(exports3, m, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isHexString = exports2.getKeys = exports2.fromAscii = exports2.fromUtf8 = exports2.toAscii = exports2.arrayContainsArray = exports2.getBinarySize = exports2.padToEven = exports2.stripHexPrefix = exports2.isHexPrefixed = void 0;
    __exportStar(constants, exports2);
    __exportStar(account, exports2);
    __exportStar(address, exports2);
    __exportStar(hash$1, exports2);
    __exportStar(signature, exports2);
    __exportStar(bytes, exports2);
    __exportStar(object, exports2);
    __exportStar(externals, exports2);
    __exportStar(types, exports2);
    var internal_12 = internal;
    Object.defineProperty(exports2, "isHexPrefixed", { enumerable: true, get: function() {
      return internal_12.isHexPrefixed;
    } });
    Object.defineProperty(exports2, "stripHexPrefix", { enumerable: true, get: function() {
      return internal_12.stripHexPrefix;
    } });
    Object.defineProperty(exports2, "padToEven", { enumerable: true, get: function() {
      return internal_12.padToEven;
    } });
    Object.defineProperty(exports2, "getBinarySize", { enumerable: true, get: function() {
      return internal_12.getBinarySize;
    } });
    Object.defineProperty(exports2, "arrayContainsArray", { enumerable: true, get: function() {
      return internal_12.arrayContainsArray;
    } });
    Object.defineProperty(exports2, "toAscii", { enumerable: true, get: function() {
      return internal_12.toAscii;
    } });
    Object.defineProperty(exports2, "fromUtf8", { enumerable: true, get: function() {
      return internal_12.fromUtf8;
    } });
    Object.defineProperty(exports2, "fromAscii", { enumerable: true, get: function() {
      return internal_12.fromAscii;
    } });
    Object.defineProperty(exports2, "getKeys", { enumerable: true, get: function() {
      return internal_12.getKeys;
    } });
    Object.defineProperty(exports2, "isHexString", { enumerable: true, get: function() {
      return internal_12.isHexString;
    } });
  })(dist_browser$1);
  globalThis.Buffer = buffer$2.Buffer;
  function toBeHex(data2) {
    return toBeHex$1(BigInt("0x" + data2.toString("hex")), 32);
  }
  function compressedPublicKeyToAddress(compressedPublicKey) {
    const publicKeyBuffer = buffer$2.Buffer.from(compressedPublicKey, "hex");
    const addressBuffer = dist_browser$1.publicToAddress(publicKeyBuffer, true);
    const addressHex = dist_browser$1.bufferToHex(addressBuffer);
    const ethAddress = dist_browser$1.toChecksumAddress(addressHex);
    return ethAddress;
  }
  function convertToEthSignature(bitSignature) {
    const s2 = bitcoreLibExports.crypto.Signature.fromCompact(buffer$2.Buffer.from(bitSignature, "base64"));
    const convertedSign = Signature$6.from({
      r: toBeHex(s2.r.toBuffer()),
      s: toBeHex(s2.s.toBuffer()),
      v: s2.i ? 28 : 27
    });
    return convertedSign.serialized;
  }
  function verifyBitSignatureWithEthAddress(bitSignature, message2, ethAddress) {
    const digest = "0x" + new bitcoreLibExports.Message(message2).magicHash().toString("hex");
    const ethSignature = convertToEthSignature(bitSignature);
    return recoverAddress(digest, ethSignature) === ethAddress;
  }
  exports.compressedPublicKeyToAddress = compressedPublicKeyToAddress;
  exports.convertToEthSignature = convertToEthSignature;
  exports.verifyBitSignatureWithEthAddress = verifyBitSignatureWithEthAddress;
  Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
});
